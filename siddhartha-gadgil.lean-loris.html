<html>
<head>
<meta charset="utf-8"></meta><title>siddhartha-gadgil/lean-loris</title>
<link rel="stylesheet" href="./static/style.css"></link></head>
<body>
<header>
<h1>
<a href="./">Reservoir</a>
</h1>
<input placeholder="Text in here to navigate!"></input><ul>
<li>
<a href="#">About</a>
</li>
<li>
<a href="#">New</a>
</li>
<li>
<a href="#">Trending</a>
</li>
</ul>
</header>
<main>
<h1>siddhartha-gadgil/lean-loris</h1>
<p>Experiments with some ways of automating reasoning in lean 4</p>
<a href="https://github.com/siddhartha-gadgil/lean-loris">GitHub Link</a>
<a href="#" title="Missing now!">Documentation</a>
<h2>Pick a version!</h2>
<p>TODO: should show a time axes that allows the users to view, filter and click copy the lakefile config.</p>
<h2>README</h2>
<div class="md" data-path="README.md" id="readme"><article class="markdown-body entry-content container-lg" itemprop="text"><h3 dir="auto">Lean Loris</h3>
<p dir="auto">This is a repository for experiments with some ways of automating reasoning in lean 4, especially <em>forward reasoning</em> and <em>mixed reasoning</em>, to complement the existing <em>backward reasoning</em> used in tactics.</p>
<h3 dir="auto">Illustrations: in compiled code and interactive mode.</h3>
<p dir="auto">Our two main illustrations, one for forward reasoning and one for mixed reasoning, are too resource intensive to run in the interpreter. They are included as two of the three options in the compiled code (the third is generation of data for machine learning).</p>
<h4 dir="auto">Forward reasoning examples</h4>
<p dir="auto">We illustrate <em>purely forward</em> reasoning, i.e., reasoning where no goal or intermediate claims are used in the evolution. These can (and are) specified only to be used for logging.</p>
<h5 dir="auto">Main example: A Czech-Slovak olympiad problem</h5>
<p dir="auto">Our main model problem for forward reasoning is the following from a Czech-Slovak Olympiad:</p>
<p dir="auto">Let <code>M</code> be a set with a product. Given the axioms:</p>
<ul dir="auto">
<li><code>∀ a b : M, (a * b) * b = a</code>,</li>
<li><code>∀ a b : M, a * (a * b) = b</code>,</li>
</ul>
<p dir="auto">for arbitrary elements <code>m</code> and <code>n</code> in <code>M</code>, we have <code>m * n = n * m</code>.</p>
<p dir="auto">We fix <code>m</code> and <code>n</code> and reason forward starting with <code>m</code>, <code>n</code>, the axioms, and multiplication. Our forward reasoning is tuned for this problem, and also mildly help by including <code>m * n</code> in the initial state. However, the evolution does not use the statement of the problem, any of the lemmas or the proof.</p>
<p dir="auto">To understand the (automated) reasoning steps (and for use during tuning and debugging), some lemmas and the theorem were defined. While running progress in proving these is logged.</p>
<ul dir="auto">
<li><code>def lem1! := (m * n) * n = m</code></li>
<li><code>def lem2! := (m * n) * ((m * n) * n) = n</code></li>
<li><code>def lem3! := ((m * n) * m) * m = m * n</code></li>
<li><code>def lem4! := (m * n) * ((m * n) * n) = (m * n) * m</code></li>
<li><code>def lem5! := (m * n) * m = n</code></li>
<li><code>def lem6! := ((m * n) * m) * m = n * m</code></li>
<li><code>def thm! := m * n = n * m</code></li>
</ul>
<p dir="auto">The forward reasoning we use is mainly function application and closure of equality under symmetry and transitivity. In the latter we implicitly use our key "lemma recognition" principle: proofs of simple statements are treated like simple terms while generating.</p>
<h5 dir="auto">A basic example: left and right identities are equal</h5>
<p dir="auto">Another example of forward reasoning, in <code>ProofExamples.lean</code>, is one of the first abstract results one sees in algebra: given a multiplication on a set <code>α</code> with a left-identity <code>eₗ</code> and a right identity <code>eᵣ</code>, we have <code>eₗ = eᵣ</code>.</p>
<p dir="auto">Our first proof is by forward reasoning using function application and equality closure under symmetry and transitivity. This is fully automatic forward reasoning in a single step.</p>
<p dir="auto">We give a second proof of the result: given a multiplication on a set <code>α</code> with a left-identity <code>eₗ</code> and a right identity <code>eᵣ</code>, we have <code>eₗ = eᵣ</code> to illustrate implicit "lemma choosing". Notice that the cut-off is just <code>1</code> for both steps. However the proof is obtained as during equality generation, we look-ahead and generate proofs of statements that are simple.</p>
<h4 dir="auto">Mixed reasoning examples</h4>
<p dir="auto">We illustrate <em>mixed reasoning</em>, where a goal is specified and used in evolution, but generation is not limited to seeking the goal.</p>
<h5 dir="auto">Main example: Locally constant functions are constant</h5>
<p dir="auto">Our main example of mixed reasoning is the result that if <code>f: Nat → α</code> is a function from natural numbers to a type <code>α</code> such that <code>∀ n : Nat, f (n + 1) = f n</code>, then <code>∀n : Nat, f n = f 0</code>, i.e. <code>f</code> is a constant function if it is locally constant.</p>
<p dir="auto">We use two forms of backward reasoning: induction and introduction of variables based on goals (the latter can be replaced by forward reasoning). The forward reasoning we use is mainly function application and closure of equality under symmetry and transitivity. In the latter we implicitly use our key "lemma recognition" principle: proofs of simple statements are treated like simple terms while generating.</p>
<h5 dir="auto">Other examples</h5>
<p dir="auto">We have a few other examples of mixed reasoning, including deriving <em>Modus Ponens</em> starting with just its statement, in <code>ProofExamples.lean</code>.</p>
<h3 dir="auto">Running the code.</h3>
<p dir="auto">Many examples can be viewed by opening the file <code>ProofExamples.lean</code> in a Lean 4 editor, such as <code>vs-code</code> with the <code>lean 4</code> plugin.</p>
<p dir="auto">The following instructions are for linux, and should be appropriately modified for any other OS. Assuming a recent installation of lean 4 (including lake), the following will build the code and show what can be run.</p>
<div class="highlight highlight-source-shell position-relative overflow-auto" data-snippet-clipboard-copy-content="lake build
build/bin/lean-loris"><pre>lake build
build/bin/lean-loris</pre></div>
<p dir="auto">You will see the following output:</p>
<div class="highlight highlight-source-shell position-relative overflow-auto" data-snippet-clipboard-copy-content="Choose one or more of the following:
1. Czech-Slovak Olympiad example
2. Induction: locally constant functions
3. Dependency data generation"><pre>Choose one or more of the following:
1. Czech-Slovak Olympiad example
2. Induction: locally constant functions
3. Dependency data generation</pre></div>
<p dir="auto">To run the Czech-Slovak Olympiad example, which uses purely forward reasoning, use the command:</p>
<div class="highlight highlight-source-shell position-relative overflow-auto" data-snippet-clipboard-copy-content="build/bin/lean-loris 1"><pre>build/bin/lean-loris 1</pre></div>
<p dir="auto">Using argument <code>2</code> runs the mixed reasoning example. The argument <code>3</code> generates data for machine learning.</p>
<h3 dir="auto">Internals and using the code</h3>
<p dir="auto">Documentation will be posted soon, along with a blog post explaining some of the principles behind the code.</p>
</article></div></main>
</body>
</html>