/-
Copyright (c) 2022 Jannis Limperg. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jannis Limperg
-/

import Aesop.Tree.TreeM

open Lean
open Lean.Meta
open Std (HashMap)

/-
To extract a proof, we start in the `MetaM` state in which Aesop was called.
Then we iterate through the proven part of the tree, top to bottom, 'replaying'
the mvar assignments that were performed during the search. This means:

- For each goal `g`, we assign `g`'s pre-norm mvar to the term generated by
  normalisation. If `g` was proved by normalisation, we are done. Otherwise,
  we find the proving child rapp of `g` and descend into it.
- For each rapp `r`, we assign the post-norm mvar of `r`'s parent goal to the
  term generated by `r`. Additionally, we assign each mvar assigned by `r`.
  Then we descend into `r`'s children.
- For each mvar cluster `c`, we find the proven goal of `c` and descend into it.

When we assign a metavariable `m`, we must take some care:

- We must first declare `m` if it is not already declared.
- We must assign (and declare) any metavariables on which the assignment of `m`
  depends. We cannot assume that these assignments are meta-free, since they may
  contain metavariables that were only assigned later during the search. We
  also cannot assume that these are the *only* metavariables occurring in the
  assignments, since they may additionally contain delayed-assigned
  metavariables which depend on the unassigned metavariables.
-/

namespace Aesop

local macro "throwPRError " s:interpolatedStr(term) : term =>
  `(throwError m!"aesop: internal error during proof reconstruction: " ++ m!$s)

private def copyMVarDecl (s : Meta.SavedState) (mvarId : MVarId) :
    MetaM Unit := do
  let decl ← s.runMetaM' $ getMVarDecl mvarId
  modifyMCtx λ mctx => { mctx with decls := mctx.decls.insert mvarId decl }

private partial def copyExprMVarAssignment (s : Meta.SavedState)
    (mvarId : MVarId) : MetaM Unit := do
  if ← isExprMVarAssigned mvarId <||> isDelayedAssigned mvarId then
    return
  unless ← isExprMVarDeclared mvarId do
    copyMVarDecl s mvarId
  let assignment? ← s.runMetaM' do
    if let (some e) ← getExprMVarAssignment? mvarId then
      return some $ Sum.inl (← instantiateMVars e)
    else if let (some d) ← getDelayedAssignment? mvarId then
      return some $ Sum.inr d
    else
      return none
  match assignment? with
  | some (Sum.inl e) =>
    assignExprMVar mvarId e
    for mvarId in ← getMVars e do
      copyExprMVarAssignment s mvarId
  | some (Sum.inr d) =>
    delayedAssignMVar mvarId d
    for mvarId in ← getMVars d.val do
      copyExprMVarAssignment s mvarId
  | none => return

mutual
  private partial def extractProofGoal (g : Goal) : MetaM Unit := do
    match g.normalizationState with
    | NormalizationState.notNormal => throwPRError
      "goal {g.id} was not normalised."
    | NormalizationState.normal postNormGoal postState =>
      copyExprMVarAssignment postState g.preNormGoal
      let rref? ← g.children.findM? λ rref => return (← rref.get).state.isProven
      let (some rref) := rref? | throwPRError
        "goal {g.id} does not have a proven rapp."
      extractProofRapp postNormGoal (← rref.get)
    | NormalizationState.provenByNormalization postState =>
      copyExprMVarAssignment postState g.preNormGoal

  private partial def extractProofRapp (parentGoal : MVarId) (r : Rapp) :
      MetaM Unit := do
    copyExprMVarAssignment r.metaState parentGoal
    for m in r.assignedMVars do
      copyExprMVarAssignment r.metaState m
    r.children.forM λ cref => do extractProofMVarCluster (← cref.get)

  private partial def extractProofMVarCluster (c : MVarCluster) :
      MetaM Unit := do
    let gref? ← c.goals.findM? λ gref => return (← gref.get).state.isProven
    let (some gref) := gref? | throwPRError
      "an mvar cluster does not contain a proven goal (candidate goals: {← c.goals.mapM λ gref => return (← gref.get).id})."
    extractProofGoal (← gref.get)
end

def Goal.extractProof (root : Goal) : MetaM Unit :=
  extractProofGoal root

def extractProof : TreeM Unit := do
  (← (← getRootGoal).get).extractProof

end Aesop
