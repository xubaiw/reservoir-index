import SciLean.Math.Symbolic.Basic
import SciLean.Math.Symbolic.Monomial
import SciLean.Math.Symbolic.FreeAlgebra

namespace SciLean

open Symbolic

variable (Œπ : Type) (K : Type) [Add K] [Mul K] [One K] [Neg K]

def Polynomial := Quot
  (Œª x y : Expr Œπ K =>
    (Expr.EqAlgebra x y) ‚à®
    (Expr.EqCommutative x y))

namespace Polynomial

  variable {Œπ : Type} {K : Type} [Add K] [Mul K] [One K] [Zero K] [Neg K]

  namespace Expr 

    open Symbolic.Expr

    def toString [ToString Œπ] [ToString K] (e : Expr Œπ K): String :=
      match e with
      | zero => "0"
      | one  => "1"
      | var i => s!"x‚ü¶{i}‚üß"
      | neg x => s!"- {toString x}"
      | add x y => s!"({toString x} + {toString y})"
      | mul x y => s!"{toString x} * {toString y}"
      | smul a x => s!"{a} {toString x}"

  end Expr


  notation " ùì¢ùìü[" Œπ ", " K "] " => Polynomial Œπ K
  notation " ùì¢ùìü[" Œπ " ] "       => Polynomial Œπ ‚Ñù
  
  -- I should define FinEnumBasis over some set/ring
  -- notation " ùìü[" V ", " K "] " => Polynomial (FinEnumBasis.index V) K
  notation " ùìü[" V "] " => Polynomial (Basis.Trait.Index V) (Basis.Trait.Coeff V)

  instance : Add (Polynomial Œπ K) :=
    ‚ü®Œª x y => Quot.mk _ <| Quot.lift‚ÇÇ FreeAlgebra.Expr.add sorry sorry x y‚ü©

  instance : Sub (Polynomial Œπ K) :=
    ‚ü®Œª x y => Quot.mk _ <| Quot.lift‚ÇÇ FreeAlgebra.Expr.sub sorry sorry x y‚ü©

  instance : Mul (Polynomial Œπ K) :=
    ‚ü®Œª x y => Quot.mk _ <| Quot.lift‚ÇÇ FreeAlgebra.Expr.mul sorry sorry x y‚ü©

  instance : Neg (Polynomial Œπ K) :=
    ‚ü®Œª x => Quot.mk _ <| Quot.lift FreeAlgebra.Expr.neg sorry x‚ü©

  instance : HMul K (Polynomial Œπ K) (Polynomial Œπ K) :=
    ‚ü®Œª a x => Quot.mk _ <| Quot.lift (FreeAlgebra.Expr.smul a) sorry x‚ü©

  instance : Zero (Polynomial Œπ K) := ‚ü®Quot.mk _ 0‚ü©
  instance : One  (Polynomial Œπ K) := ‚ü®Quot.mk _ 1‚ü©

  -- The string actually depends on the represenative element, 
  -- thus it has to be hidden behind an opaque constant
  -- The sorry here is impossible to be proven
  constant toString' [ToString Œπ] [ToString K] (p : Polynomial Œπ K)  : String :=
    Quot.lift (Œª e : Expr Œπ K => toString e) sorry p

  instance [ToString Œπ] [ToString K] : ToString (Polynomial Œπ K) := ‚ü®toString'‚ü©

  def toVal {R} [CommRing R] (p : Polynomial Œπ R) (vars : Œπ ‚Üí R) : R :=
    Quot.lift (Œª e => e.toVal vars) sorry p

  instance {R} [CommRing R] : CoeFun (Polynomial (Fin 1) R) (Œª _ => R ‚Üí R) 
    := ‚ü®Œª p x => p.toVal Œª _ => x‚ü©
  -- instance {X} [FinEnumBasis X] : CoeFun (Polynomial (Basis.index X) ‚Ñù) (Œª _ => X ‚Üí ‚Ñù) 
  --   := ‚ü®Œª p x => p.toVal Œª i => FinEnumBasis.proj i x‚ü©

  def var {Œπ} (i : Œπ) (K := ‚Ñù) [Add K] [Mul K] [One K] : Polynomial Œπ K 
    := Quot.mk _ (Expr.var i)

  def expand {Œπ} [Zero K]
    [LT Œπ] [‚àÄ i j : Œπ, Decidable (i < j)] [DecidableEq Œπ]
    [LT K] [‚àÄ a b : K, Decidable (a < b)] [DecidableEq K]
    (x : Polynomial Œπ K) : Polynomial Œπ K :=
    Quot.mk _ <|
    Quot.lift 
      (Œª e => e.expand)
      sorry x

  def simplify {Œπ} [Inhabited Œπ]
    [LT Œπ] [‚àÄ i j : Œπ, Decidable (i < j)] [DecidableEq Œπ]
    [LT K] [‚àÄ a b : K, Decidable (a < b)] [DecidableEq K]
    (x : Polynomial Œπ K) : Polynomial Œπ K :=
    Quot.mk _ <| Quot.lift 
      (Œª e =>
         e |> Expr.expand_to_monomials
           |> Array.map Monomial.symReduce
           |> (Array.qsort ¬∑ Monomial.decLt)
           |> Monomial.together
           |> Expr.simplify
      ) sorry x

  notation " x‚ü¶" i ", " K "‚üß " => Polynomial.var (K := K) i
  notation " x‚ü¶" i "‚üß " => Polynomial.var i

  #eval x‚ü¶1‚üß * x‚ü¶0‚üß * ((5 : ‚Ñù) * x‚ü¶1‚üß * x‚ü¶-1‚üß + 1) |> expand
  #eval x‚ü¶1‚üß * x‚ü¶0‚üß * ((5 : ‚Ñù) * x‚ü¶1‚üß * x‚ü¶-1‚üß + 1) + x‚ü¶0‚üß * x‚ü¶1‚üß |> simplify

  #check ùìü[‚Ñù√ó‚Ñù]

  #eval 1.4 * x‚ü¶2‚üß * ((3.0 + 4.0) * x‚ü¶0‚üß + x‚ü¶0‚üß) |> expand
  #eval 1.4 * x‚ü¶2‚üß * ((3.0 + 4.0) * x‚ü¶0‚üß + x‚ü¶0‚üß) |> simplify

end Polynomial
