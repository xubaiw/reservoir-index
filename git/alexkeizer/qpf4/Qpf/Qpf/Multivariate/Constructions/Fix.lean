/-
Copyright (c) 2018 Jeremy Avigad. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jeremy Avigad, Simon Hudon
-/
import Qpf.PFunctor.Multivariate.W
import Qpf.Qpf.Multivariate.Basic

/-!
# The initial algebra of a multivariate qpf is again a qpf.

For a `(n+1)`-ary QPF `F (α₀,..,αₙ)`, we take the least fixed point of `F` with
regards to its last argument `αₙ`. The result is a `n`-ary functor: `fix F (α₀,..,αₙ₋₁)`.
Making `fix F` into a functor allows us to take the fixed point, compose with other functors
and take a fixed point again.

## Main definitions

 * `Fix.mk`     - constructor
 * `Fix.dest`    - destructor
 * `Fix.rec`    - recursor: basis for defining functions by structural recursion on `fix F α`
 * `Fix.drec`   - dependent recursor: generalization of `Fix.rec` where
                  the result type of the function is allowed to depend on the `fix F α` value
 * `Fix.rec_eq` - defining equation for `recursor`
 * `Fix.ind`    - induction principle for `fix F α`

## Implementation notes

For `F` a `QPF`, we define `fix F α` in terms of the W-type of the polynomial functor `P` of `F`.
We define the relation `Wequiv` and take its quotient as the definition of `fix F α`.

```lean
inductive Wequiv {α : typevec n} : q.P.W α → q.P.W α → Prop
| ind (a : q.P.A) (f' : q.P.drop.B a ⟹ α) (f₀ f₁ : q.P.last.B a → q.P.W α) :
    (∀ x, Wequiv (f₀ x) (f₁ x)) → Wequiv (q.P.W_mk a f' f₀) (q.P.W_mk a f' f₁)
| abs (a₀ : q.P.A) (f'₀ : q.P.drop.B a₀ ⟹ α) (f₀ : q.P.last.B a₀ → q.P.W α)
      (a₁ : q.P.A) (f'₁ : q.P.drop.B a₁ ⟹ α) (f₁ : q.P.last.B a₁ → q.P.W α) :
      abs ⟨a₀, q.P.append_contents f'₀ f₀⟩ = abs ⟨a₁, q.P.append_contents f'₁ f₁⟩ →
        Wequiv (q.P.W_mk a₀ f'₀ f₀) (q.P.W_mk a₁ f'₁ f₁)
| trans (u v w : q.P.W α) : Wequiv u v → Wequiv v w → Wequiv u w
```

See [avigad-carneiro-hudon2019] for more details.

## Reference

 * Jeremy Avigad, Mario M. Carneiro and Simon Hudon.
   [*Data Types as Quotients of Polynomial Functors*][avigad-carneiro-hudon2019]
-/


universe u v

namespace MvQpf

open TypeVec

open MvFunctor (Liftp Liftr)

-- open_locale MvFunctor

variable {n : ℕ}
variable {F : TypeFun.{u} (n + 1)} [MvFunctor F] [q : MvQpf F]

include q

/-- `recF` is used as a basis for defining the recursor on `fix F α`. `recF`
traverses recursively the W-type generated by `q.P` using a function on `F`
as a recursive step -/
def recF {α : TypeVec n} {β : Type _} (g : F (α.append1 β) → β) : q.P.W α → β :=
  q.P.W_rec fun a f' f rec => g (abs ⟨a, splitFun f' rec⟩)

theorem recF_eq {α : TypeVec n} {β : Type _} (g : F (α.append1 β) → β) (a : q.P.A) (f' : q.P.drop.B a ⟹ α)
    (f : q.P.last.B a → q.P.W α) : recF g (q.P.W_mk a f' f) = g (abs ⟨a, splitFun f' (recF g ∘ f)⟩) := by
  rw [recF, MvPFunctor.W_rec_eq] <;> rfl

theorem recF_eq' {α : TypeVec n} {β : Type _} (g : F (α.append1 β) → β) (x : q.P.W α) :
    recF g x = g (abs (appendFun id (recF g) <$$> q.P.W_dest' x)) := 
by
  apply q.P.W_cases (C:= fun x => recF g x = g (abs ((TypeVec.id ::: recF g) <$$> MvPFunctor.W_dest' (P F) x))) _ x
  intro a f' f
  rw [recF_eq, q.P.W_dest'_W_mk, MvPFunctor.map_eq, append_fun_comp_split_fun, TypeVec.id_comp]

/-- Equivalence relation on W-types that represent the same `fix F`
value -/
inductive Wequiv {α : TypeVec n} : q.P.W α → q.P.W α → Prop
  | ind (a : q.P.A) 
        (f' : q.P.drop.B a ⟹ α) 
        (f₀ f₁ : q.P.last.B a → q.P.W α) 
        : (∀ x, Wequiv (f₀ x) (f₁ x)) 
        → Wequiv (q.P.W_mk a f' f₀) (q.P.W_mk a f' f₁)
  | abs (a₀ : q.P.A) (f'₀ : q.P.drop.B a₀ ⟹ α) (f₀ : q.P.last.B a₀ → q.P.W α) (a₁ : q.P.A) (f'₁ : q.P.drop.B a₁ ⟹ α)
    (f₁ : q.P.last.B a₁ → q.P.W α) :
    abs ⟨a₀, q.P.append_contents f'₀ f₀⟩ = abs ⟨a₁, q.P.append_contents f'₁ f₁⟩ →
      Wequiv (q.P.W_mk a₀ f'₀ f₀) (q.P.W_mk a₁ f'₁ f₁)
  | trans (u v w : q.P.W α) : Wequiv u v → Wequiv v w → Wequiv u w


theorem recF_eq_of_Wequiv (α : TypeVec n) {β : Type _} (u : F (α.append1 β) → β) (x y : q.P.W α) :
    Wequiv x y → recF u x = recF u y := by
  apply q.P.W_cases (C:=fun x => Wequiv x y → recF u x = recF u y) _ x
  intro a₀ f'₀ f₀
  apply q.P.W_cases (C:=fun y => Wequiv (MvPFunctor.W_mk (P F) a₀ f'₀ f₀) y → recF u (MvPFunctor.W_mk (P F) a₀ f'₀ f₀) = recF u y) _ y
  intro a₁ f'₁ f₁
  intro h
  generalize hw₀ : MvPFunctor.W_mk (P F) a₀ f'₀ f₀ = w₀;
  generalize hw₁ : MvPFunctor.W_mk (P F) a₁ f'₁ f₁ = w₁;
  rw [hw₀, hw₁] at h
  clear a₀ f'₀ f₀ hw₀ a₁ f'₁ f₁ hw₁
  induction h
  case ind a f' f₀ f₁ h ih => {
    simp only [recF_eq, Function.comp]
    have : (fun (x : last (MvPFunctor.B (P F) a)) => recF u (f₀ x)) = (fun x => recF u (f₁ x));
    {
      funext x; exact ih x;
    }
    simp only [this]
    rfl
  }
  case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h => {
    simp only [recF_eq', abs_map, MvPFunctor.W_dest'_W_mk, h]
  }
  case trans x y z e₁ e₂ ih₁ ih₂ => {
    exact Eq.trans ih₁ ih₂
  }

theorem Wequiv.abs' {α : TypeVec n} 
                    (x y : q.P.W α) 
                    (h : MvQpf.abs (q.P.W_dest' x) = MvQpf.abs (q.P.W_dest' y)) : 
      Wequiv x y := by
  revert h
  apply q.P.W_cases (C:=fun x => MvQpf.abs (MvPFunctor.W_dest' (P F) x) = MvQpf.abs (MvPFunctor.W_dest' (P F) y) → Wequiv x y) _ x
  intro a₀ f'₀ f₀
  apply q.P.W_cases (C:=fun y => MvQpf.abs (MvPFunctor.W_dest' (P F) (MvPFunctor.W_mk (P F) a₀ f'₀ f₀)) = MvQpf.abs (MvPFunctor.W_dest' (P F) y) →
    Wequiv (MvPFunctor.W_mk (P F) a₀ f'₀ f₀) y) _ y
  intro a₁ f'₁ f₁
  apply Wequiv.abs

theorem Wequiv.refl {α : TypeVec n} (x : q.P.W α) : Wequiv x x := 
by
  apply q.P.W_cases (C:=fun x => Wequiv x x) _ x
  intro a f' f
  exact Wequiv.abs a f' f a f' f rfl

theorem Wequiv.symm {α : TypeVec n} (x y : q.P.W α) : Wequiv x y → Wequiv y x := by
  intro h
  induction h
  case ind a f' f₀ f₁ h ih =>
    exact Wequiv.ind _ _ _ _ ih
  case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h =>
    exact Wequiv.abs _ _ _ _ _ _ h.symm
  case trans x y z e₁ e₂ ih₁ ih₂ =>
    exact MvQpf.Wequiv.trans _ _ _ ih₂ ih₁

/-- maps every element of the W type to a canonical representative -/
def Wrepr {α : TypeVec n} : q.P.W α → q.P.W α :=
  recF (q.P.W_mk' ∘ repr)

theorem Wrepr_W_mk {α : TypeVec n} (a : q.P.A) (f' : q.P.drop.B a ⟹ α) (f : q.P.last.B a → q.P.W α) :
    Wrepr (q.P.W_mk a f' f) = q.P.W_mk' (repr (abs (appendFun id Wrepr <$$> ⟨a, q.P.append_contents f' f⟩))) := 
by
  rw [Wrepr, recF_eq', q.P.W_dest'_W_mk] <;> rfl

theorem Wrepr_equiv {α : TypeVec n} (x : q.P.W α) : Wequiv (Wrepr x) x := 
by
  apply q.P.W_ind (C:=fun x => Wequiv (Wrepr x) x) _ x;
  intro a f' f ih
  apply Wequiv.trans _ (q.P.W_mk' (appendFun id Wrepr <$$> ⟨a, q.P.append_contents f' f⟩))
  rcases x with ⟨ax, fx⟩
  . apply Wequiv.abs';
    rw [Wrepr_W_mk, q.P.W_dest'_W_mk', q.P.W_dest'_W_mk', abs_repr];
  . rw [q.P.map_eq, MvPFunctor.W_mk', append_fun_comp_split_fun, id_comp]
    apply Wequiv.ind
    exact ih


theorem Wequiv_map {α β : TypeVec n} (g : α ⟹ β) (x y : q.P.W α) : Wequiv x y → Wequiv (g <$$> x) (g <$$> y) := by
  intro h
  induction h
  case ind a f' f₀ f₁ h ih =>
    rw [q.P.W_map_W_mk, q.P.W_map_W_mk]
    apply Wequiv.ind
    intro x
    apply ih
  case abs a₀ f'₀ f₀ a₁ f'₁ f₁ h =>
    rw [q.P.W_map_W_mk, q.P.W_map_W_mk]
    apply Wequiv.abs
    show
      abs (q.P.obj_append1 a₀ (g ⊚ f'₀) fun x => q.P.W_map g (f₀ x)) =
        abs (q.P.obj_append1 a₁ (g ⊚ f'₁) fun x => q.P.W_map g (f₁ x))
    rw [← q.P.map_obj_append1, ← q.P.map_obj_append1, abs_map, abs_map, h]
  case trans x y z e₁ e₂ ih₁ ih₂ =>
    apply MvQpf.Wequiv.trans
    apply ih₁
    apply ih₂

/-- Define the fixed point as the quotient of trees under the equivalence relation.
-/
def wSetoid (α : TypeVec n) : Setoid (q.P.W α) :=
  ⟨Wequiv, @Wequiv.refl _ _ _ _ _, @Wequiv.symm _ _ _ _ _, @Wequiv.trans _ _ _ _ _⟩

attribute [local instance] wSetoid

/-- Least fixed point of functor F. The result is a functor with one fewer parameters
than the input. For `F a b c` a ternary functor, fix F is a binary functor such that

```lean
fix F a b = F a b (fix F a b)
```
-/
def Fix {n : ℕ} (F : TypeVec (n + 1) → Type _) [MvFunctor F] [q : MvQpf F] (α : TypeVec n) :=
  Quotient (wSetoid α : Setoid (q.P.W α))

attribute [nolint has_inhabited_instance] Fix

/-- `fix F` is a functor -/
def Fix.map {α β : TypeVec n} (g : α ⟹ β) : Fix F α → Fix F β :=
  Quotient.lift (fun x : q.P.W α => Quotient.mk' (q.P.W_map g x)) fun a b h => Quot.sound (Wequiv_map _ _ _ h)

instance Fix.instMvFunctor : MvFunctor (Fix F) where
  map := @Fix.map _ _ _ _

variable {α : TypeVec.{u} n}

/-- Recursor for `fix F` -/
def Fix.rec {β : Type u} (g : F (α ::: β) → β) : Fix F α → β :=
  Quot.lift (recF g) (recF_eq_of_Wequiv α g)

/-- Access W-type underlying `fix F`  -/
def fixToW : Fix F α → q.P.W α :=
  Quotient.lift Wrepr (recF_eq_of_Wequiv α fun x => q.P.W_mk' (repr x))

/-- Constructor for `fix F` -/
def Fix.mk (x : F (append1 α (Fix F α))) : Fix F α :=
  Quot.mk _ (q.P.W_mk' (appendFun id fixToW <$$> repr x))

/-- Destructor for `fix F` -/
def Fix.dest : Fix F α → F (append1 α (Fix F α)) :=
  Fix.rec (MvFunctor.map (appendFun id Fix.mk))

theorem Fix.rec_eq {β : Type u} (g : F (append1 α β) → β) (x : F (append1 α (Fix F α))) :
    Fix.rec g (Fix.mk x) = g (appendFun id (Fix.rec g) <$$> x) := by
  have : recF g ∘ fixToW = Fix.rec g := by
    apply funext
    apply Quotient.ind
    intro x
    apply recF_eq_of_Wequiv
    apply Wrepr_equiv
  conv in rec _ _ => 
    rw [Fix.rec, Fix.mk]
    simp

  cases' h : repr x with a f;
  rw [MvPFunctor.map_eq, recF_eq', ← MvPFunctor.map_eq, MvPFunctor.W_dest'_W_mk']
  rw [← MvPFunctor.comp_map, abs_map, ← h, abs_repr, ← append_fun_comp, id_comp, this]

theorem Fix.ind_aux (a : q.P.A) (f' : q.P.drop.B a ⟹ α) (f : q.P.last.B a → q.P.W α) :
    Fix.mk (abs ⟨a, q.P.append_contents f' fun x => Quotient.mk' (f x)⟩) = Quotient.mk' (q.P.W_mk a f' f) := by
  have : Fix.mk (abs ⟨a, q.P.append_contents f' fun x => Quotient.mk' (f x)⟩) = Quotient.mk' (Wrepr (q.P.W_mk a f' f)) := by
    apply Quot.sound
    apply Wequiv.abs'
    rw [MvPFunctor.W_dest'_W_mk', abs_map, abs_repr, ← abs_map, MvPFunctor.map_eq]
    conv => rhs rw [Wrepr_W_mk, q.P.W_dest'_W_mk', abs_repr, MvPFunctor.map_eq]
    rw [MvPFunctor.append_contents, MvPFunctor.append_contents]
    rw [appendFun, appendFun, ← split_fun_comp, ← split_fun_comp]
    rfl
  rw [this]
  apply Quot.sound
  apply Wrepr_equiv

theorem Fix.ind_rec {β : Type _} (g₁ g₂ : Fix F α → β)
    (h :
      ∀ x : F (append1 α (Fix F α)), appendFun id g₁ <$$> x = appendFun id g₂ <$$> x → g₁ (Fix.mk x) = g₂ (Fix.mk x)) :
    ∀ x, g₁ x = g₂ x := by
  apply Quot.ind
  intro x
  apply q.P.W_ind (C:=fun x => g₁ (Quotient.mk' x) = g₂ (Quotient.mk' x)) _ x
  intro a f' f ih
  show g₁ (Quotient.mk' (q.P.W_mk a f' f)) = g₂ (Quotient.mk' (q.P.W_mk a f' f))
  rw [← Fix.ind_aux a f' f]
  apply h
  rw [← abs_map, ← abs_map, MvPFunctor.map_eq, MvPFunctor.map_eq]
  rw [MvPFunctor.append_contents, appendFun, appendFun, ← split_fun_comp, ← split_fun_comp]
  have : (g₁ ∘ fun x => Quotient.mk' (f x)) = g₂ ∘ fun x => Quotient.mk' (f x) := by
    ext x
    exact ih x
  rw [this]

theorem Fix.rec_unique {β : Type _} (g : F (append1 α β) → β) (h : Fix F α → β)
    (hyp : ∀ x, h (Fix.mk x) = g (appendFun id h <$$> x)) : Fix.rec g = h := by
  ext x
  apply Fix.ind_rec
  intro x hyp'
  rw [hyp, ← hyp', Fix.rec_eq]

theorem Fix.mk_dest (x : Fix F α) : Fix.mk (Fix.dest x) = x := by
  change (Fix.mk ∘ Fix.dest) x = x
  apply Fix.ind_rec _ id
  intro x
  simp
  rw [Fix.dest, Fix.rec_eq, ← comp_map, ← append_fun_comp, id_comp]
  intro h
  rw [h]
  show Fix.mk (appendFun id id <$$> x) = Fix.mk x
  rw [append_fun_id_id, MvFunctor.id_map]

theorem Fix.dest_mk (x : F (append1 α (Fix F α))) : Fix.dest (Fix.mk x) = x := by
  unfold Fix.dest
  rw [Fix.rec_eq, ← Fix.dest, ← comp_map]
  conv => rhs rw [← MvFunctor.id_map x]
  rw [← append_fun_comp, id_comp]
  have : Fix.mk ∘ (@Fix.dest _ F _ _ α) = _root_.id := by
    ext x
    apply Fix.mk_dest
  rw [this, append_fun_id_id]


theorem Fix.ind {α : TypeVec n} (p : Fix F α → Prop)
    (h : ∀ x : F (α.append1 (Fix F α)), Liftp (pred_last α p) x → p (Fix.mk x)) : ∀ x, p x := by
  apply Quot.ind
  intro x
  apply q.P.W_ind (C:=p ∘ Quotient.mk') _ x
  intro a f' f ih
  change p (Quotient.mk' (q.P.W_mk a f' f))
  rw [← Fix.ind_aux a f' f]
  apply h
  rw [MvQpf.liftp_iff]
  refine' ⟨_, _, rfl, _⟩
  intro i j
  cases i
  · apply ih
    
  · trivial
    

instance mvqpfFix : MvQpf (Fix F) where
  P := q.P.Wp
  abs := @fun α => Quot.mk Wequiv
  repr := @fun α => fixToW
  abs_repr := by
    intro α
    apply Quot.ind
    intro a
    apply Quot.sound
    apply Wrepr_equiv
  abs_map := by
    intro α β g x
    conv => rhs simp [MvFunctor.map]


/-- Dependent recursor for `fix F` -/
def Fix.drec {β : Fix F α → Type u} 
             (g : ∀ x : F (α ::: Sigma β), β (Fix.mk <| (TypeVec.id.{u} ::: Sigma.fst.{u,u}) <$$> x))
    (x : Fix F α) : β x :=
  by 
  let y := @Fix.rec _ F _ _ α (Sigma β) (fun i => ⟨_, g i⟩) x
  have hy : y = @Fix.rec _ F _ _ α (Sigma β) (fun i => ⟨_, g i⟩) x
    := by trivial
  have : x = y.1 := 
  by
    apply Eq.symm
    simp [hy]
    apply Fix.ind_rec (fun x => ((Fix.rec (fun i => Sigma.mk (Fix.mk ((TypeVec.id ::: Sigma.fst.{u,u}) <$$> i)) (g i)) x).fst)) id _ x
    intro x' ih
    simp [Fix.rec_eq]
    simp [append_fun_id_id] at ih
    apply congrArg
    conv => rhs; rw [← ih]
    rw [MvFunctor.map_map, ← append_fun_comp, id_comp];
    conv in (Fix.rec _ _) => 
      skip -- I don't know why, but lean needs this `conv` to close the goal
   
  apply cast _ y.2
  rw [this];


end MvQpf

