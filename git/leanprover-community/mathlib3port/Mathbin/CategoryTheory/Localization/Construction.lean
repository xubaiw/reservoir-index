/-
Copyright (c) 2022 Jo√´l Riou. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jo√´l Riou
-/
import Mathbin.CategoryTheory.MorphismProperty
import Mathbin.CategoryTheory.Category.Quiv

/-!

# Construction of the localized category

This file constructs the localized category, obtained by formally inverting
a class of maps `W : morphism_property C` in a category `C`.

We first construct a quiver `loc_quiver W` whose objects are the same as those
of `C` and whose maps are the maps in `C` and placeholders for the formal
inverses of the maps in `W`.

The localized category `W.localization` is obtained by taking the quotient
of the path category of `loc_quiver W` by the congruence generated by four
types of relations.

The obvious functor `Q W : C ‚•§ W.localization` satisfies the universal property
of the localization. Indeed, if `G : C ‚•§ D` sends morphisms in `W` to isomorphisms
in `D` (i.e. we have `hG : W.is_inverted_by G`), then there exists a unique functor
`G' : W.localization ‚•§ D` such that `Q W ‚â´ G' = G`. This `G'` is `lift G hG`.
The expected property of `lift G hG` if expressed by the lemma `fac` and the
uniqueness is expressed by `uniq`.

TODO:
1) show that for any category `E`, the composition of functors gives
an equivalence of categories between `W.localization ‚•§ E` and the full
subcategory of `C ‚•§ E` consisting of functors inverting `W`. (This only
requires an extension property for natural transformations of functors.)

2) define a predicate `is_localization L W` for a functor `L : C ‚•§ D` and
a class of morphisms `W` in `C` expressing that it is a localization with respect
to `W`, i.e. that it inverts `W` and that the obvious functor `W.localization ‚•§ D`
induced by `L` is an equivalence of categories. (It is more straightforward
to define this predicate this way rather than by using a universal property which
may imply attempting at quantifying on all universes.)

3) implement a constructor for `is_localization L W` which would take
as an input a *strict* universal property (`lift`/`fac`/`uniq`) similar to
what is obtained here for `W.localization`. (Practically speaking, this is
the easiest way to show that a functor is a localization.)

4) when we have `is_localization L W`, then show that `D ‚•§ E` identifies
to the full subcategory of `C ‚•§ E` consisting of `W`-inverting functors.

5) provide an API for the lifting of functors `C ‚•§ E`, for which
`fac`/`uniq` assertions would be expressed as isomorphisms rather than
by equalities of functors.

## References

* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]

-/


noncomputable section

open CategoryTheory.Category

namespace CategoryTheory

variable {C D : Type _} [Category C] [Category D] (W : MorphismProperty C)

namespace Localization

namespace Construction

/-- If `W : morphism_property C`, `loc_quiver W` is a quiver with the same objects
as `C`, and whose morphisms are those in `C` and placeholders for formal
inverses of the morphisms in `W`. -/
@[nolint has_nonempty_instance]
structure LocQuiver (W : MorphismProperty C) where
  obj : C

instance : Quiver (LocQuiver W) where Hom := fun A B => Sum (A.obj ‚ü∂ B.obj) { f : B.obj ‚ü∂ A.obj // W f }

/-- The object in the path category of `loc_quiver W` attached to an object in
the category `C` -/
def ŒπPaths (X : C) : Paths (LocQuiver W) :=
  ‚ü®X‚ü©

/-- The morphism in the path category associated to a morphism in the original category. -/
@[simp]
def œà‚ÇÅ {X Y : C} (f : X ‚ü∂ Y) : ŒπPaths W X ‚ü∂ ŒπPaths W Y :=
  Paths.of.map (Sum.inl f)

/-- The morphism in the path category corresponding to a formal inverse. -/
@[simp]
def œà‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : ŒπPaths W Y ‚ü∂ ŒπPaths W X :=
  Paths.of.map (Sum.inr ‚ü®w, hw‚ü©)

/-- The relations by which we take the quotient in order to get the localized category. -/
inductive Relations : HomRel (Paths (LocQuiver W))
  | id (X : C) : relations (œà‚ÇÅ W (ùüô X)) (ùüô _)
  | comp {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : relations (œà‚ÇÅ W (f ‚â´ g)) (œà‚ÇÅ W f ‚â´ œà‚ÇÅ W g)
  | Winv‚ÇÅ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : relations (œà‚ÇÅ W w ‚â´ œà‚ÇÇ W w hw) (ùüô _)
  | Winv‚ÇÇ {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : relations (œà‚ÇÇ W w hw ‚â´ œà‚ÇÅ W w) (ùüô _)

end Construction

end Localization

namespace MorphismProperty

open Localization.Construction

/-- The localized category obtained by formally inverting the morphisms
in `W : morphism_property C` -/
@[nolint has_nonempty_instance]
def Localization :=
  CategoryTheory.Quotient (Localization.Construction.Relations W)deriving Category

/-- The obvious functor `C ‚•§ W.localization` -/
def q : C ‚•§ W.Localization where
  obj := fun X => (Quotient.functor _).obj (Paths.of.obj ‚ü®X‚ü©)
  map := fun X Y f => (Quotient.functor _).map (œà‚ÇÅ W f)
  map_id' := fun X => Quotient.sound _ (Relations.id X)
  map_comp' := fun X Z Y f g => Quotient.sound _ (Relations.comp f g)

end MorphismProperty

namespace Localization

namespace Construction

variable {W}

/-- The isomorphism in `W.localization` associated to a morphism `w` in W -/
def wiso {X Y : C} (w : X ‚ü∂ Y) (hw : W w) : Iso (W.q.obj X) (W.q.obj Y) where
  Hom := W.q.map w
  inv := (Quotient.functor _).map (Paths.of.map (Sum.inr ‚ü®w, hw‚ü©))
  hom_inv_id' := Quotient.sound _ (Relations.Winv‚ÇÅ w hw)
  inv_hom_id' := Quotient.sound _ (Relations.Winv‚ÇÇ w hw)

/-- The formal inverse in `W.localization` of a morphism `w` in `W`. -/
abbrev winv {X Y : C} (w : X ‚ü∂ Y) (hw : W w) :=
  (wiso w hw).inv

end Construction

end Localization

namespace Localization

namespace Construction

variable {W} (G : C ‚•§ D) (hG : W.IsInvertedBy G)

include G hG

/-- The lifting of a functor to the path category of `loc_quiver W` -/
@[simps]
def liftToPathCategory : Paths (LocQuiver W) ‚•§ D :=
  Quiv.lift
    { obj := fun X => G.obj X.obj,
      map := fun X Y => by
        rintro (f | ‚ü®g, hg‚ü©)
        ¬∑ exact G.map f
          
        ¬∑ haveI := hG g hg
          exact inv (G.map g)
           }

/-- The lifting of a functor `C ‚•§ D` inverting `W` as a functor `W.localization ‚•§ D` -/
@[simps]
def lift : W.Localization ‚•§ D :=
  Quotient.lift (Relations W) (liftToPathCategory G hG)
    (by
      rintro ‚ü®X‚ü© ‚ü®Y‚ü© f‚ÇÅ f‚ÇÇ r
      rcases r with ‚ü®‚ü©
      tidy)

@[simp]
theorem fac : W.q ‚ãô lift G hG = G :=
  Functor.ext (fun X => rfl)
    (by
      intro X Y f
      simp only [functor.comp_map, eq_to_hom_refl, comp_id, id_comp]
      dsimp' [lift, lift_to_path_category, morphism_property.Q]
      rw [compose_path_to_path])

omit G hG

theorem uniq (G‚ÇÅ G‚ÇÇ : W.Localization ‚•§ D) (h : W.q ‚ãô G‚ÇÅ = W.q ‚ãô G‚ÇÇ) : G‚ÇÅ = G‚ÇÇ := by
  suffices h' : quotient.functor _ ‚ãô G‚ÇÅ = quotient.functor _ ‚ãô G‚ÇÇ
  ¬∑ refine' Functor.ext _ _
    ¬∑ rintro ‚ü®‚ü®X‚ü©‚ü©
      apply functor.congr_obj h
      
    ¬∑ rintro ‚ü®‚ü®X‚ü©‚ü© ‚ü®‚ü®Y‚ü©‚ü© ‚ü®f‚ü©
      apply functor.congr_hom h'
      
    
  ¬∑ refine' paths.ext_functor _ _
    ¬∑ ext X
      cases X
      apply functor.congr_obj h
      
    ¬∑ rintro ‚ü®X‚ü© ‚ü®Y‚ü© (f | ‚ü®w, hw‚ü©)
      ¬∑ simpa only using functor.congr_hom h f
        
      ¬∑ have hw : W.Q.map w = (Wiso w hw).Hom := rfl
        have hw' := functor.congr_hom h w
        simp only [functor.comp_map, hw] at hw'
        refine' functor.congr_inv_of_congr_hom _ _ _ _ _ hw'
        all_goals
          apply functor.congr_obj h
        
      
    

variable (W)

/-- The canonical bijection between objects in a category and its
localization with respect to a morphism_property `W` -/
@[simps]
def objEquiv : C ‚âÉ W.Localization where
  toFun := W.q.obj
  invFun := fun X => X.as.obj
  left_inv := fun X => rfl
  right_inv := by
    rintro ‚ü®‚ü®X‚ü©‚ü©
    rfl

variable {W}

/-- A `morphism_property` in `W.localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, the inverses of the morphisms
in `W` and if it is stable under composition -/
theorem morphism_property_is_top (P : MorphismProperty W.Localization) (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.q.map f))
    (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (w : X ‚ü∂ Y) (hw : W w), P (winv w hw)) (hP‚ÇÉ : P.StableUnderComposition) : P = ‚ä§ := by
  ext X Y f
  constructor
  ¬∑ intro hf
    simp only [Pi.top_apply]
    
  ¬∑ intro hf
    clear hf
    let G : _ ‚•§ W.localization := quotient.functor _
    suffices
      ‚àÄ (X‚ÇÅ X‚ÇÇ : C) (p : localization.construction.Œπ_paths W X‚ÇÅ ‚ü∂ localization.construction.Œπ_paths W X‚ÇÇ), P (G.map p)
      by
      rcases X with ‚ü®‚ü®X‚ü©‚ü©
      rcases Y with ‚ü®‚ü®Y‚ü©‚ü©
      simpa only [functor.image_preimage] using this _ _ (G.preimage f)
    intro X‚ÇÅ X‚ÇÇ p
    induction' p with X‚ÇÇ X‚ÇÉ p g hp
    ¬∑ simpa only [Functor.map_id] using hP‚ÇÅ (ùüô X‚ÇÅ)
      
    ¬∑ cases X‚ÇÇ
      cases X‚ÇÉ
      let p' : Œπ_paths W X‚ÇÅ ‚ü∂ Œπ_paths W X‚ÇÇ := p
      rw
        [show p.cons g = p' ‚â´ Quiver.Hom.toPath g by
          rfl,
        G.map_comp]
      refine' hP‚ÇÉ _ _ hp _
      rcases g with (g | ‚ü®g, hg‚ü©)
      ¬∑ apply hP‚ÇÅ
        
      ¬∑ apply hP‚ÇÇ
        
      
    

/-- A `morphism_property` in `W.localization` is satisfied by all
morphisms in the localized category if it contains the image of the
morphisms in the original category, if is stable under composition
and if the property is stable by passing to inverses. -/
theorem morphism_property_is_top' (P : MorphismProperty W.Localization) (hP‚ÇÅ : ‚àÄ ‚¶ÉX Y : C‚¶Ñ (f : X ‚ü∂ Y), P (W.q.map f))
    (hP‚ÇÇ : ‚àÄ ‚¶ÉX Y : W.Localization‚¶Ñ (e : X ‚âÖ Y) (he : P e.Hom), P e.inv) (hP‚ÇÉ : P.StableUnderComposition) : P = ‚ä§ :=
  morphism_property_is_top P hP‚ÇÅ (fun X Y w hw => hP‚ÇÇ _ (hP‚ÇÅ w)) hP‚ÇÉ

namespace NatTransExtension

variable {F‚ÇÅ F‚ÇÇ : W.Localization ‚•§ D} (œÑ : W.q ‚ãô F‚ÇÅ ‚ü∂ W.q ‚ãô F‚ÇÇ)

include œÑ

/-- If `F‚ÇÅ` and `F‚ÇÇ` are functors `W.localization ‚•§ D` and if we have
`œÑ : W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ`, we shall define a natural transformation `F‚ÇÅ ‚ü∂ F‚ÇÇ`.
This is the `app` field of this natural transformation. -/
def app (X : W.Localization) : F‚ÇÅ.obj X ‚ü∂ F‚ÇÇ.obj X :=
  eqToHom (congr_arg F‚ÇÅ.obj ((objEquiv W).right_inv X).symm) ‚â´
    œÑ.app ((objEquiv W).invFun X) ‚â´ eqToHom (congr_arg F‚ÇÇ.obj ((objEquiv W).right_inv X))

@[simp]
theorem app_eq (X : C) : (app œÑ) (W.q.obj X) = œÑ.app X := by
  simpa only [app, eq_to_hom_refl, comp_id, id_comp]

end NatTransExtension

/-- If `F‚ÇÅ` and `F‚ÇÇ` are functors `W.localization ‚•§ D`, a natural transformation `F‚ÇÅ ‚ü∂ F‚ÇÇ`
can be obtained from a natural transformation `W.Q ‚ãô F‚ÇÅ ‚ü∂ W.Q ‚ãô F‚ÇÇ`. -/
@[simps]
def natTransExtension {F‚ÇÅ F‚ÇÇ : W.Localization ‚•§ D} (œÑ : W.q ‚ãô F‚ÇÅ ‚ü∂ W.q ‚ãô F‚ÇÇ) : F‚ÇÅ ‚ü∂ F‚ÇÇ where
  app := NatTransExtension.app œÑ
  naturality' := fun X Y f => by
    have h :=
      morphism_property_is_top' (morphism_property.naturality_property (nat_trans_extension.app œÑ)) _
        (morphism_property.naturality_property.is_stable_under_inverse _)
        (morphism_property.naturality_property.is_stable_under_composition _)
    swap
    ¬∑ intro X Y f
      simpa only [morphism_property.naturality_property, nat_trans_extension.app_eq] using œÑ.naturality f
      
    have hf : (‚ä§ : morphism_property _) f := by
      simp only [Pi.top_apply]
    simpa only [‚Üê h] using hf

@[simp]
theorem nat_trans_extension_hcomp {F G : W.Localization ‚•§ D} (œÑ : W.q ‚ãô F ‚ü∂ W.q ‚ãô G) :
    ùüô W.q ‚ó´ natTransExtension œÑ = œÑ := by
  ext X
  simp only [nat_trans.hcomp_app, nat_trans.id_app, G.map_id, comp_id, nat_trans_extension_app,
    nat_trans_extension.app_eq]

end Construction

end Localization

end CategoryTheory

