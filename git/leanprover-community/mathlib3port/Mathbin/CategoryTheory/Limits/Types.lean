/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Reid Barton
-/
import Mathbin.CategoryTheory.Limits.Shapes.Images
import Mathbin.CategoryTheory.Filtered
import Mathbin.Tactic.EquivRw

universe u

open CategoryTheory

open CategoryTheory.Limits

namespace CategoryTheory.Limits.Types

variable {J : Type u} [SmallCategory J]

/-- (internal implementation) the limit cone of a functor,
implemented as flat sections of a pi type
-/
def limitCone (F : J ‚•§ Type u) : Cone F where
  x := F.sections
  œÄ := { app := fun j u => u.val j }

attribute [local elabWithoutExpectedType] congr_fun‚Çì

/-- (internal implementation) the fact that the proposed limit cone is the limit -/
def limitConeIsLimit (F : J ‚•§ Type u) : IsLimit (limitCone F) where
  lift := fun s v => ‚ü®fun j => s.œÄ.app j v, fun j j' f => congr_fun‚Çì (Cone.w s f) _‚ü©
  uniq' := by
    intros
    ext x j
    exact congr_fun‚Çì (w j) x

/-- The category of types has all limits.

See <https://stacks.math.columbia.edu/tag/002U>.
-/
instance : HasLimits (Type u) where
  HasLimitsOfShape := fun J ùí• =>
    { HasLimit := fun F => has_limit.mk { Cone := limit_cone F, IsLimit := limit_cone_is_limit F } }

/-- The equivalence between a limiting cone of `F` in `Type u` and the "concrete" definition as the
sections of `F`.
-/
def isLimitEquivSections {F : J ‚•§ Type u} {c : Cone F} (t : IsLimit c) : c.x ‚âÉ F.sections :=
  (IsLimit.conePointUniqueUpToIso t (limitConeIsLimit F)).toEquiv

@[simp]
theorem is_limit_equiv_sections_apply {F : J ‚•§ Type u} {c : Cone F} (t : IsLimit c) (j : J) (x : c.x) :
    ((isLimitEquivSections t) x : ‚àÄ j, F.obj j) j = c.œÄ.app j x :=
  rfl

@[simp]
theorem is_limit_equiv_sections_symm_apply {F : J ‚•§ Type u} {c : Cone F} (t : IsLimit c) (x : F.sections) (j : J) :
    c.œÄ.app j ((isLimitEquivSections t).symm x) = (x : ‚àÄ j, F.obj j) j := by
  equiv_rw(is_limit_equiv_sections t).symm  at x
  simp

/-- The equivalence between the abstract limit of `F` in `Type u`
and the "concrete" definition as the sections of `F`.
-/
noncomputable def limitEquivSections (F : J ‚•§ Type u) : (limit F : Type u) ‚âÉ F.sections :=
  isLimitEquivSections (limit.isLimit _)

@[simp]
theorem limit_equiv_sections_apply (F : J ‚•§ Type u) (x : limit F) (j : J) :
    ((limitEquivSections F) x : ‚àÄ j, F.obj j) j = limit.œÄ F j x :=
  rfl

@[simp]
theorem limit_equiv_sections_symm_apply (F : J ‚•§ Type u) (x : F.sections) (j : J) :
    limit.œÄ F j ((limitEquivSections F).symm x) = (x : ‚àÄ j, F.obj j) j :=
  is_limit_equiv_sections_symm_apply _ _ _

/-- Construct a term of `limit F : Type u` from a family of terms `x : Œ† j, F.obj j`
which are "coherent": `‚àÄ (j j') (f : j ‚ü∂ j'), F.map f (x j) = x j'`.
-/
@[ext]
noncomputable def Limit.mk (F : J ‚•§ Type u) (x : ‚àÄ j, F.obj j) (h : ‚àÄ j j' f : j ‚ü∂ j', F.map f (x j) = x j') :
    (limit F : Type u) :=
  (limitEquivSections F).symm ‚ü®x, h‚ü©

@[simp]
theorem Limit.œÄ_mk (F : J ‚•§ Type u) (x : ‚àÄ j, F.obj j) (h : ‚àÄ j j' f : j ‚ü∂ j', F.map f (x j) = x j') j :
    limit.œÄ F j (Limit.mk F x h) = x j := by
  dsimp' [limit.mk]
  simp

-- PROJECT: prove this for concrete categories where the forgetful functor preserves limits
@[ext]
theorem limit_ext (F : J ‚•§ Type u) (x y : limit F) (w : ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y) : x = y := by
  apply (limit_equiv_sections F).Injective
  ext j
  simp [w j]

theorem limit_ext_iff (F : J ‚•§ Type u) (x y : limit F) : x = y ‚Üî ‚àÄ j, limit.œÄ F j x = limit.œÄ F j y :=
  ‚ü®fun t _ => t ‚ñ∏ rfl, limit_ext _ _ _‚ü©

-- TODO: are there other limits lemmas that should have `_apply` versions?
-- Can we generate these like with `@[reassoc]`?
-- PROJECT: prove these for any concrete category where the forgetful functor preserves limits?
@[simp]
theorem Limit.w_apply {F : J ‚•§ Type u} {j j' : J} {x : limit F} (f : j ‚ü∂ j') :
    F.map f (limit.œÄ F j x) = limit.œÄ F j' x :=
  congr_fun‚Çì (limit.w F f) x

@[simp]
theorem Limit.lift_œÄ_apply (F : J ‚•§ Type u) (s : Cone F) (j : J) (x : s.x) :
    limit.œÄ F j (limit.lift F s x) = s.œÄ.app j x :=
  congr_fun‚Çì (limit.lift_œÄ s j) x

@[simp]
theorem Limit.map_œÄ_apply {F G : J ‚•§ Type u} (Œ± : F ‚ü∂ G) (j : J) x :
    limit.œÄ G j (limMap Œ± x) = Œ±.app j (limit.œÄ F j x) :=
  congr_fun‚Çì (lim_map_œÄ Œ± j) x

/-- The relation defining the quotient type which implements the colimit of a functor `F : J ‚•§ Type u`.
See `category_theory.limits.types.quot`.
-/
def Quot.Rel (F : J ‚•§ Type u) : (Œ£j, F.obj j) ‚Üí (Œ£j, F.obj j) ‚Üí Prop := fun p p' => ‚àÉ f : p.1 ‚ü∂ p'.1, p'.2 = F.map f p.2

/-- A quotient type implementing the colimit of a functor `F : J ‚•§ Type u`,
as pairs `‚ü®j, x‚ü©` where `x : F.obj j`, modulo the equivalence relation generated by
`‚ü®j, x‚ü© ~ ‚ü®j', x'‚ü©` whenever there is a morphism `f : j ‚ü∂ j'` so `F.map f x = x'`.
-/
@[nolint has_inhabited_instance]
def Quot (F : J ‚•§ Type u) : Type u :=
  @Quot (Œ£j, F.obj j) (Quot.Rel F)

/-- (internal implementation) the colimit cocone of a functor,
implemented as a quotient of a sigma type
-/
def colimitCocone (F : J ‚•§ Type u) : Cocone F where
  x := Quot F
  Œπ :=
    { app := fun j x => Quot.mk _ ‚ü®j, x‚ü©, naturality' := fun j j' f => funext fun x => Eq.symm (Quot.sound ‚ü®f, rfl‚ü©) }

attribute [local elab_with_expected_type] Quot.lift

/-- (internal implementation) the fact that the proposed colimit cocone is the colimit -/
def colimitCoconeIsColimit (F : J ‚•§ Type u) : IsColimit (colimitCocone F) where
  desc := fun s =>
    Quot.lift (fun p : Œ£j, F.obj j => s.Œπ.app p.1 p.2) fun ‚ü®j, x‚ü© ‚ü®j', x'‚ü© ‚ü®f, hf‚ü© => by
      rw [hf] <;> exact (congr_fun‚Çì (cocone.w s f) x).symm

/-- The category of types has all colimits.

See <https://stacks.math.columbia.edu/tag/002U>.
-/
instance : HasColimits (Type u) where
  HasColimitsOfShape := fun J ùí• =>
    { HasColimit := fun F => has_colimit.mk { Cocone := colimit_cocone F, IsColimit := colimit_cocone_is_colimit F } }

/-- The equivalence between the abstract colimit of `F` in `Type u`
and the "concrete" definition as a quotient.
-/
noncomputable def colimitEquivQuot (F : J ‚•§ Type u) : (colimit F : Type u) ‚âÉ Quot F :=
  (IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) (colimitCoconeIsColimit F)).toEquiv

@[simp]
theorem colimit_equiv_quot_symm_apply (F : J ‚•§ Type u) (j : J) (x : F.obj j) :
    (colimitEquivQuot F).symm (Quot.mk _ ‚ü®j, x‚ü©) = colimit.Œπ F j x :=
  rfl

@[simp]
theorem colimit_equiv_quot_apply (F : J ‚•§ Type u) (j : J) (x : F.obj j) :
    (colimitEquivQuot F) (colimit.Œπ F j x) = Quot.mk _ ‚ü®j, x‚ü© := by
  apply (colimit_equiv_quot F).symm.Injective
  simp

@[simp]
theorem Colimit.w_apply {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} (f : j ‚ü∂ j') :
    colimit.Œπ F j' (F.map f x) = colimit.Œπ F j x :=
  congr_fun‚Çì (colimit.w F f) x

@[simp]
theorem Colimit.Œπ_desc_apply (F : J ‚•§ Type u) (s : Cocone F) (j : J) (x : F.obj j) :
    colimit.desc F s (colimit.Œπ F j x) = s.Œπ.app j x :=
  congr_fun‚Çì (colimit.Œπ_desc s j) x

@[simp]
theorem Colimit.Œπ_map_apply {F G : J ‚•§ Type u} (Œ± : F ‚ü∂ G) (j : J) x :
    colim.map Œ± (colimit.Œπ F j x) = colimit.Œπ G j (Œ±.app j x) :=
  congr_fun‚Çì (colimit.Œπ_map Œ± j) x

theorem colimit_sound {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} (f : j ‚ü∂ j') (w : F.map f x = x') :
    colimit.Œπ F j x = colimit.Œπ F j' x' := by
  rw [‚Üê w]
  simp

theorem colimit_sound' {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} {j'' : J} (f : j ‚ü∂ j'') (f' : j' ‚ü∂ j'')
    (w : F.map f x = F.map f' x') : colimit.Œπ F j x = colimit.Œπ F j' x' := by
  rw [‚Üê colimit.w _ f, ‚Üê colimit.w _ f']
  rw [types_comp_apply, types_comp_apply, w]

theorem colimit_eq {F : J ‚•§ Type u} {j j' : J} {x : F.obj j} {x' : F.obj j'} (w : colimit.Œπ F j x = colimit.Œπ F j' x') :
    EqvGen (Quot.Rel F) ‚ü®j, x‚ü© ‚ü®j', x'‚ü© := by
  apply Quot.eq.1
  simpa using congr_arg‚Çì (colimit_equiv_quot F) w

theorem jointly_surjective (F : J ‚•§ Type u) {t : Cocone F} (h : IsColimit t) (x : t.x) : ‚àÉ j y, t.Œπ.app j y = x := by
  suffices (fun x : t.X => ULift.up (‚àÉ j y, t.Œπ.app j y = x)) = fun _ => ULift.up True by
    have := congr_fun‚Çì this x
    have H := congr_arg‚Çì ULift.down this
    dsimp'  at H
    rwa [eq_true‚Çì] at H
  refine' h.hom_ext _
  intro j
  ext y
  erw [iff_true‚Çì]
  exact ‚ü®j, y, rfl‚ü©

/-- A variant of `jointly_surjective` for `x : colimit F`. -/
theorem jointly_surjective' {F : J ‚•§ Type u} (x : colimit F) : ‚àÉ j y, colimit.Œπ F j y = x :=
  jointly_surjective F (colimit.isColimit _) x

namespace FilteredColimit

/- For filtered colimits of types, we can give an explicit description
  of the equivalence relation generated by the relation used to form
  the colimit.  -/
variable (F : J ‚•§ Type u)

/-- An alternative relation on `Œ£ j, F.obj j`,
which generates the same equivalence relation as we use to define the colimit in `Type` above,
but that is more convenient when working with filtered colimits.

Elements in `F.obj j` and `F.obj j'` are equivalent if there is some `k : J` to the right
where their images are equal.
-/
protected def Rel (x y : Œ£j, F.obj j) : Prop :=
  ‚àÉ (k : _)(f : x.1 ‚ü∂ k)(g : y.1 ‚ü∂ k), F.map f x.2 = F.map g y.2

theorem rel_of_quot_rel (x y : Œ£j, F.obj j) : Quot.Rel F x y ‚Üí FilteredColimit.Rel F x y := fun ‚ü®f, h‚ü© =>
  ‚ü®y.1, f, ùüô y.1, by
    rw [‚Üê h, functor_to_types.map_id_apply]‚ü©

theorem eqv_gen_quot_rel_of_rel (x y : Œ£j, F.obj j) : FilteredColimit.Rel F x y ‚Üí EqvGen (Quot.Rel F) x y :=
  fun ‚ü®k, f, g, h‚ü© =>
  EqvGen.trans _ ‚ü®k, F.map f x.2‚ü© _ (EqvGen.rel _ _ ‚ü®f, rfl‚ü©) (EqvGen.symm _ _ (EqvGen.rel _ _ ‚ü®g, h‚ü©))

attribute [local elabWithoutExpectedType] nat_trans.app

/-- Recognizing filtered colimits of types. -/
noncomputable def isColimitOf (t : Cocone F) (hsurj : ‚àÄ x : t.x, ‚àÉ i xi, x = t.Œπ.app i xi)
    (hinj : ‚àÄ i j xi xj, t.Œπ.app i xi = t.Œπ.app j xj ‚Üí ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj) :
    IsColimit t := by
  -- Strategy: Prove that the map from "the" colimit of F (defined above) to t.X
  -- is a bijection.
  apply is_colimit.of_iso_colimit (colimit.is_colimit F)
  refine' cocones.ext (Equiv‚Çì.toIso (Equiv‚Çì.ofBijective _ _)) _
  ¬∑ exact colimit.desc F t
    
  ¬∑ constructor
    ¬∑ show Function.Injective _
      intro a b h
      rcases jointly_surjective F (colimit.is_colimit F) a with ‚ü®i, xi, rfl‚ü©
      rcases jointly_surjective F (colimit.is_colimit F) b with ‚ü®j, xj, rfl‚ü©
      change (colimit.Œπ F i ‚â´ colimit.desc F t) xi = (colimit.Œπ F j ‚â´ colimit.desc F t) xj at h
      rw [colimit.Œπ_desc, colimit.Œπ_desc] at h
      rcases hinj i j xi xj h with ‚ü®k, f, g, h'‚ü©
      change colimit.Œπ F i xi = colimit.Œπ F j xj
      rw [‚Üê colimit.w F f, ‚Üê colimit.w F g]
      change colimit.Œπ F k (F.map f xi) = colimit.Œπ F k (F.map g xj)
      rw [h']
      
    ¬∑ show Function.Surjective _
      intro x
      rcases hsurj x with ‚ü®i, xi, rfl‚ü©
      use colimit.Œπ F i xi
      simp
      
    
  ¬∑ intro j
    apply colimit.Œπ_desc
    

variable [IsFilteredOrEmpty J]

protected theorem rel_equiv : Equivalence‚Çì (FilteredColimit.Rel F) :=
  ‚ü®fun x => ‚ü®x.1, ùüô x.1, ùüô x.1, rfl‚ü©, fun x y ‚ü®k, f, g, h‚ü© => ‚ü®k, g, f, h.symm‚ü©,
    fun x y z ‚ü®k, f, g, h‚ü© ‚ü®k', f', g', h'‚ü© =>
    let ‚ü®l, fl, gl, _‚ü© := IsFilteredOrEmpty.cocone_objs k k'
    let ‚ü®m, n, hn‚ü© := IsFilteredOrEmpty.cocone_maps (g ‚â´ fl) (f' ‚â´ gl)
    ‚ü®m, f ‚â´ fl ‚â´ n, g' ‚â´ gl ‚â´ n,
      calc
        F.map (f ‚â´ fl ‚â´ n) x.2 = F.map (fl ‚â´ n) (F.map f x.2) := by
          simp
        _ = F.map (fl ‚â´ n) (F.map g y.2) := by
          rw [h]
        _ = F.map ((g ‚â´ fl) ‚â´ n) y.2 := by
          simp
        _ = F.map ((f' ‚â´ gl) ‚â´ n) y.2 := by
          rw [hn]
        _ = F.map (gl ‚â´ n) (F.map f' y.2) := by
          simp
        _ = F.map (gl ‚â´ n) (F.map g' z.2) := by
          rw [h']
        _ = F.map (g' ‚â´ gl ‚â´ n) z.2 := by
          simp
        ‚ü©‚ü©

protected theorem rel_eq_eqv_gen_quot_rel : FilteredColimit.Rel F = EqvGen (Quot.Rel F) := by
  ext ‚ü®j, x‚ü© ‚ü®j', y‚ü©
  constructor
  ¬∑ apply eqv_gen_quot_rel_of_rel
    
  ¬∑ rw [‚Üê (filtered_colimit.rel_equiv F).eqv_gen_iff]
    exact EqvGen.mono (rel_of_quot_rel F)
    

theorem colimit_eq_iff_aux {i j : J} {xi : F.obj i} {xj : F.obj j} :
    (colimitCocone F).Œπ.app i xi = (colimitCocone F).Œπ.app j xj ‚Üî FilteredColimit.Rel F ‚ü®i, xi‚ü© ‚ü®j, xj‚ü© := by
  change Quot.mk _ _ = Quot.mk _ _ ‚Üî _
  rw [Quot.eq, filtered_colimit.rel_eq_eqv_gen_quot_rel]

theorem is_colimit_eq_iff {t : Cocone F} (ht : IsColimit t) {i j : J} {xi : F.obj i} {xj : F.obj j} :
    t.Œπ.app i xi = t.Œπ.app j xj ‚Üî ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj := by
  let t' := colimitCocone F
  let e : t' ‚âÖ t := IsColimit.uniqueUpToIso (colimitCoconeIsColimit F) ht
  let e' : t'.x ‚âÖ t.x := (Cocones.forget _).mapIso e
  refine' Iff.trans _ (colimit_eq_iff_aux F)
  convert e'.to_equiv.apply_eq_iff_eq <;> rw [‚Üê e.hom.w] <;> rfl

theorem colimit_eq_iff {i j : J} {xi : F.obj i} {xj : F.obj j} :
    colimit.Œπ F i xi = colimit.Œπ F j xj ‚Üî ‚àÉ (k : _)(f : i ‚ü∂ k)(g : j ‚ü∂ k), F.map f xi = F.map g xj :=
  is_colimit_eq_iff _ (colimit.isColimit F)

end FilteredColimit

variable {Œ± Œ≤ : Type u} (f : Œ± ‚ü∂ Œ≤)

section

/-- the image of a morphism in Type is just `set.range f` -/
-- implementation of `has_image`
def Image : Type u :=
  Set.Range f

instance [Inhabited Œ±] : Inhabited (Image f) where
  default := ‚ü®f default, ‚ü®_, rfl‚ü©‚ü©

/-- the inclusion of `image f` into the target -/
def Image.Œπ : Image f ‚ü∂ Œ≤ :=
  Subtype.val

instance : Mono (Image.Œπ f) :=
  (mono_iff_injective _).2 Subtype.val_injective

variable {f}

/-- the universal property for the image factorisation -/
noncomputable def Image.lift (F' : MonoFactorisation f) : Image f ‚ü∂ F'.i :=
  (fun x => F'.e (Classical.indefiniteDescription _ x.2).1 : Image f ‚Üí F'.i)

theorem Image.lift_fac (F' : MonoFactorisation f) : Image.lift F' ‚â´ F'.m = Image.Œπ f := by
  ext x
  change (F'.e ‚â´ F'.m) _ = _
  rw [F'.fac, (Classical.indefiniteDescription _ x.2).2]
  rfl

end

/-- the factorisation of any morphism in Type through a mono. -/
def monoFactorisation : MonoFactorisation f where
  i := Image f
  m := Image.Œπ f
  e := Set.rangeFactorization f

/-- the facorisation through a mono has the universal property of the image. -/
noncomputable def isImage : IsImage (monoFactorisation f) where
  lift := Image.lift
  lift_fac' := Image.lift_fac

instance : HasImage f :=
  HasImage.mk ‚ü®_, isImage f‚ü©

instance : HasImages (Type u) where
  HasImage := by
    infer_instance

instance : HasImageMaps (Type u) where
  HasImageMap := fun f g st =>
    HasImageMap.transport st (monoFactorisation f.Hom) (isImage g.Hom)
      (fun x =>
        ‚ü®st.right x.1,
          ‚ü®st.left (Classical.some x.2), by
            have p := st.w
            replace p := congr_fun‚Çì p (Classical.some x.2)
            simp only [functor.id_map, types_comp_apply, Subtype.val_eq_coe] at p
            erw [p, Classical.some_spec x.2]‚ü©‚ü©)
      rfl

end CategoryTheory.Limits.Types

