/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison, Markus Himmel, Bhavik Mehta, Andrew Yang
-/
import Mathbin.CategoryTheory.Limits.Shapes.WidePullbacks
import Mathbin.CategoryTheory.Limits.Shapes.BinaryProducts

/-!
# Pullbacks

We define a category `walking_cospan` (resp. `walking_span`), which is the index category
for the given data for a pullback (resp. pushout) diagram. Convenience methods `cospan f g`
and `span f g` construct functors from the walking (co)span, hitting the given morphisms.

We define `pullback f g` and `pushout f g` as limits and colimits of such functors.

## References
* [Stacks: Fibre products](https://stacks.math.columbia.edu/tag/001U)
* [Stacks: Pushouts](https://stacks.math.columbia.edu/tag/0025)
-/


noncomputable section

open CategoryTheory

namespace CategoryTheory.Limits

universe v‚ÇÅ v‚ÇÇ v u u‚ÇÇ

attribute [local tidy] tactic.case_bash

/-- The type of objects for the diagram indexing a pullback, defined as a special case of
`wide_pullback_shape`.
-/
abbrev WalkingCospan : Type v :=
  WidePullbackShape WalkingPair

/-- The left point of the walking cospan. -/
@[matchPattern]
abbrev WalkingCospan.left : WalkingCospan :=
  some WalkingPair.left

/-- The right point of the walking cospan. -/
@[matchPattern]
abbrev WalkingCospan.right : WalkingCospan :=
  some WalkingPair.right

/-- The central point of the walking cospan. -/
@[matchPattern]
abbrev WalkingCospan.one : WalkingCospan :=
  none

/-- The type of objects for the diagram indexing a pushout, defined as a special case of
`wide_pushout_shape`.
-/
abbrev WalkingSpan : Type v :=
  WidePushoutShape WalkingPair

/-- The left point of the walking span. -/
@[matchPattern]
abbrev WalkingSpan.left : WalkingSpan :=
  some WalkingPair.left

/-- The right point of the walking span. -/
@[matchPattern]
abbrev WalkingSpan.right : WalkingSpan :=
  some WalkingPair.right

/-- The central point of the walking span. -/
@[matchPattern]
abbrev WalkingSpan.zero : WalkingSpan :=
  none

namespace WalkingCospan

/-- The type of arrows for the diagram indexing a pullback. -/
abbrev Hom : WalkingCospan ‚Üí WalkingCospan ‚Üí Type v :=
  wide_pullback_shape.hom

/-- The left arrow of the walking cospan. -/
@[matchPattern]
abbrev Hom.inl : left ‚ü∂ one :=
  WidePullbackShape.Hom.term _

/-- The right arrow of the walking cospan. -/
@[matchPattern]
abbrev Hom.inr : right ‚ü∂ one :=
  WidePullbackShape.Hom.term _

/-- The identity arrows of the walking cospan. -/
@[matchPattern]
abbrev Hom.id (X : WalkingCospan) : X ‚ü∂ X :=
  WidePullbackShape.Hom.id X

instance (X Y : WalkingCospan) : Subsingleton (X ‚ü∂ Y) := by
  tidy

end WalkingCospan

namespace WalkingSpan

/-- The type of arrows for the diagram indexing a pushout. -/
abbrev Hom : WalkingSpan ‚Üí WalkingSpan ‚Üí Type v :=
  wide_pushout_shape.hom

/-- The left arrow of the walking span. -/
@[matchPattern]
abbrev Hom.fst : zero ‚ü∂ left :=
  WidePushoutShape.Hom.init _

/-- The right arrow of the walking span. -/
@[matchPattern]
abbrev Hom.snd : zero ‚ü∂ right :=
  WidePushoutShape.Hom.init _

/-- The identity arrows of the walking span. -/
@[matchPattern]
abbrev Hom.id (X : WalkingSpan) : X ‚ü∂ X :=
  WidePushoutShape.Hom.id X

instance (X Y : WalkingSpan) : Subsingleton (X ‚ü∂ Y) := by
  tidy

end WalkingSpan

section

open WalkingCospan

/-- The functor between two `walking_cospan`s in different universes. -/
def walkingCospanFunctor : walking_cospan.{v‚ÇÅ} ‚•§ walking_cospan.{v‚ÇÇ} where
  obj := by
    rintro (_ | _ | _)
    exacts[one, left, right]
  map := by
    rintro _ _ (_ | _ | _)
    exacts[hom.id _, hom.inl, hom.inr]
  map_id' := fun X => rfl
  map_comp' := fun _ _ _ _ _ => Subsingleton.elim‚Çì _ _

@[simp]
theorem walking_cospan_functor_one : walkingCospanFunctor.obj one = one :=
  rfl

@[simp]
theorem walking_cospan_functor_left : walkingCospanFunctor.obj left = left :=
  rfl

@[simp]
theorem walking_cospan_functor_right : walkingCospanFunctor.obj right = right :=
  rfl

@[simp]
theorem walking_cospan_functor_id X : walkingCospanFunctor.map (ùüô X) = ùüô _ :=
  rfl

@[simp]
theorem walking_cospan_functor_inl : walkingCospanFunctor.map Hom.inl = hom.inl :=
  rfl

@[simp]
theorem walking_cospan_functor_inr : walkingCospanFunctor.map Hom.inr = hom.inr :=
  rfl

/-- The equivalence between two `walking_cospan`s in different universes. -/
def walkingCospanEquiv : walking_cospan.{v‚ÇÅ} ‚âå walking_cospan.{v‚ÇÇ} where
  Functor := walkingCospanFunctor
  inverse := walkingCospanFunctor
  unitIso :=
    NatIso.ofComponents
      (fun x =>
        eqToIso
          (by
            rcases x with (_ | _ | _) <;> rfl))
      (by
        rintro _ _ (_ | _ | _) <;> simp )
  counitIso :=
    NatIso.ofComponents
      (fun x =>
        eqToIso
          (by
            rcases x with (_ | _ | _) <;> rfl))
      (by
        rintro _ _ (_ | _ | _) <;> simp )

end

section

open WalkingSpan

/-- The functor between two `walking_span`s in different universes. -/
def walkingSpanFunctor : walking_span.{v‚ÇÅ} ‚•§ walking_span.{v‚ÇÇ} where
  obj := by
    rintro (_ | _ | _)
    exacts[zero, left, right]
  map := by
    rintro _ _ (_ | _ | _)
    exacts[hom.id _, hom.fst, hom.snd]
  map_id' := fun X => rfl
  map_comp' := fun _ _ _ _ _ => Subsingleton.elim‚Çì _ _

@[simp]
theorem walking_span_functor_zero : walkingSpanFunctor.obj zero = zero :=
  rfl

@[simp]
theorem walking_span_functor_left : walkingSpanFunctor.obj left = left :=
  rfl

@[simp]
theorem walking_span_functor_right : walkingSpanFunctor.obj right = right :=
  rfl

@[simp]
theorem walking_span_functor_id X : walkingSpanFunctor.map (ùüô X) = ùüô _ :=
  rfl

@[simp]
theorem walking_span_functor_fst : walkingSpanFunctor.map Hom.fst = hom.fst :=
  rfl

@[simp]
theorem walking_span_functor_snd : walkingSpanFunctor.map Hom.snd = hom.snd :=
  rfl

/-- The equivalence between two `walking_span`s in different universes. -/
def walkingSpanEquiv : walking_span.{v‚ÇÅ} ‚âå walking_span.{v‚ÇÇ} where
  Functor := walkingSpanFunctor
  inverse := walkingSpanFunctor
  unitIso :=
    NatIso.ofComponents
      (fun x =>
        eqToIso
          (by
            rcases x with (_ | _ | _) <;> rfl))
      (by
        rintro _ _ (_ | _ | _) <;> simp )
  counitIso :=
    NatIso.ofComponents
      (fun x =>
        eqToIso
          (by
            rcases x with (_ | _ | _) <;> rfl))
      (by
        rintro _ _ (_ | _ | _) <;> simp )

end

open WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom

variable {C : Type u} [Category.{v} C]

/-- `cospan f g` is the functor from the walking cospan hitting `f` and `g`. -/
def cospan {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : walking_cospan ‚•§ C :=
  WidePullbackShape.wideCospan Z (fun j => WalkingPair.casesOn j X Y) fun j => WalkingPair.casesOn j f g

/-- `span f g` is the functor from the walking span hitting `f` and `g`. -/
def span {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : walking_span ‚•§ C :=
  WidePushoutShape.wideSpan X (fun j => WalkingPair.casesOn j Y Z) fun j => WalkingPair.casesOn j f g

@[simp]
theorem cospan_left {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (cospan f g).obj WalkingCospan.left = X :=
  rfl

@[simp]
theorem span_left {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : (span f g).obj WalkingSpan.left = Y :=
  rfl

@[simp]
theorem cospan_right {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (cospan f g).obj WalkingCospan.right = Y :=
  rfl

@[simp]
theorem span_right {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : (span f g).obj WalkingSpan.right = Z :=
  rfl

@[simp]
theorem cospan_one {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (cospan f g).obj WalkingCospan.one = Z :=
  rfl

@[simp]
theorem span_zero {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : (span f g).obj WalkingSpan.zero = X :=
  rfl

@[simp]
theorem cospan_map_inl {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (cospan f g).map WalkingCospan.Hom.inl = f :=
  rfl

@[simp]
theorem span_map_fst {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : (span f g).map WalkingSpan.Hom.fst = f :=
  rfl

@[simp]
theorem cospan_map_inr {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : (cospan f g).map WalkingCospan.Hom.inr = g :=
  rfl

@[simp]
theorem span_map_snd {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : (span f g).map WalkingSpan.Hom.snd = g :=
  rfl

theorem cospan_map_id {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (w : WalkingCospan) :
    (cospan f g).map (WalkingCospan.Hom.id w) = ùüô _ :=
  rfl

theorem span_map_id {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (w : WalkingSpan) :
    (span f g).map (WalkingSpan.Hom.id w) = ùüô _ :=
  rfl

/-- Every diagram indexing an pullback is naturally isomorphic (actually, equal) to a `cospan` -/
@[simps (config := { rhsMd := semireducible })]
def diagramIsoCospan (F : walking_cospan ‚•§ C) : F ‚âÖ cospan (F.map inl) (F.map inr) :=
  NatIso.ofComponents
    (fun j =>
      eqToIso
        (by
          tidy))
    (by
      tidy)

/-- Every diagram indexing a pushout is naturally isomorphic (actually, equal) to a `span` -/
@[simps (config := { rhsMd := semireducible })]
def diagramIsoSpan (F : walking_span ‚•§ C) : F ‚âÖ span (F.map fst) (F.map snd) :=
  NatIso.ofComponents
    (fun j =>
      eqToIso
        (by
          tidy))
    (by
      tidy)

variable {D : Type _} [Category.{v} D]

/-- A functor applied to a cospan is a cospan. -/
def cospanCompIso (F : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) : cospan f g ‚ãô F ‚âÖ cospan (F.map f) (F.map g) :=
  NatIso.ofComponents
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) <;> exact iso.refl _)
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) ‚ü®‚ü© <;>
        repeat'
          dsimp
          simp )

section

variable (F : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)

@[simp]
theorem cospan_comp_iso_app_left : (cospanCompIso F f g).app WalkingCospan.left = Iso.refl _ :=
  rfl

@[simp]
theorem cospan_comp_iso_app_right : (cospanCompIso F f g).app WalkingCospan.right = Iso.refl _ :=
  rfl

@[simp]
theorem cospan_comp_iso_app_one : (cospanCompIso F f g).app WalkingCospan.one = Iso.refl _ :=
  rfl

@[simp]
theorem cospan_comp_iso_hom_app_left : (cospanCompIso F f g).Hom.app WalkingCospan.left = ùüô _ :=
  rfl

@[simp]
theorem cospan_comp_iso_hom_app_right : (cospanCompIso F f g).Hom.app WalkingCospan.right = ùüô _ :=
  rfl

@[simp]
theorem cospan_comp_iso_hom_app_one : (cospanCompIso F f g).Hom.app WalkingCospan.one = ùüô _ :=
  rfl

@[simp]
theorem cospan_comp_iso_inv_app_left : (cospanCompIso F f g).inv.app WalkingCospan.left = ùüô _ :=
  rfl

@[simp]
theorem cospan_comp_iso_inv_app_right : (cospanCompIso F f g).inv.app WalkingCospan.right = ùüô _ :=
  rfl

@[simp]
theorem cospan_comp_iso_inv_app_one : (cospanCompIso F f g).inv.app WalkingCospan.one = ùüô _ :=
  rfl

end

/-- A functor applied to a span is a span. -/
def spanCompIso (F : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) : span f g ‚ãô F ‚âÖ span (F.map f) (F.map g) :=
  NatIso.ofComponents
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) <;> exact iso.refl _)
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) ‚ü®‚ü© <;>
        repeat'
          dsimp
          simp )

section

variable (F : C ‚•§ D) {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)

@[simp]
theorem span_comp_iso_app_left : (spanCompIso F f g).app WalkingSpan.left = Iso.refl _ :=
  rfl

@[simp]
theorem span_comp_iso_app_right : (spanCompIso F f g).app WalkingSpan.right = Iso.refl _ :=
  rfl

@[simp]
theorem span_comp_iso_app_zero : (spanCompIso F f g).app WalkingSpan.zero = Iso.refl _ :=
  rfl

@[simp]
theorem span_comp_iso_hom_app_left : (spanCompIso F f g).Hom.app WalkingSpan.left = ùüô _ :=
  rfl

@[simp]
theorem span_comp_iso_hom_app_right : (spanCompIso F f g).Hom.app WalkingSpan.right = ùüô _ :=
  rfl

@[simp]
theorem span_comp_iso_hom_app_zero : (spanCompIso F f g).Hom.app WalkingSpan.zero = ùüô _ :=
  rfl

@[simp]
theorem span_comp_iso_inv_app_left : (spanCompIso F f g).inv.app WalkingSpan.left = ùüô _ :=
  rfl

@[simp]
theorem span_comp_iso_inv_app_right : (spanCompIso F f g).inv.app WalkingSpan.right = ùüô _ :=
  rfl

@[simp]
theorem span_comp_iso_inv_app_zero : (spanCompIso F f g).inv.app WalkingSpan.zero = ùüô _ :=
  rfl

end

section

variable {X Y Z X' Y' Z' : C} (iX : X ‚âÖ X') (iY : Y ‚âÖ Y') (iZ : Z ‚âÖ Z')

section

variable {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} {f' : X' ‚ü∂ Z'} {g' : Y' ‚ü∂ Z'}

/-- Construct an isomorphism of cospans from components. -/
def cospanExt (wf : iX.Hom ‚â´ f' = f ‚â´ iZ.Hom) (wg : iY.Hom ‚â´ g' = g ‚â´ iZ.Hom) : cospan f g ‚âÖ cospan f' g' :=
  NatIso.ofComponents
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©)
      exacts[iZ, iX, iY])
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) ‚ü®‚ü© <;>
        repeat'
          dsimp
          simp [wf, wg])

variable (wf : iX.Hom ‚â´ f' = f ‚â´ iZ.Hom) (wg : iY.Hom ‚â´ g' = g ‚â´ iZ.Hom)

@[simp]
theorem cospan_ext_app_left : (cospanExt iX iY iZ wf wg).app WalkingCospan.left = iX := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_app_right : (cospanExt iX iY iZ wf wg).app WalkingCospan.right = iY := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_app_one : (cospanExt iX iY iZ wf wg).app WalkingCospan.one = iZ := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_hom_app_left : (cospanExt iX iY iZ wf wg).Hom.app WalkingCospan.left = iX.Hom := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_hom_app_right : (cospanExt iX iY iZ wf wg).Hom.app WalkingCospan.right = iY.Hom := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_hom_app_one : (cospanExt iX iY iZ wf wg).Hom.app WalkingCospan.one = iZ.Hom := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_inv_app_left : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.left = iX.inv := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_inv_app_right : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.right = iY.inv := by
  dsimp [cospan_ext]
  simp

@[simp]
theorem cospan_ext_inv_app_one : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.one = iZ.inv := by
  dsimp [cospan_ext]
  simp

end

section

variable {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} {f' : X' ‚ü∂ Y'} {g' : X' ‚ü∂ Z'}

/-- Construct an isomorphism of spans from components. -/
def spanExt (wf : iX.Hom ‚â´ f' = f ‚â´ iY.Hom) (wg : iX.Hom ‚â´ g' = g ‚â´ iZ.Hom) : span f g ‚âÖ span f' g' :=
  NatIso.ofComponents
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©)
      exacts[iX, iY, iZ])
    (by
      rintro (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) (‚ü®‚ü© | ‚ü®‚ü®‚ü©‚ü©) ‚ü®‚ü© <;>
        repeat'
          dsimp
          simp [wf, wg])

variable (wf : iX.Hom ‚â´ f' = f ‚â´ iY.Hom) (wg : iX.Hom ‚â´ g' = g ‚â´ iZ.Hom)

@[simp]
theorem span_ext_app_left : (spanExt iX iY iZ wf wg).app WalkingSpan.left = iY := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_app_right : (spanExt iX iY iZ wf wg).app WalkingSpan.right = iZ := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_app_one : (spanExt iX iY iZ wf wg).app WalkingSpan.zero = iX := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_hom_app_left : (spanExt iX iY iZ wf wg).Hom.app WalkingSpan.left = iY.Hom := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_hom_app_right : (spanExt iX iY iZ wf wg).Hom.app WalkingSpan.right = iZ.Hom := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_hom_app_zero : (spanExt iX iY iZ wf wg).Hom.app WalkingSpan.zero = iX.Hom := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_inv_app_left : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.left = iY.inv := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_inv_app_right : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.right = iZ.inv := by
  dsimp [span_ext]
  simp

@[simp]
theorem span_ext_inv_app_zero : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.zero = iX.inv := by
  dsimp [span_ext]
  simp

end

end

variable {W X Y Z : C}

/-- A pullback cone is just a cone on the cospan formed by two morphisms `f : X ‚ü∂ Z` and
    `g : Y ‚ü∂ Z`.-/
abbrev PullbackCone (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :=
  Cone (cospan f g)

namespace PullbackCone

variable {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}

/-- The first projection of a pullback cone. -/
abbrev fst (t : PullbackCone f g) : t.x ‚ü∂ X :=
  t.œÄ.app WalkingCospan.left

/-- The second projection of a pullback cone. -/
abbrev snd (t : PullbackCone f g) : t.x ‚ü∂ Y :=
  t.œÄ.app WalkingCospan.right

/-- This is a slightly more convenient method to verify that a pullback cone is a limit cone. It
    only asks for a proof of facts that carry any mathematical content -/
def isLimitAux (t : PullbackCone f g) (lift : ‚àÄ s : PullbackCone f g, s.x ‚ü∂ t.x)
    (fac_left : ‚àÄ s : PullbackCone f g, lift s ‚â´ t.fst = s.fst)
    (fac_right : ‚àÄ s : PullbackCone f g, lift s ‚â´ t.snd = s.snd)
    (uniq : ‚àÄ s : PullbackCone f g m : s.x ‚ü∂ t.x w : ‚àÄ j : WalkingCospan, m ‚â´ t.œÄ.app j = s.œÄ.app j, m = lift s) :
    IsLimit t :=
  { lift,
    fac' := fun s j =>
      Option.casesOn j
        (by
          rw [‚Üê s.w inl, ‚Üê t.w inl, ‚Üê category.assoc]
          congr
          exact fac_left s)
        fun j' => WalkingPair.casesOn j' (fac_left s) (fac_right s),
    uniq' := uniq }

/-- This is another convenient method to verify that a pullback cone is a limit cone. It
    only asks for a proof of facts that carry any mathematical content, and allows access to the
    same `s` for all parts. -/
def isLimitAux' (t : PullbackCone f g)
    (create :
      ‚àÄ s : PullbackCone f g,
        { l // l ‚â´ t.fst = s.fst ‚àß l ‚â´ t.snd = s.snd ‚àß ‚àÄ {m}, m ‚â´ t.fst = s.fst ‚Üí m ‚â´ t.snd = s.snd ‚Üí m = l }) :
    Limits.IsLimit t :=
  PullbackCone.isLimitAux t (fun s => (create s).1) (fun s => (create s).2.1) (fun s => (create s).2.2.1) fun s m w =>
    (create s).2.2.2 (w WalkingCospan.left) (w WalkingCospan.right)

/-- A pullback cone on `f` and `g` is determined by morphisms `fst : W ‚ü∂ X` and `snd : W ‚ü∂ Y`
    such that `fst ‚â´ f = snd ‚â´ g`. -/
@[simps]
def mk {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) : PullbackCone f g where
  x := W
  œÄ := { app := fun j => Option.casesOn j (fst ‚â´ f) fun j' => WalkingPair.casesOn j' fst snd }

@[simp]
theorem mk_œÄ_app_left {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
    (mk fst snd Eq).œÄ.app WalkingCospan.left = fst :=
  rfl

@[simp]
theorem mk_œÄ_app_right {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
    (mk fst snd Eq).œÄ.app WalkingCospan.right = snd :=
  rfl

@[simp]
theorem mk_œÄ_app_one {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) :
    (mk fst snd Eq).œÄ.app WalkingCospan.one = fst ‚â´ f :=
  rfl

@[simp]
theorem mk_fst {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) : (mk fst snd Eq).fst = fst :=
  rfl

@[simp]
theorem mk_snd {W : C} (fst : W ‚ü∂ X) (snd : W ‚ü∂ Y) (eq : fst ‚â´ f = snd ‚â´ g) : (mk fst snd Eq).snd = snd :=
  rfl

@[reassoc]
theorem condition (t : PullbackCone f g) : fst t ‚â´ f = snd t ‚â´ g :=
  (t.w inl).trans (t.w inr).symm

/-- To check whether a morphism is equalized by the maps of a pullback cone, it suffices to check
  it for `fst t` and `snd t` -/
theorem equalizer_ext (t : PullbackCone f g) {W : C} {k l : W ‚ü∂ t.x} (h‚ÇÄ : k ‚â´ fst t = l ‚â´ fst t)
    (h‚ÇÅ : k ‚â´ snd t = l ‚â´ snd t) : ‚àÄ j : WalkingCospan, k ‚â´ t.œÄ.app j = l ‚â´ t.œÄ.app j
  | some walking_pair.left => h‚ÇÄ
  | some walking_pair.right => h‚ÇÅ
  | none => by
    rw [‚Üê t.w inl, reassoc_of h‚ÇÄ]

theorem IsLimit.hom_ext {t : PullbackCone f g} (ht : IsLimit t) {W : C} {k l : W ‚ü∂ t.x} (h‚ÇÄ : k ‚â´ fst t = l ‚â´ fst t)
    (h‚ÇÅ : k ‚â´ snd t = l ‚â´ snd t) : k = l :=
  ht.hom_ext <| equalizer_ext _ h‚ÇÄ h‚ÇÅ

theorem mono_snd_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono f] : Mono t.snd :=
  ‚ü®fun W h k i =>
    IsLimit.hom_ext ht
      (by
        simp [‚Üê cancel_mono f, t.condition, reassoc_of i])
      i‚ü©

theorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] : Mono t.fst :=
  ‚ü®fun W h k i =>
    IsLimit.hom_ext ht i
      (by
        simp [‚Üê cancel_mono g, ‚Üê t.condition, reassoc_of i])‚ü©

/-- If `t` is a limit pullback cone over `f` and `g` and `h : W ‚ü∂ X` and `k : W ‚ü∂ Y` are such that
    `h ‚â´ f = k ‚â´ g`, then we have `l : W ‚ü∂ t.X` satisfying `l ‚â´ fst t = h` and `l ‚â´ snd t = k`.
    -/
def IsLimit.lift' {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W ‚ü∂ X) (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) :
    { l : W ‚ü∂ t.x // l ‚â´ fst t = h ‚àß l ‚â´ snd t = k } :=
  ‚ü®ht.lift <| PullbackCone.mk _ _ w, ht.fac _ _, ht.fac _ _‚ü©

/-- This is a more convenient formulation to show that a `pullback_cone` constructed using
`pullback_cone.mk` is a limit cone.
-/
def IsLimit.mk {W : C} {fst : W ‚ü∂ X} {snd : W ‚ü∂ Y} (eq : fst ‚â´ f = snd ‚â´ g) (lift : ‚àÄ s : PullbackCone f g, s.x ‚ü∂ W)
    (fac_left : ‚àÄ s : PullbackCone f g, lift s ‚â´ fst = s.fst) (fac_right : ‚àÄ s : PullbackCone f g, lift s ‚â´ snd = s.snd)
    (uniq : ‚àÄ s : PullbackCone f g m : s.x ‚ü∂ W w_fst : m ‚â´ fst = s.fst w_snd : m ‚â´ snd = s.snd, m = lift s) :
    IsLimit (mk fst snd Eq) :=
  isLimitAux _ lift fac_left fac_right fun s m w => uniq s m (w WalkingCospan.left) (w WalkingCospan.right)

/-- The flip of a pullback square is a pullback square. -/
def flipIsLimit {W : C} {h : W ‚ü∂ X} {k : W ‚ü∂ Y} {comm : h ‚â´ f = k ‚â´ g} (t : IsLimit (mk _ _ comm.symm)) :
    IsLimit (mk _ _ comm) :=
  (isLimitAux' _) fun s => by
    refine'
      ‚ü®(is_limit.lift' t _ _ s.condition.symm).1, (is_limit.lift' t _ _ _).2.2, (is_limit.lift' t _ _ _).2.1,
        fun m m‚ÇÅ m‚ÇÇ => t.hom_ext _‚ü©
    apply (mk k h _).equalizer_ext
    ¬∑ rwa [(is_limit.lift' t _ _ _).2.1]
      
    ¬∑ rwa [(is_limit.lift' t _ _ _).2.2]
      

/-- The pullback cone `(ùüô X, ùüô X)` for the pair `(f, f)` is a limit if `f` is a mono. The converse is
shown in `mono_of_pullback_is_id`.
-/
def isLimitMkIdId (f : X ‚ü∂ Y) [Mono f] : IsLimit (mk (ùüô X) (ùüô X) rfl : PullbackCone f f) :=
  IsLimit.mk _ (fun s => s.fst) (fun s => Category.comp_id _)
    (fun s => by
      rw [‚Üê cancel_mono f, category.comp_id, s.condition])
    fun s m m‚ÇÅ m‚ÇÇ => by
    simpa using m‚ÇÅ

/-- `f` is a mono if the pullback cone `(ùüô X, ùüô X)` is a limit for the pair `(f, f)`. The converse is
given in `pullback_cone.is_id_of_mono`.
-/
theorem mono_of_is_limit_mk_id_id (f : X ‚ü∂ Y) (t : IsLimit (mk (ùüô X) (ùüô X) rfl : PullbackCone f f)) : Mono f :=
  ‚ü®fun Z g h eq => by
    rcases pullback_cone.is_limit.lift' t _ _ Eq with ‚ü®_, rfl, rfl‚ü©
    rfl‚ü©

/-- Suppose `f` and `g` are two morphisms with a common codomain and `s` is a limit cone over the
    diagram formed by `f` and `g`. Suppose `f` and `g` both factor through a monomorphism `h` via
    `x` and `y`, respectively.  Then `s` is also a limit cone over the diagram formed by `x` and
    `y`.  -/
def isLimitOfFactors (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (h : W ‚ü∂ Z) [Mono h] (x : X ‚ü∂ W) (y : Y ‚ü∂ W) (hxh : x ‚â´ h = f)
    (hyh : y ‚â´ h = g) (s : PullbackCone f g) (hs : IsLimit s) :
    IsLimit
      (PullbackCone.mk _ _
        (show s.fst ‚â´ x = s.snd ‚â´ y from
          (cancel_mono h).1 <| by
            simp only [category.assoc, hxh, hyh, s.condition])) :=
  (PullbackCone.isLimitAux' _) fun t =>
    ‚ü®hs.lift
        (PullbackCone.mk t.fst t.snd <| by
          rw [‚Üê hxh, ‚Üê hyh, reassoc_of t.condition]),
      ‚ü®hs.fac _ WalkingCospan.left, hs.fac _ WalkingCospan.right, fun r hr hr' => by
        apply pullback_cone.is_limit.hom_ext hs <;>
          simp only [pullback_cone.mk_fst, pullback_cone.mk_snd] at hr hr'‚ä¢ <;> simp only [hr, hr'] <;> symm
        exacts[hs.fac _ walking_cospan.left, hs.fac _ walking_cospan.right]‚ü©‚ü©

/-- If `W` is the pullback of `f, g`,
it is also the pullback of `f ‚â´ i, g ‚â´ i` for any mono `i`. -/
def isLimitOfCompMono (f : X ‚ü∂ W) (g : Y ‚ü∂ W) (i : W ‚ü∂ Z) [Mono i] (s : PullbackCone f g) (H : IsLimit s) :
    IsLimit
      (PullbackCone.mk _ _
        (show s.fst ‚â´ f ‚â´ i = s.snd ‚â´ g ‚â´ i by
          rw [‚Üê category.assoc, ‚Üê category.assoc, s.condition])) :=
  by
  apply pullback_cone.is_limit_aux'
  intro s
  rcases pullback_cone.is_limit.lift' H s.fst s.snd
      ((cancel_mono i).mp
        (by
          simpa using s.condition)) with
    ‚ü®l, h‚ÇÅ, h‚ÇÇ‚ü©
  refine' ‚ü®l, h‚ÇÅ, h‚ÇÇ, _‚ü©
  intro m hm‚ÇÅ hm‚ÇÇ
  exact (pullback_cone.is_limit.hom_ext H (hm‚ÇÅ.trans h‚ÇÅ.symm) (hm‚ÇÇ.trans h‚ÇÇ.symm) : _)

end PullbackCone

/-- A pushout cocone is just a cocone on the span formed by two morphisms `f : X ‚ü∂ Y` and
    `g : X ‚ü∂ Z`.-/
abbrev PushoutCocone (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) :=
  Cocone (span f g)

namespace PushoutCocone

variable {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}

/-- The first inclusion of a pushout cocone. -/
abbrev inl (t : PushoutCocone f g) : Y ‚ü∂ t.x :=
  t.Œπ.app WalkingSpan.left

/-- The second inclusion of a pushout cocone. -/
abbrev inr (t : PushoutCocone f g) : Z ‚ü∂ t.x :=
  t.Œπ.app WalkingSpan.right

/-- This is a slightly more convenient method to verify that a pushout cocone is a colimit cocone.
    It only asks for a proof of facts that carry any mathematical content -/
def isColimitAux (t : PushoutCocone f g) (desc : ‚àÄ s : PushoutCocone f g, t.x ‚ü∂ s.x)
    (fac_left : ‚àÄ s : PushoutCocone f g, t.inl ‚â´ desc s = s.inl)
    (fac_right : ‚àÄ s : PushoutCocone f g, t.inr ‚â´ desc s = s.inr)
    (uniq : ‚àÄ s : PushoutCocone f g m : t.x ‚ü∂ s.x w : ‚àÄ j : WalkingSpan, t.Œπ.app j ‚â´ m = s.Œπ.app j, m = desc s) :
    IsColimit t :=
  { desc,
    fac' := fun s j =>
      Option.casesOn j
        (by
          simp [‚Üê s.w fst, ‚Üê t.w fst, fac_left s])
        fun j' => WalkingPair.casesOn j' (fac_left s) (fac_right s),
    uniq' := uniq }

/-- This is another convenient method to verify that a pushout cocone is a colimit cocone. It
    only asks for a proof of facts that carry any mathematical content, and allows access to the
    same `s` for all parts. -/
def isColimitAux' (t : PushoutCocone f g)
    (create :
      ‚àÄ s : PushoutCocone f g,
        { l // t.inl ‚â´ l = s.inl ‚àß t.inr ‚â´ l = s.inr ‚àß ‚àÄ {m}, t.inl ‚â´ m = s.inl ‚Üí t.inr ‚â´ m = s.inr ‚Üí m = l }) :
    IsColimit t :=
  isColimitAux t (fun s => (create s).1) (fun s => (create s).2.1) (fun s => (create s).2.2.1) fun s m w =>
    (create s).2.2.2 (w WalkingCospan.left) (w WalkingCospan.right)

/-- A pushout cocone on `f` and `g` is determined by morphisms `inl : Y ‚ü∂ W` and `inr : Z ‚ü∂ W` such
    that `f ‚â´ inl = g ‚Ü† inr`. -/
@[simps]
def mk {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) : PushoutCocone f g where
  x := W
  Œπ := { app := fun j => Option.casesOn j (f ‚â´ inl) fun j' => WalkingPair.casesOn j' inl inr }

@[simp]
theorem mk_Œπ_app_left {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
    (mk inl inr Eq).Œπ.app WalkingSpan.left = inl :=
  rfl

@[simp]
theorem mk_Œπ_app_right {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
    (mk inl inr Eq).Œπ.app WalkingSpan.right = inr :=
  rfl

@[simp]
theorem mk_Œπ_app_zero {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) :
    (mk inl inr Eq).Œπ.app WalkingSpan.zero = f ‚â´ inl :=
  rfl

@[simp]
theorem mk_inl {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) : (mk inl inr Eq).inl = inl :=
  rfl

@[simp]
theorem mk_inr {W : C} (inl : Y ‚ü∂ W) (inr : Z ‚ü∂ W) (eq : f ‚â´ inl = g ‚â´ inr) : (mk inl inr Eq).inr = inr :=
  rfl

@[reassoc]
theorem condition (t : PushoutCocone f g) : f ‚â´ inl t = g ‚â´ inr t :=
  (t.w fst).trans (t.w snd).symm

/-- To check whether a morphism is coequalized by the maps of a pushout cocone, it suffices to check
  it for `inl t` and `inr t` -/
theorem coequalizer_ext (t : PushoutCocone f g) {W : C} {k l : t.x ‚ü∂ W} (h‚ÇÄ : inl t ‚â´ k = inl t ‚â´ l)
    (h‚ÇÅ : inr t ‚â´ k = inr t ‚â´ l) : ‚àÄ j : WalkingSpan, t.Œπ.app j ‚â´ k = t.Œπ.app j ‚â´ l
  | some walking_pair.left => h‚ÇÄ
  | some walking_pair.right => h‚ÇÅ
  | none => by
    rw [‚Üê t.w fst, category.assoc, category.assoc, h‚ÇÄ]

theorem IsColimit.hom_ext {t : PushoutCocone f g} (ht : IsColimit t) {W : C} {k l : t.x ‚ü∂ W}
    (h‚ÇÄ : inl t ‚â´ k = inl t ‚â´ l) (h‚ÇÅ : inr t ‚â´ k = inr t ‚â´ l) : k = l :=
  ht.hom_ext <| coequalizer_ext _ h‚ÇÄ h‚ÇÅ

/-- If `t` is a colimit pushout cocone over `f` and `g` and `h : Y ‚ü∂ W` and `k : Z ‚ü∂ W` are
    morphisms satisfying `f ‚â´ h = g ‚â´ k`, then we have a factorization `l : t.X ‚ü∂ W` such that
    `inl t ‚â´ l = h` and `inr t ‚â´ l = k`. -/
def IsColimit.desc' {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y ‚ü∂ W) (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) :
    { l : t.x ‚ü∂ W // inl t ‚â´ l = h ‚àß inr t ‚â´ l = k } :=
  ‚ü®ht.desc <| PushoutCocone.mk _ _ w, ht.fac _ _, ht.fac _ _‚ü©

theorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] : Epi t.inr :=
  ‚ü®fun W h k i =>
    IsColimit.hom_ext ht
      (by
        simp [‚Üê cancel_epi f, t.condition_assoc, i])
      i‚ü©

theorem epi_inl_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi g] : Epi t.inl :=
  ‚ü®fun W h k i =>
    IsColimit.hom_ext ht i
      (by
        simp [‚Üê cancel_epi g, ‚Üê t.condition_assoc, i])‚ü©

/-- This is a more convenient formulation to show that a `pushout_cocone` constructed using
`pushout_cocone.mk` is a colimit cocone.
-/
def IsColimit.mk {W : C} {inl : Y ‚ü∂ W} {inr : Z ‚ü∂ W} (eq : f ‚â´ inl = g ‚â´ inr) (desc : ‚àÄ s : PushoutCocone f g, W ‚ü∂ s.x)
    (fac_left : ‚àÄ s : PushoutCocone f g, inl ‚â´ desc s = s.inl)
    (fac_right : ‚àÄ s : PushoutCocone f g, inr ‚â´ desc s = s.inr)
    (uniq : ‚àÄ s : PushoutCocone f g m : W ‚ü∂ s.x w_inl : inl ‚â´ m = s.inl w_inr : inr ‚â´ m = s.inr, m = desc s) :
    IsColimit (mk inl inr Eq) :=
  isColimitAux _ desc fac_left fac_right fun s m w => uniq s m (w WalkingCospan.left) (w WalkingCospan.right)

/-- The flip of a pushout square is a pushout square. -/
def flipIsColimit {W : C} {h : Y ‚ü∂ W} {k : Z ‚ü∂ W} {comm : f ‚â´ h = g ‚â´ k} (t : IsColimit (mk _ _ comm.symm)) :
    IsColimit (mk _ _ comm) :=
  (isColimitAux' _) fun s => by
    refine'
      ‚ü®(is_colimit.desc' t _ _ s.condition.symm).1, (is_colimit.desc' t _ _ _).2.2, (is_colimit.desc' t _ _ _).2.1,
        fun m m‚ÇÅ m‚ÇÇ => t.hom_ext _‚ü©
    apply (mk k h _).coequalizer_ext
    ¬∑ rwa [(is_colimit.desc' t _ _ _).2.1]
      
    ¬∑ rwa [(is_colimit.desc' t _ _ _).2.2]
      

/-- The pushout cocone `(ùüô X, ùüô X)` for the pair `(f, f)` is a colimit if `f` is an epi. The converse is
shown in `epi_of_is_colimit_mk_id_id`.
-/
def isColimitMkIdId (f : X ‚ü∂ Y) [Epi f] : IsColimit (mk (ùüô Y) (ùüô Y) rfl : PushoutCocone f f) :=
  IsColimit.mk _ (fun s => s.inl) (fun s => Category.id_comp _)
    (fun s => by
      rw [‚Üê cancel_epi f, category.id_comp, s.condition])
    fun s m m‚ÇÅ m‚ÇÇ => by
    simpa using m‚ÇÅ

/-- `f` is an epi if the pushout cocone `(ùüô X, ùüô X)` is a colimit for the pair `(f, f)`.
The converse is given in `pushout_cocone.is_colimit_mk_id_id`.
-/
theorem epi_of_is_colimit_mk_id_id (f : X ‚ü∂ Y) (t : IsColimit (mk (ùüô Y) (ùüô Y) rfl : PushoutCocone f f)) : Epi f :=
  ‚ü®fun Z g h eq => by
    rcases pushout_cocone.is_colimit.desc' t _ _ Eq with ‚ü®_, rfl, rfl‚ü©
    rfl‚ü©

/-- Suppose `f` and `g` are two morphisms with a common domain and `s` is a colimit cocone over the
    diagram formed by `f` and `g`. Suppose `f` and `g` both factor through an epimorphism `h` via
    `x` and `y`, respectively. Then `s` is also a colimit cocone over the diagram formed by `x` and
    `y`.  -/
def isColimitOfFactors (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : X ‚ü∂ W) [Epi h] (x : W ‚ü∂ Y) (y : W ‚ü∂ Z) (hhx : h ‚â´ x = f)
    (hhy : h ‚â´ y = g) (s : PushoutCocone f g) (hs : IsColimit s) :
    IsColimit
      (PushoutCocone.mk _ _
        (show x ‚â´ s.inl = y ‚â´ s.inr from
          (cancel_epi h).1 <| by
            rw [reassoc_of hhx, reassoc_of hhy, s.condition])) :=
  (PushoutCocone.isColimitAux' _) fun t =>
    ‚ü®hs.desc
        (PushoutCocone.mk t.inl t.inr <| by
          rw [‚Üê hhx, ‚Üê hhy, category.assoc, category.assoc, t.condition]),
      ‚ü®hs.fac _ WalkingSpan.left, hs.fac _ WalkingSpan.right, fun r hr hr' => by
        apply pushout_cocone.is_colimit.hom_ext hs <;>
          simp only [pushout_cocone.mk_inl, pushout_cocone.mk_inr] at hr hr'‚ä¢ <;> simp only [hr, hr'] <;> symm
        exacts[hs.fac _ walking_span.left, hs.fac _ walking_span.right]‚ü©‚ü©

/-- If `W` is the pushout of `f, g`,
it is also the pushout of `h ‚â´ f, h ‚â´ g` for any epi `h`. -/
def isColimitOfEpiComp (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : W ‚ü∂ X) [Epi h] (s : PushoutCocone f g) (H : IsColimit s) :
    IsColimit
      (PushoutCocone.mk _ _
        (show (h ‚â´ f) ‚â´ s.inl = (h ‚â´ g) ‚â´ s.inr by
          rw [category.assoc, category.assoc, s.condition])) :=
  by
  apply pushout_cocone.is_colimit_aux'
  intro s
  rcases pushout_cocone.is_colimit.desc' H s.inl s.inr
      ((cancel_epi h).mp
        (by
          simpa using s.condition)) with
    ‚ü®l, h‚ÇÅ, h‚ÇÇ‚ü©
  refine' ‚ü®l, h‚ÇÅ, h‚ÇÇ, _‚ü©
  intro m hm‚ÇÅ hm‚ÇÇ
  exact (pushout_cocone.is_colimit.hom_ext H (hm‚ÇÅ.trans h‚ÇÅ.symm) (hm‚ÇÇ.trans h‚ÇÇ.symm) : _)

end PushoutCocone

/-- This is a helper construction that can be useful when verifying that a category has all
    pullbacks. Given `F : walking_cospan ‚•§ C`, which is really the same as
    `cospan (F.map inl) (F.map inr)`, and a pullback cone on `F.map inl` and `F.map inr`, we
    get a cone on `F`.

    If you're thinking about using this, have a look at `has_pullbacks_of_has_limit_cospan`,
    which you may find to be an easier way of achieving your goal. -/
@[simps]
def Cone.ofPullbackCone {F : walking_cospan ‚•§ C} (t : PullbackCone (F.map inl) (F.map inr)) : Cone F where
  x := t.x
  œÄ := t.œÄ ‚â´ (diagramIsoCospan F).inv

/-- This is a helper construction that can be useful when verifying that a category has all
    pushout. Given `F : walking_span ‚•§ C`, which is really the same as
    `span (F.map fst) (F.mal snd)`, and a pushout cocone on `F.map fst` and `F.map snd`,
    we get a cocone on `F`.

    If you're thinking about using this, have a look at `has_pushouts_of_has_colimit_span`, which
    you may find to be an easiery way of achieving your goal.  -/
@[simps]
def Cocone.ofPushoutCocone {F : walking_span ‚•§ C} (t : PushoutCocone (F.map fst) (F.map snd)) : Cocone F where
  x := t.x
  Œπ := (diagramIsoSpan F).Hom ‚â´ t.Œπ

/-- Given `F : walking_cospan ‚•§ C`, which is really the same as `cospan (F.map inl) (F.map inr)`,
    and a cone on `F`, we get a pullback cone on `F.map inl` and `F.map inr`. -/
@[simps]
def PullbackCone.ofCone {F : walking_cospan ‚•§ C} (t : Cone F) : PullbackCone (F.map inl) (F.map inr) where
  x := t.x
  œÄ := t.œÄ ‚â´ (diagramIsoCospan F).Hom

/-- A diagram `walking_cospan ‚•§ C` is isomorphic to some `pullback_cone.mk` after
composing with `diagram_iso_cospan`. -/
@[simps]
def PullbackCone.isoMk {F : walking_cospan ‚•§ C} (t : Cone F) :
    (Cones.postcompose (diagramIsoCospan.{v} _).Hom).obj t ‚âÖ
      PullbackCone.mk (t.œÄ.app WalkingCospan.left) (t.œÄ.app WalkingCospan.right)
        ((t.œÄ.naturality inl).symm.trans (t.œÄ.naturality inr : _)) :=
  Cones.ext (Iso.refl _) <| by
    rintro (_ | (_ | _)) <;>
      ¬∑ dsimp
        simp
        

/-- Given `F : walking_span ‚•§ C`, which is really the same as `span (F.map fst) (F.map snd)`,
    and a cocone on `F`, we get a pushout cocone on `F.map fst` and `F.map snd`. -/
@[simps]
def PushoutCocone.ofCocone {F : walking_span ‚•§ C} (t : Cocone F) : PushoutCocone (F.map fst) (F.map snd) where
  x := t.x
  Œπ := (diagramIsoSpan F).inv ‚â´ t.Œπ

/-- A diagram `walking_span ‚•§ C` is isomorphic to some `pushout_cocone.mk` after composing with
`diagram_iso_span`. -/
@[simps]
def PushoutCocone.isoMk {F : walking_span ‚•§ C} (t : Cocone F) :
    (Cocones.precompose (diagramIsoSpan.{v} _).inv).obj t ‚âÖ
      PushoutCocone.mk (t.Œπ.app WalkingSpan.left) (t.Œπ.app WalkingSpan.right)
        ((t.Œπ.naturality fst).trans (t.Œπ.naturality snd).symm) :=
  Cocones.ext (Iso.refl _) <| by
    rintro (_ | (_ | _)) <;>
      ¬∑ dsimp
        simp
        

/-- `has_pullback f g` represents a particular choice of limiting cone
for the pair of morphisms `f : X ‚ü∂ Z` and `g : Y ‚ü∂ Z`.
-/
abbrev HasPullback {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) :=
  HasLimit (cospan f g)

/-- `has_pushout f g` represents a particular choice of colimiting cocone
for the pair of morphisms `f : X ‚ü∂ Y` and `g : X ‚ü∂ Z`.
-/
abbrev HasPushout {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) :=
  HasColimit (span f g)

/-- `pullback f g` computes the pullback of a pair of morphisms with the same target. -/
abbrev pullback {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] :=
  limit (cospan f g)

/-- `pushout f g` computes the pushout of a pair of morphisms with the same source. -/
abbrev pushout {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g] :=
  colimit (span f g)

/-- The first projection of the pullback of `f` and `g`. -/
abbrev pullback.fst {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] : pullback f g ‚ü∂ X :=
  limit.œÄ (cospan f g) WalkingCospan.left

/-- The second projection of the pullback of `f` and `g`. -/
abbrev pullback.snd {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] : pullback f g ‚ü∂ Y :=
  limit.œÄ (cospan f g) WalkingCospan.right

/-- The first inclusion into the pushout of `f` and `g`. -/
abbrev pushout.inl {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] : Y ‚ü∂ pushout f g :=
  colimit.Œπ (span f g) WalkingSpan.left

/-- The second inclusion into the pushout of `f` and `g`. -/
abbrev pushout.inr {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] : Z ‚ü∂ pushout f g :=
  colimit.Œπ (span f g) WalkingSpan.right

/-- A pair of morphisms `h : W ‚ü∂ X` and `k : W ‚ü∂ Y` satisfying `h ‚â´ f = k ‚â´ g` induces a morphism
    `pullback.lift : W ‚ü∂ pullback f g`. -/
abbrev pullback.lift {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X) (k : W ‚ü∂ Y)
    (w : h ‚â´ f = k ‚â´ g) : W ‚ü∂ pullback f g :=
  limit.lift _ (PullbackCone.mk h k w)

/-- A pair of morphisms `h : Y ‚ü∂ W` and `k : Z ‚ü∂ W` satisfying `f ‚â´ h = g ‚â´ k` induces a morphism
    `pushout.desc : pushout f g ‚ü∂ W`. -/
abbrev pushout.desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W) (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) :
    pushout f g ‚ü∂ W :=
  colimit.desc _ (PushoutCocone.mk h k w)

@[simp, reassoc]
theorem pullback.lift_fst {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X) (k : W ‚ü∂ Y)
    (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.fst = h :=
  limit.lift_œÄ _ _

@[simp, reassoc]
theorem pullback.lift_snd {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X) (k : W ‚ü∂ Y)
    (w : h ‚â´ f = k ‚â´ g) : pullback.lift h k w ‚â´ pullback.snd = k :=
  limit.lift_œÄ _ _

@[simp, reassoc]
theorem pushout.inl_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W) (k : Z ‚ü∂ W)
    (w : f ‚â´ h = g ‚â´ k) : pushout.inl ‚â´ pushout.desc h k w = h :=
  colimit.Œπ_desc _ _

@[simp, reassoc]
theorem pushout.inr_desc {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W) (k : Z ‚ü∂ W)
    (w : f ‚â´ h = g ‚â´ k) : pushout.inr ‚â´ pushout.desc h k w = k :=
  colimit.Œπ_desc _ _

/-- A pair of morphisms `h : W ‚ü∂ X` and `k : W ‚ü∂ Y` satisfying `h ‚â´ f = k ‚â´ g` induces a morphism
    `l : W ‚ü∂ pullback f g` such that `l ‚â´ pullback.fst = h` and `l ‚â´ pullback.snd = k`. -/
def pullback.lift' {W X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] (h : W ‚ü∂ X) (k : W ‚ü∂ Y) (w : h ‚â´ f = k ‚â´ g) :
    { l : W ‚ü∂ pullback f g // l ‚â´ pullback.fst = h ‚àß l ‚â´ pullback.snd = k } :=
  ‚ü®pullback.lift h k w, pullback.lift_fst _ _ _, pullback.lift_snd _ _ _‚ü©

/-- A pair of morphisms `h : Y ‚ü∂ W` and `k : Z ‚ü∂ W` satisfying `f ‚â´ h = g ‚â´ k` induces a morphism
    `l : pushout f g ‚ü∂ W` such that `pushout.inl ‚â´ l = h` and `pushout.inr ‚â´ l = k`. -/
def pullback.desc' {W X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] (h : Y ‚ü∂ W) (k : Z ‚ü∂ W) (w : f ‚â´ h = g ‚â´ k) :
    { l : pushout f g ‚ü∂ W // pushout.inl ‚â´ l = h ‚àß pushout.inr ‚â´ l = k } :=
  ‚ü®pushout.desc h k w, pushout.inl_desc _ _ _, pushout.inr_desc _ _ _‚ü©

@[reassoc]
theorem pullback.condition {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] :
    (pullback.fst : pullback f g ‚ü∂ X) ‚â´ f = pullback.snd ‚â´ g :=
  PullbackCone.condition _

@[reassoc]
theorem pushout.condition {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] :
    f ‚â´ (pushout.inl : Y ‚ü∂ pushout f g) = g ‚â´ pushout.inr :=
  PushoutCocone.condition _

/-- Given such a diagram, then there is a natural morphism `W √ó‚Çõ X ‚ü∂ Y √ó‚Çú Z`.

    W  ‚ü∂  Y
      ‚Üò      ‚Üò
        S  ‚ü∂  T
      ‚Üó      ‚Üó
    X  ‚ü∂  Z

-/
abbrev pullback.map {W X Y Z S T : C} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) [HasPullback f‚ÇÅ f‚ÇÇ] (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T)
    [HasPullback g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ) :
    pullback f‚ÇÅ f‚ÇÇ ‚ü∂ pullback g‚ÇÅ g‚ÇÇ :=
  pullback.lift (pullback.fst ‚â´ i‚ÇÅ) (pullback.snd ‚â´ i‚ÇÇ)
    (by
      simp [‚Üê eq‚ÇÅ, ‚Üê eq‚ÇÇ, pullback.condition_assoc])

/-- Given such a diagram, then there is a natural morphism `W ‚®ø‚Çõ X ‚ü∂ Y ‚®ø‚Çú Z`.

        W  ‚ü∂  Y
      ‚Üó      ‚Üó
    S  ‚ü∂  T
      ‚Üò      ‚Üò
        X  ‚ü∂  Z

-/
abbrev pushout.map {W X Y Z S T : C} (f‚ÇÅ : S ‚ü∂ W) (f‚ÇÇ : S ‚ü∂ X) [HasPushout f‚ÇÅ f‚ÇÇ] (g‚ÇÅ : T ‚ü∂ Y) (g‚ÇÇ : T ‚ü∂ Z)
    [HasPushout g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÅ = i‚ÇÉ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÇ = i‚ÇÉ ‚â´ g‚ÇÇ) :
    pushout f‚ÇÅ f‚ÇÇ ‚ü∂ pushout g‚ÇÅ g‚ÇÇ :=
  pushout.desc (i‚ÇÅ ‚â´ pushout.inl) (i‚ÇÇ ‚â´ pushout.inr)
    (by
      simp only [‚Üê category.assoc, eq‚ÇÅ, eq‚ÇÇ]
      simp [pushout.condition])

/-- Two morphisms into a pullback are equal if their compositions with the pullback morphisms are
    equal -/
@[ext]
theorem pullback.hom_ext {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] {W : C} {k l : W ‚ü∂ pullback f g}
    (h‚ÇÄ : k ‚â´ pullback.fst = l ‚â´ pullback.fst) (h‚ÇÅ : k ‚â´ pullback.snd = l ‚â´ pullback.snd) : k = l :=
  limit.hom_ext <| PullbackCone.equalizer_ext _ h‚ÇÄ h‚ÇÅ

/-- The pullback cone built from the pullback projections is a pullback. -/
def pullbackIsPullback {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] :
    IsLimit (PullbackCone.mk (pullback.fst : pullback f g ‚ü∂ _) pullback.snd pullback.condition) :=
  PullbackCone.IsLimit.mk _ (fun s => pullback.lift s.fst s.snd s.condition)
    (by
      simp )
    (by
      simp )
    (by
      tidy)

/-- The pullback of a monomorphism is a monomorphism -/
instance pullback.fst_of_mono {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] [Mono g] :
    Mono (pullback.fst : pullback f g ‚ü∂ X) :=
  PullbackCone.mono_fst_of_is_pullback_of_mono (limit.isLimit _)

/-- The pullback of a monomorphism is a monomorphism -/
instance pullback.snd_of_mono {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z} [HasPullback f g] [Mono f] :
    Mono (pullback.snd : pullback f g ‚ü∂ Y) :=
  PullbackCone.mono_snd_of_is_pullback_of_mono (limit.isLimit _)

/-- The map `X √ó[Z] Y ‚ü∂ X √ó Y` is mono. -/
instance mono_pullback_to_prod {C : Type _} [Category C] {X Y Z : C} (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g]
    [HasBinaryProduct X Y] : Mono (prod.lift pullback.fst pullback.snd : pullback f g ‚ü∂ _) :=
  ‚ü®fun W i‚ÇÅ i‚ÇÇ h => by
    ext
    ¬∑ simpa using congr_arg‚Çì (fun f => f ‚â´ Prod.fst) h
      
    ¬∑ simpa using congr_arg‚Çì (fun f => f ‚â´ Prod.snd) h
      ‚ü©

/-- Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are
    equal -/
@[ext]
theorem pushout.hom_ext {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] {W : C} {k l : pushout f g ‚ü∂ W}
    (h‚ÇÄ : pushout.inl ‚â´ k = pushout.inl ‚â´ l) (h‚ÇÅ : pushout.inr ‚â´ k = pushout.inr ‚â´ l) : k = l :=
  colimit.hom_ext <| PushoutCocone.coequalizer_ext _ h‚ÇÄ h‚ÇÅ

/-- The pushout cocone built from the pushout coprojections is a pushout. -/
def pushoutIsPushout {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g] :
    IsColimit (PushoutCocone.mk (pushout.inl : _ ‚ü∂ pushout f g) pushout.inr pushout.condition) :=
  PushoutCocone.IsColimit.mk _ (fun s => pushout.desc s.inl s.inr s.condition)
    (by
      simp )
    (by
      simp )
    (by
      tidy)

/-- The pushout of an epimorphism is an epimorphism -/
instance pushout.inl_of_epi {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] [Epi g] :
    Epi (pushout.inl : Y ‚ü∂ pushout f g) :=
  PushoutCocone.epi_inl_of_is_pushout_of_epi (colimit.isColimit _)

/-- The pushout of an epimorphism is an epimorphism -/
instance pushout.inr_of_epi {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z} [HasPushout f g] [Epi f] :
    Epi (pushout.inr : Z ‚ü∂ pushout f g) :=
  PushoutCocone.epi_inr_of_is_pushout_of_epi (colimit.isColimit _)

/-- The map ` X ‚®ø Y ‚ü∂ X ‚®ø[Z] Y` is epi. -/
instance epi_coprod_to_pushout {C : Type _} [Category C] {X Y Z : C} (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g]
    [HasBinaryCoproduct Y Z] : Epi (coprod.desc pushout.inl pushout.inr : _ ‚ü∂ pushout f g) :=
  ‚ü®fun W i‚ÇÅ i‚ÇÇ h => by
    ext
    ¬∑ simpa using congr_arg‚Çì (fun f => coprod.inl ‚â´ f) h
      
    ¬∑ simpa using congr_arg‚Çì (fun f => coprod.inr ‚â´ f) h
      ‚ü©

instance pullback.map_is_iso {W X Y Z S T : C} (f‚ÇÅ : W ‚ü∂ S) (f‚ÇÇ : X ‚ü∂ S) [HasPullback f‚ÇÅ f‚ÇÇ] (g‚ÇÅ : Y ‚ü∂ T) (g‚ÇÇ : Z ‚ü∂ T)
    [HasPullback g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÉ = i‚ÇÅ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÉ = i‚ÇÇ ‚â´ g‚ÇÇ)
    [IsIso i‚ÇÅ] [IsIso i‚ÇÇ] [IsIso i‚ÇÉ] : IsIso (pullback.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) := by
  refine' ‚ü®‚ü®pullback.map _ _ _ _ (inv i‚ÇÅ) (inv i‚ÇÇ) (inv i‚ÇÉ) _ _, _, _‚ü©‚ü©
  ¬∑ rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÅ, is_iso.inv_hom_id_assoc]
    
  ¬∑ rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÇ, is_iso.inv_hom_id_assoc]
    
  tidy

/-- If `f‚ÇÅ = f‚ÇÇ` and `g‚ÇÅ = g‚ÇÇ`, we may construct a canonical
isomorphism `pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ` -/
@[simps Hom]
def pullback.congrHom {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [HasPullback f‚ÇÅ g‚ÇÅ]
    [HasPullback f‚ÇÇ g‚ÇÇ] : pullback f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ :=
  as_iso <|
    pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _)
      (by
        simp [h‚ÇÅ])
      (by
        simp [h‚ÇÇ])

@[simp]
theorem pullback.congr_hom_inv {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Z} {g‚ÇÅ g‚ÇÇ : Y ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ)
    [HasPullback f‚ÇÅ g‚ÇÅ] [HasPullback f‚ÇÇ g‚ÇÇ] :
    (pullback.congrHom h‚ÇÅ h‚ÇÇ).inv =
      pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _)
        (by
          simp [h‚ÇÅ])
        (by
          simp [h‚ÇÇ]) :=
  by
  apply pullback.hom_ext
  ¬∑ erw [pullback.lift_fst]
    rw [iso.inv_comp_eq]
    erw [pullback.lift_fst_assoc]
    rw [category.comp_id, category.comp_id]
    
  ¬∑ erw [pullback.lift_snd]
    rw [iso.inv_comp_eq]
    erw [pullback.lift_snd_assoc]
    rw [category.comp_id, category.comp_id]
    

instance pushout.map_is_iso {W X Y Z S T : C} (f‚ÇÅ : S ‚ü∂ W) (f‚ÇÇ : S ‚ü∂ X) [HasPushout f‚ÇÅ f‚ÇÇ] (g‚ÇÅ : T ‚ü∂ Y) (g‚ÇÇ : T ‚ü∂ Z)
    [HasPushout g‚ÇÅ g‚ÇÇ] (i‚ÇÅ : W ‚ü∂ Y) (i‚ÇÇ : X ‚ü∂ Z) (i‚ÇÉ : S ‚ü∂ T) (eq‚ÇÅ : f‚ÇÅ ‚â´ i‚ÇÅ = i‚ÇÉ ‚â´ g‚ÇÅ) (eq‚ÇÇ : f‚ÇÇ ‚â´ i‚ÇÇ = i‚ÇÉ ‚â´ g‚ÇÇ)
    [IsIso i‚ÇÅ] [IsIso i‚ÇÇ] [IsIso i‚ÇÉ] : IsIso (pushout.map f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ i‚ÇÅ i‚ÇÇ i‚ÇÉ eq‚ÇÅ eq‚ÇÇ) := by
  refine' ‚ü®‚ü®pushout.map _ _ _ _ (inv i‚ÇÅ) (inv i‚ÇÇ) (inv i‚ÇÉ) _ _, _, _‚ü©‚ü©
  ¬∑ rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÅ, is_iso.inv_hom_id_assoc]
    
  ¬∑ rw [is_iso.comp_inv_eq, category.assoc, eq‚ÇÇ, is_iso.inv_hom_id_assoc]
    
  tidy

/-- If `f‚ÇÅ = f‚ÇÇ` and `g‚ÇÅ = g‚ÇÇ`, we may construct a canonical
isomorphism `pushout f‚ÇÅ g‚ÇÅ ‚âÖ pullback f‚ÇÇ g‚ÇÇ` -/
@[simps Hom]
def pushout.congrHom {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y} {g‚ÇÅ g‚ÇÇ : X ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ) [HasPushout f‚ÇÅ g‚ÇÅ]
    [HasPushout f‚ÇÇ g‚ÇÇ] : pushout f‚ÇÅ g‚ÇÅ ‚âÖ pushout f‚ÇÇ g‚ÇÇ :=
  as_iso <|
    pushout.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _)
      (by
        simp [h‚ÇÅ])
      (by
        simp [h‚ÇÇ])

@[simp]
theorem pushout.congr_hom_inv {X Y Z : C} {f‚ÇÅ f‚ÇÇ : X ‚ü∂ Y} {g‚ÇÅ g‚ÇÇ : X ‚ü∂ Z} (h‚ÇÅ : f‚ÇÅ = f‚ÇÇ) (h‚ÇÇ : g‚ÇÅ = g‚ÇÇ)
    [HasPushout f‚ÇÅ g‚ÇÅ] [HasPushout f‚ÇÇ g‚ÇÇ] :
    (pushout.congrHom h‚ÇÅ h‚ÇÇ).inv =
      pushout.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _)
        (by
          simp [h‚ÇÅ])
        (by
          simp [h‚ÇÇ]) :=
  by
  apply pushout.hom_ext
  ¬∑ erw [pushout.inl_desc]
    rw [iso.comp_inv_eq, category.id_comp]
    erw [pushout.inl_desc]
    rw [category.id_comp]
    
  ¬∑ erw [pushout.inr_desc]
    rw [iso.comp_inv_eq, category.id_comp]
    erw [pushout.inr_desc]
    rw [category.id_comp]
    

section

variable (G : C ‚•§ D)

/-- The comparison morphism for the pullback of `f,g`.
This is an isomorphism iff `G` preserves the pullback of `f,g`; see
`category_theory/limits/preserves/shapes/pullbacks.lean`
-/
def pullbackComparison (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [HasPullback (G.map f) (G.map g)] :
    G.obj (pullback f g) ‚ü∂ pullback (G.map f) (G.map g) :=
  pullback.lift (G.map pullback.fst) (G.map pullback.snd)
    (by
      simp only [‚Üê G.map_comp, pullback.condition])

@[simp, reassoc]
theorem pullback_comparison_comp_fst (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [HasPullback (G.map f) (G.map g)] :
    pullbackComparison G f g ‚â´ pullback.fst = G.map pullback.fst :=
  pullback.lift_fst _ _ _

@[simp, reassoc]
theorem pullback_comparison_comp_snd (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [HasPullback (G.map f) (G.map g)] :
    pullbackComparison G f g ‚â´ pullback.snd = G.map pullback.snd :=
  pullback.lift_snd _ _ _

@[simp, reassoc]
theorem map_lift_pullback_comparison (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [HasPullback f g] [HasPullback (G.map f) (G.map g)] {W : C}
    {h : W ‚ü∂ X} {k : W ‚ü∂ Y} (w : h ‚â´ f = k ‚â´ g) :
    G.map (pullback.lift _ _ w) ‚â´ pullbackComparison G f g =
      pullback.lift (G.map h) (G.map k)
        (by
          simp only [‚Üê G.map_comp, w]) :=
  by
  ext <;> simp [‚Üê G.map_comp]

/-- The comparison morphism for the pushout of `f,g`.
This is an isomorphism iff `G` preserves the pushout of `f,g`; see
`category_theory/limits/preserves/shapes/pullbacks.lean`
-/
def pushoutComparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g] [HasPushout (G.map f) (G.map g)] :
    pushout (G.map f) (G.map g) ‚ü∂ G.obj (pushout f g) :=
  pushout.desc (G.map pushout.inl) (G.map pushout.inr)
    (by
      simp only [‚Üê G.map_comp, pushout.condition])

@[simp, reassoc]
theorem inl_comp_pushout_comparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g] [HasPushout (G.map f) (G.map g)] :
    pushout.inl ‚â´ pushoutComparison G f g = G.map pushout.inl :=
  pushout.inl_desc _ _ _

@[simp, reassoc]
theorem inr_comp_pushout_comparison (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g] [HasPushout (G.map f) (G.map g)] :
    pushout.inr ‚â´ pushoutComparison G f g = G.map pushout.inr :=
  pushout.inr_desc _ _ _

@[simp, reassoc]
theorem pushout_comparison_map_desc (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [HasPushout f g] [HasPushout (G.map f) (G.map g)] {W : C}
    {h : Y ‚ü∂ W} {k : Z ‚ü∂ W} (w : f ‚â´ h = g ‚â´ k) :
    pushoutComparison G f g ‚â´ G.map (pushout.desc _ _ w) =
      pushout.desc (G.map h) (G.map k)
        (by
          simp only [‚Üê G.map_comp, w]) :=
  by
  ext <;> simp [‚Üê G.map_comp]

end

section PullbackSymmetry

open WalkingCospan

variable (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z)

/-- Making this a global instance would make the typeclass seach go in an infinite loop. -/
theorem has_pullback_symmetry [HasPullback f g] : HasPullback g f :=
  ‚ü®‚ü®‚ü®PullbackCone.mk _ _ pullback.condition.symm, PullbackCone.flipIsLimit (pullbackIsPullback _ _)‚ü©‚ü©‚ü©

attribute [local instance] has_pullback_symmetry

/-- The isomorphism `X √ó[Z] Y ‚âÖ Y √ó[Z] X`. -/
def pullbackSymmetry [HasPullback f g] : pullback f g ‚âÖ pullback g f :=
  IsLimit.conePointUniqueUpToIso
    (PullbackCone.flipIsLimit (pullbackIsPullback f g) : IsLimit (PullbackCone.mk _ _ pullback.condition.symm))
    (limit.isLimit _)

@[simp, reassoc]
theorem pullback_symmetry_hom_comp_fst [HasPullback f g] : (pullbackSymmetry f g).Hom ‚â´ pullback.fst = pullback.snd :=
  by
  simp [pullback_symmetry]

@[simp, reassoc]
theorem pullback_symmetry_hom_comp_snd [HasPullback f g] : (pullbackSymmetry f g).Hom ‚â´ pullback.snd = pullback.fst :=
  by
  simp [pullback_symmetry]

@[simp, reassoc]
theorem pullback_symmetry_inv_comp_fst [HasPullback f g] : (pullbackSymmetry f g).inv ‚â´ pullback.fst = pullback.snd :=
  by
  simp [iso.inv_comp_eq]

@[simp, reassoc]
theorem pullback_symmetry_inv_comp_snd [HasPullback f g] : (pullbackSymmetry f g).inv ‚â´ pullback.snd = pullback.fst :=
  by
  simp [iso.inv_comp_eq]

end PullbackSymmetry

section PushoutSymmetry

open WalkingCospan

variable (f : X ‚ü∂ Y) (g : X ‚ü∂ Z)

/-- Making this a global instance would make the typeclass seach go in an infinite loop. -/
theorem has_pushout_symmetry [HasPushout f g] : HasPushout g f :=
  ‚ü®‚ü®‚ü®PushoutCocone.mk _ _ pushout.condition.symm, PushoutCocone.flipIsColimit (pushoutIsPushout _ _)‚ü©‚ü©‚ü©

attribute [local instance] has_pushout_symmetry

/-- The isomorphism `Y ‚®ø[X] Z ‚âÖ Z ‚®ø[X] Y`. -/
def pushoutSymmetry [HasPushout f g] : pushout f g ‚âÖ pushout g f :=
  IsColimit.coconePointUniqueUpToIso
    (PushoutCocone.flipIsColimit (pushoutIsPushout f g) : IsColimit (PushoutCocone.mk _ _ pushout.condition.symm))
    (colimit.isColimit _)

@[simp, reassoc]
theorem inl_comp_pushout_symmetry_hom [HasPushout f g] : pushout.inl ‚â´ (pushoutSymmetry f g).Hom = pushout.inr :=
  (colimit.isColimit (span f g)).comp_cocone_point_unique_up_to_iso_hom
    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _

@[simp, reassoc]
theorem inr_comp_pushout_symmetry_hom [HasPushout f g] : pushout.inr ‚â´ (pushoutSymmetry f g).Hom = pushout.inl :=
  (colimit.isColimit (span f g)).comp_cocone_point_unique_up_to_iso_hom
    (PushoutCocone.flipIsColimit (pushoutIsPushout g f)) _

@[simp, reassoc]
theorem inl_comp_pushout_symmetry_inv [HasPushout f g] : pushout.inl ‚â´ (pushoutSymmetry f g).inv = pushout.inr := by
  simp [iso.comp_inv_eq]

@[simp, reassoc]
theorem inr_comp_pushout_symmetry_inv [HasPushout f g] : pushout.inr ‚â´ (pushoutSymmetry f g).inv = pushout.inl := by
  simp [iso.comp_inv_eq]

end PushoutSymmetry

section PullbackLeftIso

open WalkingCospan

/-- The pullback of `f, g` is also the pullback of `f ‚â´ i, g ‚â´ i` for any mono `i`. -/
noncomputable def pullbackIsPullbackOfCompMono (f : X ‚ü∂ W) (g : Y ‚ü∂ W) (i : W ‚ü∂ Z) [Mono i] [HasPullback f g] :
    IsLimit (PullbackCone.mk pullback.fst pullback.snd _) :=
  PullbackCone.isLimitOfCompMono f g i _ (limit.isLimit (cospan f g))

instance has_pullback_of_comp_mono (f : X ‚ü∂ W) (g : Y ‚ü∂ W) (i : W ‚ü∂ Z) [Mono i] [HasPullback f g] :
    HasPullback (f ‚â´ i) (g ‚â´ i) :=
  ‚ü®‚ü®‚ü®_, pullbackIsPullbackOfCompMono f g i‚ü©‚ü©‚ü©

variable (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [IsIso f]

/-- If `f : X ‚ü∂ Z` is iso, then `X √ó[Z] Y ‚âÖ Y`. This is the explicit limit cone. -/
def pullbackConeOfLeftIso : PullbackCone f g :=
  PullbackCone.mk (g ‚â´ inv f) (ùüô _) <| by
    simp

@[simp]
theorem pullback_cone_of_left_iso_X : (pullbackConeOfLeftIso f g).x = Y :=
  rfl

@[simp]
theorem pullback_cone_of_left_iso_fst : (pullbackConeOfLeftIso f g).fst = g ‚â´ inv f :=
  rfl

@[simp]
theorem pullback_cone_of_left_iso_snd : (pullbackConeOfLeftIso f g).snd = ùüô _ :=
  rfl

@[simp]
theorem pullback_cone_of_left_iso_œÄ_app_none : (pullbackConeOfLeftIso f g).œÄ.app none = g := by
  delta' pullback_cone_of_left_iso
  simp

@[simp]
theorem pullback_cone_of_left_iso_œÄ_app_left : (pullbackConeOfLeftIso f g).œÄ.app left = g ‚â´ inv f :=
  rfl

@[simp]
theorem pullback_cone_of_left_iso_œÄ_app_right : (pullbackConeOfLeftIso f g).œÄ.app right = ùüô _ :=
  rfl

/-- Verify that the constructed limit cone is indeed a limit. -/
def pullbackConeOfLeftIsoIsLimit : IsLimit (pullbackConeOfLeftIso f g) :=
  PullbackCone.isLimitAux' _ fun s =>
    ‚ü®s.snd, by
      simp [‚Üê s.condition_assoc]‚ü©

theorem has_pullback_of_left_iso : HasPullback f g :=
  ‚ü®‚ü®‚ü®_, pullbackConeOfLeftIsoIsLimit f g‚ü©‚ü©‚ü©

attribute [local instance] has_pullback_of_left_iso

instance pullback_snd_iso_of_left_iso : IsIso (pullback.snd : pullback f g ‚ü∂ _) := by
  refine'
    ‚ü®‚ü®pullback.lift (g ‚â´ inv f) (ùüô _)
          (by
            simp ),
        _, by
        simp ‚ü©‚ü©
  ext
  ¬∑ simp [‚Üê pullback.condition_assoc]
    
  ¬∑ simp [pullback.condition_assoc]
    

variable (i : Z ‚ü∂ W) [Mono i]

instance has_pullback_of_right_factors_mono (f : X ‚ü∂ Z) : HasPullback i (f ‚â´ i) := by
  conv => congr rw [‚Üê category.id_comp i]
  infer_instance

instance pullback_snd_iso_of_right_factors_mono (f : X ‚ü∂ Z) : IsIso (pullback.snd : pullback i (f ‚â´ i) ‚ü∂ _) := by
  convert
      (congr_arg‚Çì is_iso
            (show _ ‚â´ pullback.snd = _ from
              limit.iso_limit_cone_hom_œÄ ‚ü®_, pullback_is_pullback_of_comp_mono (ùüô _) f i‚ü© walking_cospan.right)).mp
        inferInstance <;>
    exact (category.id_comp _).symm

end PullbackLeftIso

section PullbackRightIso

open WalkingCospan

variable (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) [IsIso g]

/-- If `g : Y ‚ü∂ Z` is iso, then `X √ó[Z] Y ‚âÖ X`. This is the explicit limit cone. -/
def pullbackConeOfRightIso : PullbackCone f g :=
  PullbackCone.mk (ùüô _) (f ‚â´ inv g) <| by
    simp

@[simp]
theorem pullback_cone_of_right_iso_X : (pullbackConeOfRightIso f g).x = X :=
  rfl

@[simp]
theorem pullback_cone_of_right_iso_fst : (pullbackConeOfRightIso f g).fst = ùüô _ :=
  rfl

@[simp]
theorem pullback_cone_of_right_iso_snd : (pullbackConeOfRightIso f g).snd = f ‚â´ inv g :=
  rfl

@[simp]
theorem pullback_cone_of_right_iso_œÄ_app_none : (pullbackConeOfRightIso f g).œÄ.app none = f :=
  Category.id_comp _

@[simp]
theorem pullback_cone_of_right_iso_œÄ_app_left : (pullbackConeOfRightIso f g).œÄ.app left = ùüô _ :=
  rfl

@[simp]
theorem pullback_cone_of_right_iso_œÄ_app_right : (pullbackConeOfRightIso f g).œÄ.app right = f ‚â´ inv g :=
  rfl

/-- Verify that the constructed limit cone is indeed a limit. -/
def pullbackConeOfRightIsoIsLimit : IsLimit (pullbackConeOfRightIso f g) :=
  PullbackCone.isLimitAux' _ fun s =>
    ‚ü®s.fst, by
      simp [s.condition_assoc]‚ü©

theorem has_pullback_of_right_iso : HasPullback f g :=
  ‚ü®‚ü®‚ü®_, pullbackConeOfRightIsoIsLimit f g‚ü©‚ü©‚ü©

attribute [local instance] has_pullback_of_right_iso

instance pullback_snd_iso_of_right_iso : IsIso (pullback.fst : pullback f g ‚ü∂ _) := by
  refine'
    ‚ü®‚ü®pullback.lift (ùüô _) (f ‚â´ inv g)
          (by
            simp ),
        _, by
        simp ‚ü©‚ü©
  ext
  ¬∑ simp
    
  ¬∑ simp [pullback.condition_assoc]
    

variable (i : Z ‚ü∂ W) [Mono i]

instance has_pullback_of_left_factors_mono (f : X ‚ü∂ Z) : HasPullback (f ‚â´ i) i := by
  conv => congr skip rw [‚Üê category.id_comp i]
  infer_instance

instance pullback_snd_iso_of_left_factors_mono (f : X ‚ü∂ Z) : IsIso (pullback.fst : pullback (f ‚â´ i) i ‚ü∂ _) := by
  convert
      (congr_arg‚Çì is_iso
            (show _ ‚â´ pullback.fst = _ from
              limit.iso_limit_cone_hom_œÄ ‚ü®_, pullback_is_pullback_of_comp_mono f (ùüô _) i‚ü© walking_cospan.left)).mp
        inferInstance <;>
    exact (category.id_comp _).symm

end PullbackRightIso

section PushoutLeftIso

open WalkingSpan

/-- The pushout of `f, g` is also the pullback of `h ‚â´ f, h ‚â´ g` for any epi `h`. -/
noncomputable def pushoutIsPushoutOfEpiComp (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : W ‚ü∂ X) [Epi h] [HasPushout f g] :
    IsColimit (PushoutCocone.mk pushout.inl pushout.inr _) :=
  PushoutCocone.isColimitOfEpiComp f g h _ (colimit.isColimit (span f g))

instance has_pushout_of_epi_comp (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (h : W ‚ü∂ X) [Epi h] [HasPushout f g] :
    HasPushout (h ‚â´ f) (h ‚â´ g) :=
  ‚ü®‚ü®‚ü®_, pushoutIsPushoutOfEpiComp f g h‚ü©‚ü©‚ü©

variable (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [IsIso f]

/-- If `f : X ‚ü∂ Y` is iso, then `Y ‚®ø[X] Z ‚âÖ Z`. This is the explicit colimit cocone. -/
def pushoutCoconeOfLeftIso : PushoutCocone f g :=
  PushoutCocone.mk (inv f ‚â´ g) (ùüô _) <| by
    simp

@[simp]
theorem pushout_cocone_of_left_iso_X : (pushoutCoconeOfLeftIso f g).x = Z :=
  rfl

@[simp]
theorem pushout_cocone_of_left_iso_inl : (pushoutCoconeOfLeftIso f g).inl = inv f ‚â´ g :=
  rfl

@[simp]
theorem pushout_cocone_of_left_iso_inr : (pushoutCoconeOfLeftIso f g).inr = ùüô _ :=
  rfl

@[simp]
theorem pushout_cocone_of_left_iso_Œπ_app_none : (pushoutCoconeOfLeftIso f g).Œπ.app none = g := by
  delta' pushout_cocone_of_left_iso
  simp

@[simp]
theorem pushout_cocone_of_left_iso_Œπ_app_left : (pushoutCoconeOfLeftIso f g).Œπ.app left = inv f ‚â´ g :=
  rfl

@[simp]
theorem pushout_cocone_of_left_iso_Œπ_app_right : (pushoutCoconeOfLeftIso f g).Œπ.app right = ùüô _ :=
  rfl

/-- Verify that the constructed cocone is indeed a colimit. -/
def pushoutCoconeOfLeftIsoIsLimit : IsColimit (pushoutCoconeOfLeftIso f g) :=
  PushoutCocone.isColimitAux' _ fun s =>
    ‚ü®s.inr, by
      simp [‚Üê s.condition]‚ü©

theorem has_pushout_of_left_iso : HasPushout f g :=
  ‚ü®‚ü®‚ü®_, pushoutCoconeOfLeftIsoIsLimit f g‚ü©‚ü©‚ü©

attribute [local instance] has_pushout_of_left_iso

instance pushout_inr_iso_of_left_iso : IsIso (pushout.inr : _ ‚ü∂ pushout f g) := by
  refine'
    ‚ü®‚ü®pushout.desc (inv f ‚â´ g) (ùüô _)
          (by
            simp ),
        by
        simp , _‚ü©‚ü©
  ext
  ¬∑ simp [‚Üê pushout.condition]
    
  ¬∑ simp [pushout.condition_assoc]
    

variable (h : W ‚ü∂ X) [Epi h]

instance has_pushout_of_right_factors_epi (f : X ‚ü∂ Y) : HasPushout h (h ‚â´ f) := by
  conv => congr rw [‚Üê category.comp_id h]
  infer_instance

instance pushout_inr_iso_of_right_factors_epi (f : X ‚ü∂ Y) : IsIso (pushout.inr : _ ‚ü∂ pushout h (h ‚â´ f)) := by
  convert
      (congr_arg‚Çì is_iso
            (show pushout.inr ‚â´ _ = _ from
              colimit.iso_colimit_cocone_Œπ_inv ‚ü®_, pushout_is_pushout_of_epi_comp (ùüô _) f h‚ü© walking_span.right)).mp
        inferInstance <;>
    exact (category.comp_id _).symm

end PushoutLeftIso

section PushoutRightIso

open WalkingSpan

variable (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) [IsIso g]

/-- If `f : X ‚ü∂ Z` is iso, then `Y ‚®ø[X] Z ‚âÖ Y`. This is the explicit colimit cocone. -/
def pushoutCoconeOfRightIso : PushoutCocone f g :=
  PushoutCocone.mk (ùüô _) (inv g ‚â´ f) <| by
    simp

@[simp]
theorem pushout_cocone_of_right_iso_X : (pushoutCoconeOfRightIso f g).x = Y :=
  rfl

@[simp]
theorem pushout_cocone_of_right_iso_inl : (pushoutCoconeOfRightIso f g).inl = ùüô _ :=
  rfl

@[simp]
theorem pushout_cocone_of_right_iso_inr : (pushoutCoconeOfRightIso f g).inr = inv g ‚â´ f :=
  rfl

@[simp]
theorem pushout_cocone_of_right_iso_Œπ_app_none : (pushoutCoconeOfRightIso f g).Œπ.app none = f := by
  delta' pushout_cocone_of_right_iso
  simp

@[simp]
theorem pushout_cocone_of_right_iso_Œπ_app_left : (pushoutCoconeOfRightIso f g).Œπ.app left = ùüô _ :=
  rfl

@[simp]
theorem pushout_cocone_of_right_iso_Œπ_app_right : (pushoutCoconeOfRightIso f g).Œπ.app right = inv g ‚â´ f :=
  rfl

/-- Verify that the constructed cocone is indeed a colimit. -/
def pushoutCoconeOfRightIsoIsLimit : IsColimit (pushoutCoconeOfRightIso f g) :=
  PushoutCocone.isColimitAux' _ fun s =>
    ‚ü®s.inl, by
      simp [‚Üê s.condition]‚ü©

theorem has_pushout_of_right_iso : HasPushout f g :=
  ‚ü®‚ü®‚ü®_, pushoutCoconeOfRightIsoIsLimit f g‚ü©‚ü©‚ü©

attribute [local instance] has_pushout_of_right_iso

instance pushout_inl_iso_of_right_iso : IsIso (pushout.inl : _ ‚ü∂ pushout f g) := by
  refine'
    ‚ü®‚ü®pushout.desc (ùüô _) (inv g ‚â´ f)
          (by
            simp ),
        by
        simp , _‚ü©‚ü©
  ext
  ¬∑ simp [‚Üê pushout.condition]
    
  ¬∑ simp [pushout.condition]
    

variable (h : W ‚ü∂ X) [Epi h]

instance has_pushout_of_left_factors_epi (f : X ‚ü∂ Y) : HasPushout (h ‚â´ f) h := by
  conv => congr skip rw [‚Üê category.comp_id h]
  infer_instance

instance pushout_inl_iso_of_left_factors_epi (f : X ‚ü∂ Y) : IsIso (pushout.inl : _ ‚ü∂ pushout (h ‚â´ f) h) := by
  convert
      (congr_arg‚Çì is_iso
            (show pushout.inl ‚â´ _ = _ from
              colimit.iso_colimit_cocone_Œπ_inv ‚ü®_, pushout_is_pushout_of_epi_comp f (ùüô _) h‚ü© walking_span.left)).mp
        inferInstance <;>
    exact (category.comp_id _).symm

end PushoutRightIso

section

open WalkingCospan

variable (f : X ‚ü∂ Y)

instance has_kernel_pair_of_mono [Mono f] : HasPullback f f :=
  ‚ü®‚ü®‚ü®_, PullbackCone.isLimitMkIdId f‚ü©‚ü©‚ü©

theorem fst_eq_snd_of_mono_eq [Mono f] : (pullback.fst : pullback f f ‚ü∂ _) = pullback.snd :=
  ((PullbackCone.isLimitMkIdId f).fac (getLimitCone (cospan f f)).Cone left).symm.trans
    ((PullbackCone.isLimitMkIdId f).fac (getLimitCone (cospan f f)).Cone right : _)

@[simp]
theorem pullback_symmetry_hom_of_mono_eq [Mono f] : (pullbackSymmetry f f).Hom = ùüô _ := by
  ext <;> simp [fst_eq_snd_of_mono_eq]

instance fst_iso_of_mono_eq [Mono f] : IsIso (pullback.fst : pullback f f ‚ü∂ _) := by
  refine'
    ‚ü®‚ü®pullback.lift (ùüô _) (ùüô _)
          (by
            simp ),
        _, by
        simp ‚ü©‚ü©
  ext
  ¬∑ simp
    
  ¬∑ simp [fst_eq_snd_of_mono_eq]
    

instance snd_iso_of_mono_eq [Mono f] : IsIso (pullback.snd : pullback f f ‚ü∂ _) := by
  rw [‚Üê fst_eq_snd_of_mono_eq]
  infer_instance

end

section

open WalkingSpan

variable (f : X ‚ü∂ Y)

instance has_cokernel_pair_of_epi [Epi f] : HasPushout f f :=
  ‚ü®‚ü®‚ü®_, PushoutCocone.isColimitMkIdId f‚ü©‚ü©‚ü©

theorem inl_eq_inr_of_epi_eq [Epi f] : (pushout.inl : _ ‚ü∂ pushout f f) = pushout.inr :=
  ((PushoutCocone.isColimitMkIdId f).fac (getColimitCocone (span f f)).Cocone left).symm.trans
    ((PushoutCocone.isColimitMkIdId f).fac (getColimitCocone (span f f)).Cocone right : _)

@[simp]
theorem pullback_symmetry_hom_of_epi_eq [Epi f] : (pushoutSymmetry f f).Hom = ùüô _ := by
  ext <;> simp [inl_eq_inr_of_epi_eq]

instance inl_iso_of_epi_eq [Epi f] : IsIso (pushout.inl : _ ‚ü∂ pushout f f) := by
  refine'
    ‚ü®‚ü®pushout.desc (ùüô _) (ùüô _)
          (by
            simp ),
        by
        simp , _‚ü©‚ü©
  ext
  ¬∑ simp
    
  ¬∑ simp [inl_eq_inr_of_epi_eq]
    

instance inr_iso_of_epi_eq [Epi f] : IsIso (pushout.inr : _ ‚ü∂ pushout f f) := by
  rw [‚Üê inl_eq_inr_of_epi_eq]
  infer_instance

end

section PasteLemma

variable {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ Y‚ÇÉ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (g‚ÇÅ : Y‚ÇÅ ‚ü∂ Y‚ÇÇ) (g‚ÇÇ : Y‚ÇÇ ‚ü∂ Y‚ÇÉ)

variable (i‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (i‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (i‚ÇÉ : X‚ÇÉ ‚ü∂ Y‚ÇÉ)

variable (h‚ÇÅ : i‚ÇÅ ‚â´ g‚ÇÅ = f‚ÇÅ ‚â´ i‚ÇÇ) (h‚ÇÇ : i‚ÇÇ ‚â´ g‚ÇÇ = f‚ÇÇ ‚â´ i‚ÇÉ)

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the big square is a pullback if both the small squares are.
-/
def bigSquareIsPullback (H : IsLimit (PullbackCone.mk _ _ h‚ÇÇ)) (H' : IsLimit (PullbackCone.mk _ _ h‚ÇÅ)) :
    IsLimit
      (PullbackCone.mk _ _
        (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
          rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc])) :=
  by
  fapply pullback_cone.is_limit_aux'
  intro s
  have : (s.fst ‚â´ g‚ÇÅ) ‚â´ g‚ÇÇ = s.snd ‚â´ i‚ÇÉ := by
    rw [‚Üê s.condition, category.assoc]
  rcases pullback_cone.is_limit.lift' H (s.fst ‚â´ g‚ÇÅ) s.snd this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  rcases pullback_cone.is_limit.lift' H' s.fst l‚ÇÅ hl‚ÇÅ.symm with ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©
  use l‚ÇÇ
  use hl‚ÇÇ
  use
    show l‚ÇÇ ‚â´ f‚ÇÅ ‚â´ f‚ÇÇ = s.snd by
      rw [‚Üê hl‚ÇÅ', ‚Üê hl‚ÇÇ', category.assoc]
      rfl
  intro m hm‚ÇÅ hm‚ÇÇ
  apply pullback_cone.is_limit.hom_ext H'
  ¬∑ erw [hm‚ÇÅ, hl‚ÇÇ]
    
  ¬∑ apply pullback_cone.is_limit.hom_ext H
    ¬∑ erw [category.assoc, ‚Üê h‚ÇÅ, ‚Üê category.assoc, hm‚ÇÅ, ‚Üê hl‚ÇÇ, category.assoc, category.assoc, h‚ÇÅ]
      rfl
      
    ¬∑ erw [category.assoc, hm‚ÇÇ, ‚Üê hl‚ÇÅ', ‚Üê hl‚ÇÇ']
      
    

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the big square is a pushout if both the small squares are.
-/
def bigSquareIsPushout (H : IsColimit (PushoutCocone.mk _ _ h‚ÇÇ)) (H' : IsColimit (PushoutCocone.mk _ _ h‚ÇÅ)) :
    IsColimit
      (PushoutCocone.mk _ _
        (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
          rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc])) :=
  by
  fapply pushout_cocone.is_colimit_aux'
  intro s
  have : i‚ÇÅ ‚â´ s.inl = f‚ÇÅ ‚â´ f‚ÇÇ ‚â´ s.inr := by
    rw [s.condition, category.assoc]
  rcases pushout_cocone.is_colimit.desc' H' s.inl (f‚ÇÇ ‚â´ s.inr) this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  rcases pushout_cocone.is_colimit.desc' H l‚ÇÅ s.inr hl‚ÇÅ' with ‚ü®l‚ÇÇ, hl‚ÇÇ, hl‚ÇÇ'‚ü©
  use l‚ÇÇ
  use
    show (g‚ÇÅ ‚â´ g‚ÇÇ) ‚â´ l‚ÇÇ = s.inl by
      rw [‚Üê hl‚ÇÅ, ‚Üê hl‚ÇÇ, category.assoc]
      rfl
  use hl‚ÇÇ'
  intro m hm‚ÇÅ hm‚ÇÇ
  apply pushout_cocone.is_colimit.hom_ext H
  ¬∑ apply pushout_cocone.is_colimit.hom_ext H'
    ¬∑ erw [‚Üê category.assoc, hm‚ÇÅ, hl‚ÇÇ, hl‚ÇÅ]
      
    ¬∑ erw [‚Üê category.assoc, h‚ÇÇ, category.assoc, hm‚ÇÇ, ‚Üê hl‚ÇÇ', ‚Üê category.assoc, ‚Üê category.assoc, ‚Üê h‚ÇÇ]
      rfl
      
    
  ¬∑ erw [hm‚ÇÇ, hl‚ÇÇ']
    

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the left square is a pullback if the right square and the big square are.
-/
def leftSquareIsPullback (H : IsLimit (PullbackCone.mk _ _ h‚ÇÇ))
    (H' :
      IsLimit
        (PullbackCone.mk _ _
          (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
            rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc]))) :
    IsLimit (PullbackCone.mk _ _ h‚ÇÅ) := by
  fapply pullback_cone.is_limit_aux'
  intro s
  have : s.fst ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (s.snd ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ := by
    rw [‚Üê category.assoc, s.condition, category.assoc, category.assoc, h‚ÇÇ]
  rcases pullback_cone.is_limit.lift' H' s.fst (s.snd ‚â´ f‚ÇÇ) this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  use l‚ÇÅ
  use hl‚ÇÅ
  constructor
  ¬∑ apply pullback_cone.is_limit.hom_ext H
    ¬∑ erw [category.assoc, ‚Üê h‚ÇÅ, ‚Üê category.assoc, hl‚ÇÅ, s.condition]
      rfl
      
    ¬∑ erw [category.assoc, hl‚ÇÅ']
      rfl
      
    
  ¬∑ intro m hm‚ÇÅ hm‚ÇÇ
    apply pullback_cone.is_limit.hom_ext H'
    ¬∑ erw [hm‚ÇÅ, hl‚ÇÅ]
      
    ¬∑ erw [hl‚ÇÅ', ‚Üê hm‚ÇÇ]
      exact (category.assoc _ _ _).symm
      
    

/-- Given

X‚ÇÅ - f‚ÇÅ -> X‚ÇÇ - f‚ÇÇ -> X‚ÇÉ
|          |          |
i‚ÇÅ         i‚ÇÇ         i‚ÇÉ
‚à®          ‚à®          ‚à®
Y‚ÇÅ - g‚ÇÅ -> Y‚ÇÇ - g‚ÇÇ -> Y‚ÇÉ

Then the right square is a pushout if the left square and the big square are.
-/
def rightSquareIsPushout (H : IsColimit (PushoutCocone.mk _ _ h‚ÇÅ))
    (H' :
      IsColimit
        (PushoutCocone.mk _ _
          (show i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ g‚ÇÇ = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ i‚ÇÉ by
            rw [‚Üê category.assoc, h‚ÇÅ, category.assoc, h‚ÇÇ, category.assoc]))) :
    IsColimit (PushoutCocone.mk _ _ h‚ÇÇ) := by
  fapply pushout_cocone.is_colimit_aux'
  intro s
  have : i‚ÇÅ ‚â´ g‚ÇÅ ‚â´ s.inl = (f‚ÇÅ ‚â´ f‚ÇÇ) ‚â´ s.inr := by
    rw [category.assoc, ‚Üê s.condition, ‚Üê category.assoc, ‚Üê category.assoc, h‚ÇÅ]
  rcases pushout_cocone.is_colimit.desc' H' (g‚ÇÅ ‚â´ s.inl) s.inr this with ‚ü®l‚ÇÅ, hl‚ÇÅ, hl‚ÇÅ'‚ü©
  dsimp  at *
  use l‚ÇÅ
  refine' ‚ü®_, _, _‚ü©
  ¬∑ apply pushout_cocone.is_colimit.hom_ext H
    ¬∑ erw [‚Üê category.assoc, hl‚ÇÅ]
      rfl
      
    ¬∑ erw [‚Üê category.assoc, h‚ÇÇ, category.assoc, hl‚ÇÅ', s.condition]
      
    
  ¬∑ exact hl‚ÇÅ'
    
  ¬∑ intro m hm‚ÇÅ hm‚ÇÇ
    apply pushout_cocone.is_colimit.hom_ext H'
    ¬∑ erw [hl‚ÇÅ, category.assoc, hm‚ÇÅ]
      
    ¬∑ erw [hm‚ÇÇ, hl‚ÇÅ']
      
    

end PasteLemma

section

variable (f : X ‚ü∂ Z) (g : Y ‚ü∂ Z) (f' : W ‚ü∂ X)

variable [HasPullback f g] [HasPullback f' (pullback.fst : pullback f g ‚ü∂ _)]

variable [HasPullback (f' ‚â´ f) g]

/-- The canonical isomorphism `W √ó[X] (X √ó[Z] Y) ‚âÖ W √ó[Z] Y` -/
noncomputable def pullbackRightPullbackFstIso : pullback f' (pullback.fst : pullback f g ‚ü∂ _) ‚âÖ pullback (f' ‚â´ f) g :=
  by
  let this :=
    big_square_is_pullback (pullback.snd : pullback f' (pullback.fst : pullback f g ‚ü∂ _) ‚ü∂ _) pullback.snd f' f
      pullback.fst pullback.fst g pullback.condition pullback.condition (pullback_is_pullback _ _)
      (pullback_is_pullback _ _)
  exact (this.cone_point_unique_up_to_iso (pullback_is_pullback _ _) : _)

@[simp, reassoc]
theorem pullback_right_pullback_fst_iso_hom_fst :
    (pullbackRightPullbackFstIso f g f').Hom ‚â´ pullback.fst = pullback.fst :=
  IsLimit.cone_point_unique_up_to_iso_hom_comp _ _ WalkingCospan.left

@[simp, reassoc]
theorem pullback_right_pullback_fst_iso_hom_snd :
    (pullbackRightPullbackFstIso f g f').Hom ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd :=
  IsLimit.cone_point_unique_up_to_iso_hom_comp _ _ WalkingCospan.right

@[simp, reassoc]
theorem pullback_right_pullback_fst_iso_inv_fst :
    (pullbackRightPullbackFstIso f g f').inv ‚â´ pullback.fst = pullback.fst :=
  IsLimit.cone_point_unique_up_to_iso_inv_comp _ _ WalkingCospan.left

@[simp, reassoc]
theorem pullback_right_pullback_fst_iso_inv_snd_snd :
    (pullbackRightPullbackFstIso f g f').inv ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd :=
  IsLimit.cone_point_unique_up_to_iso_inv_comp _ _ WalkingCospan.right

@[simp, reassoc]
theorem pullback_right_pullback_fst_iso_inv_snd_fst :
    (pullbackRightPullbackFstIso f g f').inv ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst ‚â´ f' := by
  rw [‚Üê pullback.condition]
  exact pullback_right_pullback_fst_iso_inv_fst_assoc _ _ _ _

end

section

variable (f : X ‚ü∂ Y) (g : X ‚ü∂ Z) (g' : Z ‚ü∂ W)

variable [HasPushout f g] [HasPushout (pushout.inr : _ ‚ü∂ pushout f g) g']

variable [HasPushout f (g ‚â´ g')]

/-- The canonical isomorphism `(Y ‚®ø[X] Z) ‚®ø[Z] W ‚âÖ Y √ó[X] W` -/
noncomputable def pushoutLeftPushoutInrIso : pushout (pushout.inr : _ ‚ü∂ pushout f g) g' ‚âÖ pushout f (g ‚â´ g') :=
  ((bigSquareIsPushout g g' _ _ f _ _ pushout.condition pushout.condition (pushoutIsPushout _ _)
        (pushoutIsPushout _ _)).coconePointUniqueUpToIso
    (pushoutIsPushout _ _) :
    _)

@[simp, reassoc]
theorem inl_pushout_left_pushout_inr_iso_inv :
    pushout.inl ‚â´ (pushoutLeftPushoutInrIso f g g').inv = pushout.inl ‚â´ pushout.inl :=
  ((bigSquareIsPushout g g' _ _ f _ _ pushout.condition pushout.condition (pushoutIsPushout _ _)
        (pushoutIsPushout _ _)).comp_cocone_point_unique_up_to_iso_inv
    (pushoutIsPushout _ _) WalkingSpan.left :
    _)

@[simp, reassoc]
theorem inr_pushout_left_pushout_inr_iso_hom : pushout.inr ‚â´ (pushoutLeftPushoutInrIso f g g').Hom = pushout.inr :=
  ((bigSquareIsPushout g g' _ _ f _ _ pushout.condition pushout.condition (pushoutIsPushout _ _)
        (pushoutIsPushout _ _)).comp_cocone_point_unique_up_to_iso_hom
    (pushoutIsPushout _ _) WalkingSpan.right :
    _)

@[simp, reassoc]
theorem inr_pushout_left_pushout_inr_iso_inv : pushout.inr ‚â´ (pushoutLeftPushoutInrIso f g g').inv = pushout.inr := by
  rw [iso.comp_inv_eq, inr_pushout_left_pushout_inr_iso_hom]

@[simp, reassoc]
theorem inl_inl_pushout_left_pushout_inr_iso_hom :
    pushout.inl ‚â´ pushout.inl ‚â´ (pushoutLeftPushoutInrIso f g g').Hom = pushout.inl := by
  rw [‚Üê category.assoc, ‚Üê iso.eq_comp_inv, inl_pushout_left_pushout_inr_iso_inv]

@[simp, reassoc]
theorem inr_inl_pushout_left_pushout_inr_iso_hom :
    pushout.inr ‚â´ pushout.inl ‚â´ (pushoutLeftPushoutInrIso f g g').Hom = g' ‚â´ pushout.inr := by
  rw [‚Üê category.assoc, ‚Üê iso.eq_comp_inv, category.assoc, inr_pushout_left_pushout_inr_iso_inv, pushout.condition]

end

section PullbackAssoc

/-
The objects and morphisms are as follows:

           Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
           |          |
           g‚ÇÉ         f‚ÇÑ
           ‚à®          ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|          |
g‚ÇÅ         f‚ÇÇ
‚à®          ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ

where the two squares are pullbacks.

We can then construct the pullback squares

W  - l‚ÇÇ -> Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
|                     |
l‚ÇÅ                    f‚ÇÑ
‚à®                     ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ

and

W' - l‚ÇÇ' -> Z‚ÇÇ
|           |
l‚ÇÅ'         g‚ÇÉ
‚à®           ‚à®
Z‚ÇÅ          X‚ÇÇ
|           |
g‚ÇÅ          f‚ÇÇ
‚à®           ‚à®
X‚ÇÅ -  f‚ÇÅ -> Y‚ÇÅ

We will show that both `W` and `W'` are pullbacks over `g‚ÇÅ, g‚ÇÇ`, and thus we may construct a
canonical isomorphism between them. -/
variable {X‚ÇÅ X‚ÇÇ X‚ÇÉ Y‚ÇÅ Y‚ÇÇ : C} (f‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÉ : X‚ÇÇ ‚ü∂ Y‚ÇÇ)

variable (f‚ÇÑ : X‚ÇÉ ‚ü∂ Y‚ÇÇ) [HasPullback f‚ÇÅ f‚ÇÇ] [HasPullback f‚ÇÉ f‚ÇÑ]

include f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ

-- mathport name: ¬´exprZ‚ÇÅ¬ª
local notation "Z‚ÇÅ" => pullback f‚ÇÅ f‚ÇÇ

-- mathport name: ¬´exprZ‚ÇÇ¬ª
local notation "Z‚ÇÇ" => pullback f‚ÇÉ f‚ÇÑ

-- mathport name: ¬´exprg‚ÇÅ¬ª
local notation "g‚ÇÅ" => (pullback.fst : Z‚ÇÅ ‚ü∂ X‚ÇÅ)

-- mathport name: ¬´exprg‚ÇÇ¬ª
local notation "g‚ÇÇ" => (pullback.snd : Z‚ÇÅ ‚ü∂ X‚ÇÇ)

-- mathport name: ¬´exprg‚ÇÉ¬ª
local notation "g‚ÇÉ" => (pullback.fst : Z‚ÇÇ ‚ü∂ X‚ÇÇ)

-- mathport name: ¬´exprg‚ÇÑ¬ª
local notation "g‚ÇÑ" => (pullback.snd : Z‚ÇÇ ‚ü∂ X‚ÇÉ)

-- mathport name: ¬´exprW¬ª
local notation "W" => pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ

-- mathport name: ¬´exprW'¬ª
local notation "W'" => pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)

-- mathport name: ¬´exprl‚ÇÅ¬ª
local notation "l‚ÇÅ" => (pullback.fst : W ‚ü∂ Z‚ÇÅ)

-- mathport name: ¬´exprl‚ÇÇ¬ª
local notation "l‚ÇÇ" =>
  (pullback.lift (pullback.fst ‚â´ g‚ÇÇ) pullback.snd ((Category.assoc _ _ _).trans pullback.condition) : W ‚ü∂ Z‚ÇÇ)

-- mathport name: ¬´exprl‚ÇÅ'¬ª
local notation "l‚ÇÅ'" =>
  (pullback.lift pullback.fst (pullback.snd ‚â´ g‚ÇÉ) (pullback.condition.trans (Category.assoc _ _ _).symm) : W' ‚ü∂ Z‚ÇÅ)

-- mathport name: ¬´exprl‚ÇÇ'¬ª
local notation "l‚ÇÇ'" => (pullback.snd : W' ‚ü∂ Z‚ÇÇ)

/-- `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullbackPullbackLeftIsPullback [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] :
    IsLimit (PullbackCone.mk l‚ÇÅ l‚ÇÇ (show l‚ÇÅ ‚â´ g‚ÇÇ = l‚ÇÇ ‚â´ g‚ÇÉ from (pullback.lift_fst _ _ _).symm)) := by
  apply left_square_is_pullback
  exact pullback_is_pullback f‚ÇÉ f‚ÇÑ
  convert pullback_is_pullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ
  rw [pullback.lift_snd]

/-- `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ` is the pullback `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullbackAssocIsPullback [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] :
    IsLimit
      (PullbackCone.mk (l‚ÇÅ ‚â´ g‚ÇÅ) l‚ÇÇ
        (show (l‚ÇÅ ‚â´ g‚ÇÅ) ‚â´ f‚ÇÅ = l‚ÇÇ ‚â´ g‚ÇÉ ‚â´ f‚ÇÇ by
          rw [pullback.lift_fst_assoc, category.assoc, category.assoc, pullback.condition])) :=
  by
  apply pullback_cone.flip_is_limit
  apply big_square_is_pullback
  ¬∑ apply pullback_cone.flip_is_limit
    exact pullback_is_pullback f‚ÇÅ f‚ÇÇ
    
  ¬∑ apply pullback_cone.flip_is_limit
    apply pullback_pullback_left_is_pullback
    
  ¬∑ exact pullback.lift_fst _ _ _
    
  ¬∑ exact pullback.condition.symm
    

theorem has_pullback_assoc [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] : HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ) :=
  ‚ü®‚ü®‚ü®_, pullbackAssocIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ‚ü©‚ü©‚ü©

/-- `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
def pullbackPullbackRightIsPullback [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] :
    IsLimit (PullbackCone.mk l‚ÇÅ' l‚ÇÇ' (show l‚ÇÅ' ‚â´ g‚ÇÇ = l‚ÇÇ' ‚â´ g‚ÇÉ from pullback.lift_snd _ _ _)) := by
  apply pullback_cone.flip_is_limit
  apply left_square_is_pullback
  ¬∑ apply pullback_cone.flip_is_limit
    exact pullback_is_pullback f‚ÇÅ f‚ÇÇ
    
  ¬∑ apply pullback_cone.flip_is_limit
    convert pullback_is_pullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)
    rw [pullback.lift_fst]
    
  ¬∑ exact pullback.condition.symm
    

/-- `X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)` is the pullback `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ`. -/
def pullbackAssocSymmIsPullback [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] :
    IsLimit
      (PullbackCone.mk l‚ÇÅ' (l‚ÇÇ' ‚â´ g‚ÇÑ)
        (show l‚ÇÅ' ‚â´ g‚ÇÇ ‚â´ f‚ÇÉ = (l‚ÇÇ' ‚â´ g‚ÇÑ) ‚â´ f‚ÇÑ by
          rw [pullback.lift_snd_assoc, category.assoc, category.assoc, pullback.condition])) :=
  by
  apply big_square_is_pullback
  exact pullback_is_pullback f‚ÇÉ f‚ÇÑ
  apply pullback_pullback_right_is_pullback

theorem has_pullback_assoc_symm [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)] : HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ :=
  ‚ü®‚ü®‚ü®_, pullbackAssocSymmIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ‚ü©‚ü©‚ü©

variable [HasPullback (g‚ÇÇ ‚â´ f‚ÇÉ) f‚ÇÑ] [HasPullback f‚ÇÅ (g‚ÇÉ ‚â´ f‚ÇÇ)]

/-- The canonical isomorphism `(X‚ÇÅ √ó[Y‚ÇÅ] X‚ÇÇ) √ó[Y‚ÇÇ] X‚ÇÉ ‚âÖ X‚ÇÅ √ó[Y‚ÇÅ] (X‚ÇÇ √ó[Y‚ÇÇ] X‚ÇÉ)`. -/
noncomputable def pullbackAssoc :
    pullback (pullback.snd ‚â´ f‚ÇÉ : pullback f‚ÇÅ f‚ÇÇ ‚ü∂ _) f‚ÇÑ ‚âÖ pullback f‚ÇÅ (pullback.fst ‚â´ f‚ÇÇ : pullback f‚ÇÉ f‚ÇÑ ‚ü∂ _) :=
  (pullbackPullbackLeftIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).conePointUniqueUpToIso (pullbackPullbackRightIsPullback f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ)

@[simp, reassoc]
theorem pullback_assoc_inv_fst_fst : (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.fst ‚â´ pullback.fst = pullback.fst := by
  trans l‚ÇÅ' ‚â´ pullback.fst
  rw [‚Üê category.assoc]
  congr 1
  exact is_limit.cone_point_unique_up_to_iso_inv_comp _ _ walking_cospan.left
  exact pullback.lift_fst _ _ _

@[simp, reassoc]
theorem pullback_assoc_hom_fst : (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).Hom ‚â´ pullback.fst = pullback.fst ‚â´ pullback.fst := by
  rw [‚Üê iso.eq_inv_comp, pullback_assoc_inv_fst_fst]

@[simp, reassoc]
theorem pullback_assoc_hom_snd_fst :
    (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).Hom ‚â´ pullback.snd ‚â´ pullback.fst = pullback.fst ‚â´ pullback.snd := by
  trans l‚ÇÇ ‚â´ pullback.fst
  rw [‚Üê category.assoc]
  congr 1
  exact is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.right
  exact pullback.lift_fst _ _ _

@[simp, reassoc]
theorem pullback_assoc_hom_snd_snd : (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).Hom ‚â´ pullback.snd ‚â´ pullback.snd = pullback.snd := by
  trans l‚ÇÇ ‚â´ pullback.snd
  rw [‚Üê category.assoc]
  congr 1
  exact is_limit.cone_point_unique_up_to_iso_hom_comp _ _ walking_cospan.right
  exact pullback.lift_snd _ _ _

@[simp, reassoc]
theorem pullback_assoc_inv_fst_snd :
    (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.fst ‚â´ pullback.snd = pullback.snd ‚â´ pullback.fst := by
  rw [iso.inv_comp_eq, pullback_assoc_hom_snd_fst]

@[simp, reassoc]
theorem pullback_assoc_inv_snd : (pullbackAssoc f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ).inv ‚â´ pullback.snd = pullback.snd ‚â´ pullback.snd := by
  rw [iso.inv_comp_eq, pullback_assoc_hom_snd_snd]

end PullbackAssoc

section PushoutAssoc

/-
The objects and morphisms are as follows:

           Z‚ÇÇ - g‚ÇÑ -> X‚ÇÉ
           |          |
           g‚ÇÉ         f‚ÇÑ
           ‚à®          ‚à®
Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|          |
g‚ÇÅ         f‚ÇÇ
‚à®          ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ

where the two squares are pushouts.

We can then construct the pushout squares

Z‚ÇÅ - g‚ÇÇ -> X‚ÇÇ - f‚ÇÉ -> Y‚ÇÇ
|                     |
g‚ÇÅ                    l‚ÇÇ
‚à®                     ‚à®
X‚ÇÅ - f‚ÇÅ -> Y‚ÇÅ - l‚ÇÅ -> W

and

Z‚ÇÇ - g‚ÇÑ  -> X‚ÇÉ
|           |
g‚ÇÉ          f‚ÇÑ
‚à®           ‚à®
X‚ÇÇ          Y‚ÇÇ
|           |
f‚ÇÇ          l‚ÇÇ'
‚à®           ‚à®
Y‚ÇÅ - l‚ÇÅ' -> W'

We will show that both `W` and `W'` are pushouts over `f‚ÇÇ, f‚ÇÉ`, and thus we may construct a
canonical isomorphism between them. -/
variable {X‚ÇÅ X‚ÇÇ X‚ÇÉ Z‚ÇÅ Z‚ÇÇ : C} (g‚ÇÅ : Z‚ÇÅ ‚ü∂ X‚ÇÅ) (g‚ÇÇ : Z‚ÇÅ ‚ü∂ X‚ÇÇ) (g‚ÇÉ : Z‚ÇÇ ‚ü∂ X‚ÇÇ)

variable (g‚ÇÑ : Z‚ÇÇ ‚ü∂ X‚ÇÉ) [HasPushout g‚ÇÅ g‚ÇÇ] [HasPushout g‚ÇÉ g‚ÇÑ]

include g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ

-- mathport name: ¬´exprY‚ÇÅ¬ª
local notation "Y‚ÇÅ" => pushout g‚ÇÅ g‚ÇÇ

-- mathport name: ¬´exprY‚ÇÇ¬ª
local notation "Y‚ÇÇ" => pushout g‚ÇÉ g‚ÇÑ

-- mathport name: ¬´exprf‚ÇÅ¬ª
local notation "f‚ÇÅ" => (pushout.inl : X‚ÇÅ ‚ü∂ Y‚ÇÅ)

-- mathport name: ¬´exprf‚ÇÇ¬ª
local notation "f‚ÇÇ" => (pushout.inr : X‚ÇÇ ‚ü∂ Y‚ÇÅ)

-- mathport name: ¬´exprf‚ÇÉ¬ª
local notation "f‚ÇÉ" => (pushout.inl : X‚ÇÇ ‚ü∂ Y‚ÇÇ)

-- mathport name: ¬´exprf‚ÇÑ¬ª
local notation "f‚ÇÑ" => (pushout.inr : X‚ÇÉ ‚ü∂ Y‚ÇÇ)

-- mathport name: ¬´exprW¬ª
local notation "W" => pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)

-- mathport name: ¬´exprW'¬ª
local notation "W'" => pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ

-- mathport name: ¬´exprl‚ÇÅ¬ª
local notation "l‚ÇÅ" =>
  (pushout.desc pushout.inl (f‚ÇÉ ‚â´ pushout.inr) (pushout.condition.trans (Category.assoc _ _ _)) : Y‚ÇÅ ‚ü∂ W)

-- mathport name: ¬´exprl‚ÇÇ¬ª
local notation "l‚ÇÇ" => (pushout.inr : Y‚ÇÇ ‚ü∂ W)

-- mathport name: ¬´exprl‚ÇÅ'¬ª
local notation "l‚ÇÅ'" => (pushout.inl : Y‚ÇÅ ‚ü∂ W')

-- mathport name: ¬´exprl‚ÇÇ'¬ª
local notation "l‚ÇÇ'" =>
  (pushout.desc (f‚ÇÇ ‚â´ pushout.inl) pushout.inr ((Category.assoc _ _ _).symm.trans pushout.condition) : Y‚ÇÇ ‚ü∂ W')

/-- `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushoutPushoutLeftIsPushout [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] :
    IsColimit (PushoutCocone.mk l‚ÇÅ' l‚ÇÇ' (show f‚ÇÇ ‚â´ l‚ÇÅ' = f‚ÇÉ ‚â´ l‚ÇÇ' from (pushout.inl_desc _ _ _).symm)) := by
  apply pushout_cocone.flip_is_colimit
  apply right_square_is_pushout
  ¬∑ apply pushout_cocone.flip_is_colimit
    exact pushout_is_pushout _ _
    
  ¬∑ apply pushout_cocone.flip_is_colimit
    convert pushout_is_pushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ
    exact pushout.inr_desc _ _ _
    
  ¬∑ exact pushout.condition.symm
    

/-- `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ` is the pushout `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushoutAssocIsPushout [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] :
    IsColimit
      (PushoutCocone.mk (f‚ÇÅ ‚â´ l‚ÇÅ') l‚ÇÇ'
        (show g‚ÇÅ ‚â´ f‚ÇÅ ‚â´ l‚ÇÅ' = (g‚ÇÇ ‚â´ f‚ÇÉ) ‚â´ l‚ÇÇ' by
          rw [category.assoc, pushout.inl_desc, pushout.condition_assoc])) :=
  by
  apply big_square_is_pushout
  ¬∑ apply pushout_pushout_left_is_pushout
    
  ¬∑ exact pushout_is_pushout _ _
    

theorem has_pushout_assoc [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] : HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ) :=
  ‚ü®‚ü®‚ü®_, pushoutAssocIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ‚ü©‚ü©‚ü©

/-- `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) √ó[X‚ÇÇ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
def pushoutPushoutRightIsPushout [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] :
    IsColimit (PushoutCocone.mk l‚ÇÅ l‚ÇÇ (show f‚ÇÇ ‚â´ l‚ÇÅ = f‚ÇÉ ‚â´ l‚ÇÇ from pushout.inr_desc _ _ _)) := by
  apply right_square_is_pushout
  ¬∑ exact pushout_is_pushout _ _
    
  ¬∑ convert pushout_is_pushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)
    rw [pushout.inl_desc]
    

/-- `X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)` is the pushout `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ`. -/
def pushoutAssocSymmIsPushout [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] :
    IsColimit
      (PushoutCocone.mk l‚ÇÅ (f‚ÇÑ ‚â´ l‚ÇÇ)
        (show (g‚ÇÉ ‚â´ f‚ÇÇ) ‚â´ l‚ÇÅ = g‚ÇÑ ‚â´ f‚ÇÑ ‚â´ l‚ÇÇ by
          rw [category.assoc, pushout.inr_desc, pushout.condition_assoc])) :=
  by
  apply pushout_cocone.flip_is_colimit
  apply big_square_is_pushout
  ¬∑ apply pushout_cocone.flip_is_colimit
    apply pushout_pushout_right_is_pushout
    
  ¬∑ apply pushout_cocone.flip_is_colimit
    exact pushout_is_pushout _ _
    
  ¬∑ exact pushout.condition.symm
    
  ¬∑ exact (pushout.inr_desc _ _ _).symm
    

theorem has_pushout_assoc_symm [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)] : HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ :=
  ‚ü®‚ü®‚ü®_, pushoutAssocSymmIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ‚ü©‚ü©‚ü©

variable [HasPushout (g‚ÇÉ ‚â´ f‚ÇÇ) g‚ÇÑ] [HasPushout g‚ÇÅ (g‚ÇÇ ‚â´ f‚ÇÉ)]

/-- The canonical isomorphism `(X‚ÇÅ ‚®ø[Z‚ÇÅ] X‚ÇÇ) ‚®ø[Z‚ÇÇ] X‚ÇÉ ‚âÖ X‚ÇÅ ‚®ø[Z‚ÇÅ] (X‚ÇÇ ‚®ø[Z‚ÇÇ] X‚ÇÉ)`. -/
noncomputable def pushoutAssoc :
    pushout (g‚ÇÉ ‚â´ pushout.inr : _ ‚ü∂ pushout g‚ÇÅ g‚ÇÇ) g‚ÇÑ ‚âÖ pushout g‚ÇÅ (g‚ÇÇ ‚â´ pushout.inl : _ ‚ü∂ pushout g‚ÇÉ g‚ÇÑ) :=
  (pushoutPushoutLeftIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).coconePointUniqueUpToIso (pushoutPushoutRightIsPushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ)

@[simp, reassoc]
theorem inl_inl_pushout_assoc_hom : pushout.inl ‚â´ pushout.inl ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).Hom = pushout.inl := by
  trans f‚ÇÅ ‚â´ l‚ÇÅ
  ¬∑ congr 1
    exact (pushout_pushout_left_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).comp_cocone_point_unique_up_to_iso_hom _ walking_cospan.left
    
  ¬∑ exact pushout.inl_desc _ _ _
    

@[simp, reassoc]
theorem inr_inl_pushout_assoc_hom :
    pushout.inr ‚â´ pushout.inl ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).Hom = pushout.inl ‚â´ pushout.inr := by
  trans f‚ÇÇ ‚â´ l‚ÇÅ
  ¬∑ congr 1
    exact (pushout_pushout_left_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).comp_cocone_point_unique_up_to_iso_hom _ walking_cospan.left
    
  ¬∑ exact pushout.inr_desc _ _ _
    

@[simp, reassoc]
theorem inr_inr_pushout_assoc_inv : pushout.inr ‚â´ pushout.inr ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inr := by
  trans f‚ÇÑ ‚â´ l‚ÇÇ'
  ¬∑ congr 1
    exact
      (pushout_pushout_left_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).comp_cocone_point_unique_up_to_iso_inv
        (pushout_pushout_right_is_pushout g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ) walking_cospan.right
    
  ¬∑ exact pushout.inr_desc _ _ _
    

@[simp, reassoc]
theorem inl_pushout_assoc_inv : pushout.inl ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inl ‚â´ pushout.inl := by
  rw [iso.comp_inv_eq, category.assoc, inl_inl_pushout_assoc_hom]

@[simp, reassoc]
theorem inl_inr_pushout_assoc_inv :
    pushout.inl ‚â´ pushout.inr ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).inv = pushout.inr ‚â´ pushout.inl := by
  rw [‚Üê category.assoc, iso.comp_inv_eq, category.assoc, inr_inl_pushout_assoc_hom]

@[simp, reassoc]
theorem inr_pushout_assoc_hom : pushout.inr ‚â´ (pushoutAssoc g‚ÇÅ g‚ÇÇ g‚ÇÉ g‚ÇÑ).Hom = pushout.inr ‚â´ pushout.inr := by
  rw [‚Üê iso.eq_comp_inv, category.assoc, inr_inr_pushout_assoc_inv]

end PushoutAssoc

variable (C)

/-- `has_pullbacks` represents a choice of pullback for every pair of morphisms

See https://stacks.math.columbia.edu/tag/001W
-/
abbrev HasPullbacks :=
  HasLimitsOfShape WalkingCospan.{v} C

/-- `has_pushouts` represents a choice of pushout for every pair of morphisms -/
abbrev HasPushouts :=
  HasColimitsOfShape WalkingSpan.{v} C

/-- If `C` has all limits of diagrams `cospan f g`, then it has all pullbacks -/
theorem has_pullbacks_of_has_limit_cospan [‚àÄ {X Y Z : C} {f : X ‚ü∂ Z} {g : Y ‚ü∂ Z}, HasLimit (cospan f g)] :
    HasPullbacks C :=
  { HasLimit := fun F => has_limit_of_iso (diagramIsoCospan F).symm }

/-- If `C` has all colimits of diagrams `span f g`, then it has all pushouts -/
theorem has_pushouts_of_has_colimit_span [‚àÄ {X Y Z : C} {f : X ‚ü∂ Y} {g : X ‚ü∂ Z}, HasColimit (span f g)] :
    HasPushouts C :=
  { HasColimit := fun F => has_colimit_of_iso (diagramIsoSpan F) }

end CategoryTheory.Limits

