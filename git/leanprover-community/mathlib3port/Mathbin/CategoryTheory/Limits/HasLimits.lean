/-
Copyright (c) 2018 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Reid Barton, Mario Carneiro, Scott Morrison, Floris van Doorn
-/
import Mathbin.CategoryTheory.Limits.IsLimit
import Mathbin.CategoryTheory.Category.Ulift

/-!
# Existence of limits and colimits

In `category_theory.limits.is_limit` we defined `is_limit c`,
the data showing that a cone `c` is a limit cone.

The two main structures defined in this file are:
* `limit_cone F`, which consists of a choice of cone for `F` and the fact it is a limit cone, and
* `has_limit F`, asserting the mere existence of some limit cone for `F`.

`has_limit` is a propositional typeclass
(it's important that it is a proposition merely asserting the existence of a limit,
as otherwise we would have non-defeq problems from incompatible instances).

While `has_limit` only asserts the existence of a limit cone,
we happily use the axiom of choice in mathlib,
so there are convenience functions all depending on `has_limit F`:
* `limit F : C`, producing some limit object (of course all such are isomorphic)
* `limit.œÄ F j : limit F ‚ü∂ F.obj j`, the morphisms out of the limit,
* `limit.lift F c : c.X ‚ü∂ limit F`, the universal morphism from any other `c : cone F`, etc.

Key to using the `has_limit` interface is that there is an `@[ext]` lemma stating that
to check `f = g`, for `f g : Z ‚ü∂ limit F`, it suffices to check `f ‚â´ limit.œÄ F j = g ‚â´ limit.œÄ F j`
for every `j`.
This, combined with `@[simp]` lemmas, makes it possible to prove many easy facts about limits using
automation (e.g. `tidy`).

There are abbreviations `has_limits_of_shape J C` and `has_limits C`
asserting the existence of classes of limits.
Later more are introduced, for finite limits, special shapes of limits, etc.

Ideally, many results about limits should be stated first in terms of `is_limit`,
and then a result in terms of `has_limit` derived from this.
At this point, however, this is far from uniformly achieved in mathlib ---
often statements are only written in terms of `has_limit`.

## Implementation
At present we simply say everything twice, in order to handle both limits and colimits.
It would be highly desirable to have some automation support,
e.g. a `@[dualize]` attribute that behaves similarly to `@[to_additive]`.

## References
* [Stacks: Limits and colimits](https://stacks.math.columbia.edu/tag/002D)

-/


noncomputable section

open CategoryTheory CategoryTheory.Category CategoryTheory.Functor Opposite

namespace CategoryTheory.Limits

-- morphism levels before object levels. See note [category_theory universes].
universe v‚ÇÅ u‚ÇÅ v‚ÇÇ u‚ÇÇ v‚ÇÉ u‚ÇÉ v v' v'' u u' u''

variable {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J] {K : Type u‚ÇÇ} [Category.{v‚ÇÇ} K]

variable {C : Type u} [Category.{v} C]

variable {F : J ‚•§ C}

section Limit

/-- `limit_cone F` contains a cone over `F` together with the information that it is a limit. -/
@[nolint has_inhabited_instance]
structure LimitCone (F : J ‚•§ C) where
  Cone : Cone F
  IsLimit : IsLimit cone

/-- `has_limit F` represents the mere existence of a limit for `F`. -/
class HasLimit (F : J ‚•§ C) : Prop where mk' ::
  exists_limit : Nonempty (LimitCone F)

theorem HasLimit.mk {F : J ‚•§ C} (d : LimitCone F) : HasLimit F :=
  ‚ü®Nonempty.intro d‚ü©

/-- Use the axiom of choice to extract explicit `limit_cone F` from `has_limit F`. -/
def getLimitCone (F : J ‚•§ C) [HasLimit F] : LimitCone F :=
  Classical.choice <| has_limit.exists_limit

variable (J C)

/-- `C` has limits of shape `J` if there exists a limit for every functor `F : J ‚•§ C`. -/
class HasLimitsOfShape : Prop where
  HasLimit : ‚àÄ F : J ‚•§ C, HasLimit F := by
    run_tac
      tactic.apply_instance

/-- `C` has all limits of size `v‚ÇÅ u‚ÇÅ` (`has_limits_of_size.{v‚ÇÅ u‚ÇÅ} C`)
if it has limits of every shape `J : Type u‚ÇÅ` with `[category.{v‚ÇÅ} J]`.
-/
class HasLimitsOfSize (C : Type u) [Category.{v} C] : Prop where
  HasLimitsOfShape : ‚àÄ (J : Type u‚ÇÅ) [ùí• : Category.{v‚ÇÅ} J], HasLimitsOfShape J C := by
    run_tac
      tactic.apply_instance

/-- `C` has all (small) limits if it has limits of every shape that is as big as its hom-sets. -/
abbrev HasLimits (C : Type u) [Category.{v} C] : Prop :=
  HasLimitsOfSize.{v, v} C

theorem HasLimits.has_limits_of_shape {C : Type u} [Category.{v} C] [HasLimits C] (J : Type v) [Category.{v} J] :
    HasLimitsOfShape J C :=
  HasLimitsOfSize.has_limits_of_shape J

variable {J C}

-- see Note [lower instance priority]
instance (priority := 100) has_limit_of_has_limits_of_shape {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J] [H : HasLimitsOfShape J C]
    (F : J ‚•§ C) : HasLimit F :=
  HasLimitsOfShape.has_limit F

-- see Note [lower instance priority]
instance (priority := 100) has_limits_of_shape_of_has_limits {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
    [H : HasLimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C] : HasLimitsOfShape J C :=
  HasLimitsOfSize.has_limits_of_shape J

/-- An arbitrary choice of limit cone for a functor. -/
-- Interface to the `has_limit` class.
def Limit.cone (F : J ‚•§ C) [HasLimit F] : Cone F :=
  (getLimitCone F).Cone

/-- An arbitrary choice of limit object of a functor. -/
def limit (F : J ‚•§ C) [HasLimit F] :=
  (Limit.cone F).x

/-- The projection from the limit object to a value of the functor. -/
def limit.œÄ (F : J ‚•§ C) [HasLimit F] (j : J) : limit F ‚ü∂ F.obj j :=
  (Limit.cone F).œÄ.app j

@[simp]
theorem limit.cone_X {F : J ‚•§ C} [HasLimit F] : (Limit.cone F).x = limit F :=
  rfl

@[simp]
theorem limit.cone_œÄ {F : J ‚•§ C} [HasLimit F] : (Limit.cone F).œÄ.app = limit.œÄ _ :=
  rfl

@[simp, reassoc]
theorem limit.w (F : J ‚•§ C) [HasLimit F] {j j' : J} (f : j ‚ü∂ j') : limit.œÄ F j ‚â´ F.map f = limit.œÄ F j' :=
  (Limit.cone F).w f

/-- Evidence that the arbitrary choice of cone provied by `limit.cone F` is a limit cone. -/
def limit.isLimit (F : J ‚•§ C) [HasLimit F] : IsLimit (Limit.cone F) :=
  (getLimitCone F).IsLimit

/-- The morphism from the cone point of any other cone to the limit object. -/
def limit.lift (F : J ‚•§ C) [HasLimit F] (c : Cone F) : c.x ‚ü∂ limit F :=
  (limit.isLimit F).lift c

@[simp]
theorem limit.is_limit_lift {F : J ‚•§ C} [HasLimit F] (c : Cone F) : (limit.isLimit F).lift c = limit.lift F c :=
  rfl

@[simp, reassoc]
theorem limit.lift_œÄ {F : J ‚•§ C} [HasLimit F] (c : Cone F) (j : J) : limit.lift F c ‚â´ limit.œÄ F j = c.œÄ.app j :=
  IsLimit.fac _ c j

/-- Functoriality of limits.

Usually this morphism should be accessed through `lim.map`,
but may be needed separately when you have specified limits for the source and target functors,
but not necessarily for all functors of shape `J`.
-/
def limMap {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (Œ± : F ‚ü∂ G) : limit F ‚ü∂ limit G :=
  IsLimit.map _ (limit.isLimit G) Œ±

@[simp, reassoc]
theorem lim_map_œÄ {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (Œ± : F ‚ü∂ G) (j : J) :
    limMap Œ± ‚â´ limit.œÄ G j = limit.œÄ F j ‚â´ Œ±.app j :=
  limit.lift_œÄ _ j

/-- The cone morphism from any cone to the arbitrary choice of limit cone. -/
def limit.coneMorphism {F : J ‚•§ C} [HasLimit F] (c : Cone F) : c ‚ü∂ Limit.cone F :=
  (limit.isLimit F).liftConeMorphism c

@[simp]
theorem limit.cone_morphism_hom {F : J ‚•§ C} [HasLimit F] (c : Cone F) : (limit.coneMorphism c).Hom = limit.lift F c :=
  rfl

theorem limit.cone_morphism_œÄ {F : J ‚•§ C} [HasLimit F] (c : Cone F) (j : J) :
    (limit.coneMorphism c).Hom ‚â´ limit.œÄ F j = c.œÄ.app j := by
  simp

@[simp, reassoc]
theorem limit.cone_point_unique_up_to_iso_hom_comp {F : J ‚•§ C} [HasLimit F] {c : Cone F} (hc : IsLimit c) (j : J) :
    (IsLimit.conePointUniqueUpToIso hc (limit.isLimit _)).Hom ‚â´ limit.œÄ F j = c.œÄ.app j :=
  IsLimit.cone_point_unique_up_to_iso_hom_comp _ _ _

@[simp, reassoc]
theorem limit.cone_point_unique_up_to_iso_inv_comp {F : J ‚•§ C} [HasLimit F] {c : Cone F} (hc : IsLimit c) (j : J) :
    (IsLimit.conePointUniqueUpToIso (limit.isLimit _) hc).inv ‚â´ limit.œÄ F j = c.œÄ.app j :=
  IsLimit.cone_point_unique_up_to_iso_inv_comp _ _ _

theorem limit.exists_unique {F : J ‚•§ C} [HasLimit F] (t : Cone F) :
    ‚àÉ! l : t.x ‚ü∂ limit F, ‚àÄ j, l ‚â´ limit.œÄ F j = t.œÄ.app j :=
  (limit.isLimit F).ExistsUnique _

/-- Given any other limit cone for `F`, the chosen `limit F` is isomorphic to the cone point.
-/
def limit.isoLimitCone {F : J ‚•§ C} [HasLimit F] (t : LimitCone F) : limit F ‚âÖ t.Cone.x :=
  IsLimit.conePointUniqueUpToIso (limit.isLimit F) t.IsLimit

@[simp, reassoc]
theorem limit.iso_limit_cone_hom_œÄ {F : J ‚•§ C} [HasLimit F] (t : LimitCone F) (j : J) :
    (limit.isoLimitCone t).Hom ‚â´ t.Cone.œÄ.app j = limit.œÄ F j := by
  dsimp' [‚Üê limit.iso_limit_cone, ‚Üê is_limit.cone_point_unique_up_to_iso]
  tidy

@[simp, reassoc]
theorem limit.iso_limit_cone_inv_œÄ {F : J ‚•§ C} [HasLimit F] (t : LimitCone F) (j : J) :
    (limit.isoLimitCone t).inv ‚â´ limit.œÄ F j = t.Cone.œÄ.app j := by
  dsimp' [‚Üê limit.iso_limit_cone, ‚Üê is_limit.cone_point_unique_up_to_iso]
  tidy

@[ext]
theorem limit.hom_ext {F : J ‚•§ C} [HasLimit F] {X : C} {f f' : X ‚ü∂ limit F}
    (w : ‚àÄ j, f ‚â´ limit.œÄ F j = f' ‚â´ limit.œÄ F j) : f = f' :=
  (limit.isLimit F).hom_ext w

@[simp]
theorem limit.lift_map {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (c : Cone F) (Œ± : F ‚ü∂ G) :
    limit.lift F c ‚â´ limMap Œ± = limit.lift G ((Cones.postcompose Œ±).obj c) := by
  ext
  rw [assoc, lim_map_œÄ, limit.lift_œÄ_assoc, limit.lift_œÄ]
  rfl

@[simp]
theorem limit.lift_cone {F : J ‚•§ C} [HasLimit F] : limit.lift F (Limit.cone F) = ùüô (limit F) :=
  (limit.isLimit _).lift_self

/-- The isomorphism (in `Type`) between
morphisms from a specified object `W` to the limit object,
and cones with cone point `W`.
-/
def limit.homIso (F : J ‚•§ C) [HasLimit F] (W : C) : ULift.{u‚ÇÅ} (W ‚ü∂ limit F : Type v) ‚âÖ F.cones.obj (op W) :=
  (limit.isLimit F).homIso W

@[simp]
theorem limit.hom_iso_hom (F : J ‚•§ C) [HasLimit F] {W : C} (f : ULift (W ‚ü∂ limit F)) :
    (limit.homIso F W).Hom f = (const J).map f.down ‚â´ (Limit.cone F).œÄ :=
  (limit.isLimit F).hom_iso_hom f

/-- The isomorphism (in `Type`) between
morphisms from a specified object `W` to the limit object,
and an explicit componentwise description of cones with cone point `W`.
-/
def limit.homIso' (F : J ‚•§ C) [HasLimit F] (W : C) :
    ULift.{u‚ÇÅ} (W ‚ü∂ limit F : Type v) ‚âÖ { p : ‚àÄ j, W ‚ü∂ F.obj j // ‚àÄ {j j' : J} (f : j ‚ü∂ j'), p j ‚â´ F.map f = p j' } :=
  (limit.isLimit F).homIso' W

theorem limit.lift_extend {F : J ‚•§ C} [HasLimit F] (c : Cone F) {X : C} (f : X ‚ü∂ c.x) :
    limit.lift F (c.extend f) = f ‚â´ limit.lift F c := by
  run_tac
    obviously

/-- If a functor `F` has a limit, so does any naturally isomorphic functor.
-/
theorem has_limit_of_iso {F G : J ‚•§ C} [HasLimit F] (Œ± : F ‚âÖ G) : HasLimit G :=
  HasLimit.mk
    { Cone := (Cones.postcompose Œ±.Hom).obj (Limit.cone F),
      IsLimit :=
        { lift := fun s => limit.lift F ((Cones.postcompose Œ±.inv).obj s),
          fac' := fun s j => by
            rw [cones.postcompose_obj_œÄ, nat_trans.comp_app, limit.cone_œÄ, ‚Üê category.assoc, limit.lift_œÄ]
            simp ,
          uniq' := fun s m w => by
            apply limit.hom_ext
            intro j
            rw [limit.lift_œÄ, cones.postcompose_obj_œÄ, nat_trans.comp_app, ‚Üê nat_iso.app_inv, iso.eq_comp_inv]
            simpa using w j } }

/-- If a functor `G` has the same collection of cones as a functor `F`
which has a limit, then `G` also has a limit. -/
-- See the construction of limits from products and equalizers
-- for an example usage.
theorem HasLimit.of_cones_iso {J K : Type u‚ÇÅ} [Category.{v‚ÇÅ} J] [Category.{v‚ÇÇ} K] (F : J ‚•§ C) (G : K ‚•§ C)
    (h : F.cones ‚âÖ G.cones) [HasLimit F] : HasLimit G :=
  HasLimit.mk ‚ü®_, IsLimit.ofNatIso (IsLimit.natIso (limit.isLimit F) ‚â™‚â´ h)‚ü©

/-- The limits of `F : J ‚•§ C` and `G : J ‚•§ C` are isomorphic,
if the functors are naturally isomorphic.
-/
def HasLimit.isoOfNatIso {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (w : F ‚âÖ G) : limit F ‚âÖ limit G :=
  IsLimit.conePointsIsoOfNatIso (limit.isLimit F) (limit.isLimit G) w

@[simp, reassoc]
theorem HasLimit.iso_of_nat_iso_hom_œÄ {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (w : F ‚âÖ G) (j : J) :
    (HasLimit.isoOfNatIso w).Hom ‚â´ limit.œÄ G j = limit.œÄ F j ‚â´ w.Hom.app j :=
  IsLimit.cone_points_iso_of_nat_iso_hom_comp _ _ _ _

@[simp, reassoc]
theorem HasLimit.iso_of_nat_iso_inv_œÄ {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (w : F ‚âÖ G) (j : J) :
    (HasLimit.isoOfNatIso w).inv ‚â´ limit.œÄ F j = limit.œÄ G j ‚â´ w.inv.app j :=
  IsLimit.cone_points_iso_of_nat_iso_inv_comp _ _ _ _

@[simp, reassoc]
theorem HasLimit.lift_iso_of_nat_iso_hom {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (t : Cone F) (w : F ‚âÖ G) :
    limit.lift F t ‚â´ (HasLimit.isoOfNatIso w).Hom = limit.lift G ((Cones.postcompose w.Hom).obj _) :=
  IsLimit.lift_comp_cone_points_iso_of_nat_iso_hom _ _ _

@[simp, reassoc]
theorem HasLimit.lift_iso_of_nat_iso_inv {F G : J ‚•§ C} [HasLimit F] [HasLimit G] (t : Cone G) (w : F ‚âÖ G) :
    limit.lift G t ‚â´ (HasLimit.isoOfNatIso w).inv = limit.lift F ((Cones.postcompose w.inv).obj _) :=
  IsLimit.lift_comp_cone_points_iso_of_nat_iso_inv _ _ _

/-- The limits of `F : J ‚•§ C` and `G : K ‚•§ C` are isomorphic,
if there is an equivalence `e : J ‚âå K` making the triangle commute up to natural isomorphism.
-/
def HasLimit.isoOfEquivalence {F : J ‚•§ C} [HasLimit F] {G : K ‚•§ C} [HasLimit G] (e : J ‚âå K) (w : e.Functor ‚ãô G ‚âÖ F) :
    limit F ‚âÖ limit G :=
  IsLimit.conePointsIsoOfEquivalence (limit.isLimit F) (limit.isLimit G) e w

@[simp]
theorem HasLimit.iso_of_equivalence_hom_œÄ {F : J ‚•§ C} [HasLimit F] {G : K ‚•§ C} [HasLimit G] (e : J ‚âå K)
    (w : e.Functor ‚ãô G ‚âÖ F) (k : K) :
    (HasLimit.isoOfEquivalence e w).Hom ‚â´ limit.œÄ G k =
      limit.œÄ F (e.inverse.obj k) ‚â´ w.inv.app (e.inverse.obj k) ‚â´ G.map (e.counit.app k) :=
  by
  simp only [‚Üê has_limit.iso_of_equivalence, ‚Üê is_limit.cone_points_iso_of_equivalence_hom]
  dsimp'
  simp

@[simp]
theorem HasLimit.iso_of_equivalence_inv_œÄ {F : J ‚•§ C} [HasLimit F] {G : K ‚•§ C} [HasLimit G] (e : J ‚âå K)
    (w : e.Functor ‚ãô G ‚âÖ F) (j : J) :
    (HasLimit.isoOfEquivalence e w).inv ‚â´ limit.œÄ F j = limit.œÄ G (e.Functor.obj j) ‚â´ w.Hom.app j := by
  simp only [‚Üê has_limit.iso_of_equivalence, ‚Üê is_limit.cone_points_iso_of_equivalence_hom]
  dsimp'
  simp

section Pre

variable (F) [HasLimit F] (E : K ‚•§ J) [HasLimit (E ‚ãô F)]

/-- The canonical morphism from the limit of `F` to the limit of `E ‚ãô F`.
-/
def limit.pre : limit F ‚ü∂ limit (E ‚ãô F) :=
  limit.lift (E ‚ãô F) ((Limit.cone F).whisker E)

@[simp, reassoc]
theorem limit.pre_œÄ (k : K) : limit.pre F E ‚â´ limit.œÄ (E ‚ãô F) k = limit.œÄ F (E.obj k) := by
  erw [is_limit.fac]
  rfl

@[simp]
theorem limit.lift_pre (c : Cone F) : limit.lift F c ‚â´ limit.pre F E = limit.lift (E ‚ãô F) (c.whisker E) := by
  ext <;> simp

variable {L : Type u‚ÇÉ} [Category.{v‚ÇÉ} L]

variable (D : L ‚•§ K) [HasLimit (D ‚ãô E ‚ãô F)]

@[simp]
theorem limit.pre_pre : limit.pre F E ‚â´ limit.pre (E ‚ãô F) D = limit.pre F (D ‚ãô E) := by
  ext j <;> erw [assoc, limit.pre_œÄ, limit.pre_œÄ, limit.pre_œÄ] <;> rfl

variable {E F}

/-- -
If we have particular limit cones available for `E ‚ãô F` and for `F`,
we obtain a formula for `limit.pre F E`.
-/
theorem limit.pre_eq (s : LimitCone (E ‚ãô F)) (t : LimitCone F) :
    limit.pre F E = (limit.isoLimitCone t).Hom ‚â´ s.IsLimit.lift (t.Cone.whisker E) ‚â´ (limit.isoLimitCone s).inv := by
  tidy

end Pre

section Post

variable {D : Type u'} [Category.{v'} D]

variable (F) [HasLimit F] (G : C ‚•§ D) [HasLimit (F ‚ãô G)]

/-- The canonical morphism from `G` applied to the limit of `F` to the limit of `F ‚ãô G`.
-/
def limit.post : G.obj (limit F) ‚ü∂ limit (F ‚ãô G) :=
  limit.lift (F ‚ãô G) (G.mapCone (Limit.cone F))

@[simp, reassoc]
theorem limit.post_œÄ (j : J) : limit.post F G ‚â´ limit.œÄ (F ‚ãô G) j = G.map (limit.œÄ F j) := by
  erw [is_limit.fac]
  rfl

@[simp]
theorem limit.lift_post (c : Cone F) : G.map (limit.lift F c) ‚â´ limit.post F G = limit.lift (F ‚ãô G) (G.mapCone c) := by
  ext
  rw [assoc, limit.post_œÄ, ‚Üê G.map_comp, limit.lift_œÄ, limit.lift_œÄ]
  rfl

@[simp]
theorem limit.post_post {E : Type u''} [Category.{v''} E] (H : D ‚•§ E)
    [HasLimit ((F ‚ãô G) ‚ãô H)] :-- H G (limit F) ‚ü∂ H (limit (F ‚ãô G)) ‚ü∂ limit ((F ‚ãô G) ‚ãô H) equals 
            -- H G (limit F) ‚ü∂ limit (F ‚ãô (G ‚ãô H))
            H.map
          (limit.post F G) ‚â´
        limit.post (F ‚ãô G) H =
      limit.post F (G ‚ãô H) :=
  by
  ext <;> erw [assoc, limit.post_œÄ, ‚Üê H.map_comp, limit.post_œÄ, limit.post_œÄ] <;> rfl

end Post

theorem limit.pre_post {D : Type u'} [Category.{v'} D] (E : K ‚•§ J) (F : J ‚•§ C) (G : C ‚•§ D) [HasLimit F]
    [HasLimit (E ‚ãô F)] [HasLimit (F ‚ãô G)]
    [HasLimit ((E ‚ãô F) ‚ãô G)] :-- G (limit F) ‚ü∂ G (limit (E ‚ãô F)) ‚ü∂ limit ((E ‚ãô F) ‚ãô G) vs 
            -- G (limit F) ‚ü∂ limit F ‚ãô G ‚ü∂ limit (E ‚ãô (F ‚ãô G)) or
            G.map
          (limit.pre F E) ‚â´
        limit.post (E ‚ãô F) G =
      limit.post F G ‚â´ limit.pre (F ‚ãô G) E :=
  by
  ext <;> erw [assoc, limit.post_œÄ, ‚Üê G.map_comp, limit.pre_œÄ, assoc, limit.pre_œÄ, limit.post_œÄ] <;> rfl

open CategoryTheory.Equivalence

instance has_limit_equivalence_comp (e : K ‚âå J) [HasLimit F] : HasLimit (e.Functor ‚ãô F) :=
  HasLimit.mk
    { Cone := Cone.whisker e.Functor (Limit.cone F), IsLimit := IsLimit.whiskerEquivalence (limit.isLimit F) e }

attribute [local elabWithoutExpectedType] inv_fun_id_assoc

/-- If a `E ‚ãô F` has a limit, and `E` is an equivalence, we can construct a limit of `F`.
-/
-- not entirely sure why this is needed
theorem has_limit_of_equivalence_comp (e : K ‚âå J) [HasLimit (e.Functor ‚ãô F)] : HasLimit F := by
  have : has_limit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_limit_equivalence_comp e.symm
  apply has_limit_of_iso (e.inv_fun_id_assoc F)

-- `has_limit_comp_equivalence` and `has_limit_of_comp_equivalence`
-- are proved in `category_theory/adjunction/limits.lean`.
section LimFunctor

variable [HasLimitsOfShape J C]

section

/-- `limit F` is functorial in `F`, when `C` has all limits of shape `J`. -/
@[simps obj]
def lim : (J ‚•§ C) ‚•§ C where
  obj := fun F => limit F
  map := fun F G Œ± => limMap Œ±
  map_id' := fun F => by
    ext
    erw [lim_map_œÄ, category.id_comp, category.comp_id]
  map_comp' := fun F G H Œ± Œ≤ => by
    ext <;> erw [assoc, is_limit.fac, is_limit.fac, ‚Üê assoc, is_limit.fac, assoc] <;> rfl

end

variable {F} {G : J ‚•§ C} (Œ± : F ‚ü∂ G)

-- We generate this manually since `simps` gives it a weird name.
@[simp]
theorem lim_map_eq_lim_map : lim.map Œ± = limMap Œ± :=
  rfl

theorem limit.map_pre [HasLimitsOfShape K C] (E : K ‚•§ J) :
    lim.map Œ± ‚â´ limit.pre G E = limit.pre F E ‚â´ lim.map (whiskerLeft E Œ±) := by
  ext
  simp

theorem limit.map_pre' [HasLimitsOfShape K C] (F : J ‚•§ C) {E‚ÇÅ E‚ÇÇ : K ‚•§ J} (Œ± : E‚ÇÅ ‚ü∂ E‚ÇÇ) :
    limit.pre F E‚ÇÇ = limit.pre F E‚ÇÅ ‚â´ lim.map (whiskerRight Œ± F) := by
  ext1 <;> simp [category.assoc]

theorem limit.id_pre (F : J ‚•§ C) : limit.pre F (ùü≠ _) = lim.map (Functor.leftUnitor F).inv := by
  tidy

theorem limit.map_post {D : Type u'} [Category.{v'} D] [HasLimitsOfShape J D]
    (H : C ‚•§ D) :/- H (limit F) ‚ü∂ H (limit G) ‚ü∂ limit (G ‚ãô H) vs
               H (limit F) ‚ü∂ limit (F ‚ãô H) ‚ü∂ limit (G ‚ãô H) -/
            H.map
          (limMap Œ±) ‚â´
        limit.post G H =
      limit.post F H ‚â´ limMap (whiskerRight Œ± H) :=
  by
  ext
  simp only [‚Üê whisker_right_app, ‚Üê lim_map_œÄ, ‚Üê assoc, ‚Üê limit.post_œÄ_assoc, ‚Üê limit.post_œÄ, H.map_comp]

/-- The isomorphism between
morphisms from `W` to the cone point of the limit cone for `F`
and cones over `F` with cone point `W`
is natural in `F`.
-/
def limYoneda : lim ‚ãô yoneda ‚ãô (whiskeringRight _ _ _).obj uliftFunctor.{u‚ÇÅ} ‚âÖ CategoryTheory.cones J C :=
  NatIso.ofComponents
    (fun F =>
      NatIso.ofComponents (fun W => limit.homIso F (unop W))
        (by
          tidy))
    (by
      tidy)

end LimFunctor

/-- We can transport limits of shape `J` along an equivalence `J ‚âå J'`.
-/
theorem has_limits_of_shape_of_equivalence {J' : Type u‚ÇÇ} [Category.{v‚ÇÇ} J'] (e : J ‚âå J') [HasLimitsOfShape J C] :
    HasLimitsOfShape J' C := by
  constructor
  intro F
  apply has_limit_of_equivalence_comp e
  infer_instance

variable (C)

/-- `has_limits_of_size_shrink.{v u} C` tries to obtain `has_limits_of_size.{v u} C`
from some other `has_limits_of_size C`.
-/
theorem has_limits_of_size_shrink [HasLimitsOfSize.{max v‚ÇÅ v‚ÇÇ, max u‚ÇÅ u‚ÇÇ} C] : HasLimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C :=
  ‚ü®fun J hJ => has_limits_of_shape_of_equivalence (UliftHomUliftCategory.equiv.{v‚ÇÇ, u‚ÇÇ} J).symm‚ü©

instance (priority := 100) has_smallest_limits_of_has_limits [HasLimits C] : HasLimitsOfSize.{0, 0} C :=
  has_limits_of_size_shrink.{0, 0} C

end Limit

section Colimit

/-- `colimit_cocone F` contains a cocone over `F` together with the information that it is a
    colimit. -/
@[nolint has_inhabited_instance]
structure ColimitCocone (F : J ‚•§ C) where
  Cocone : Cocone F
  IsColimit : IsColimit cocone

/-- `has_colimit F` represents the mere existence of a colimit for `F`. -/
class HasColimit (F : J ‚•§ C) : Prop where mk' ::
  exists_colimit : Nonempty (ColimitCocone F)

theorem HasColimit.mk {F : J ‚•§ C} (d : ColimitCocone F) : HasColimit F :=
  ‚ü®Nonempty.intro d‚ü©

/-- Use the axiom of choice to extract explicit `colimit_cocone F` from `has_colimit F`. -/
def getColimitCocone (F : J ‚•§ C) [HasColimit F] : ColimitCocone F :=
  Classical.choice <| has_colimit.exists_colimit

variable (J C)

/-- `C` has colimits of shape `J` if there exists a colimit for every functor `F : J ‚•§ C`. -/
class HasColimitsOfShape : Prop where
  HasColimit : ‚àÄ F : J ‚•§ C, HasColimit F := by
    run_tac
      tactic.apply_instance

/-- `C` has all colimits of size `v‚ÇÅ u‚ÇÅ` (`has_colimits_of_size.{v‚ÇÅ u‚ÇÅ} C`)
if it has colimits of every shape `J : Type u‚ÇÅ` with `[category.{v‚ÇÅ} J]`.
-/
class HasColimitsOfSize (C : Type u) [Category.{v} C] : Prop where
  HasColimitsOfShape : ‚àÄ (J : Type u‚ÇÅ) [ùí• : Category.{v‚ÇÅ} J], HasColimitsOfShape J C := by
    run_tac
      tactic.apply_instance

/-- `C` has all (small) colimits if it has colimits of every shape that is as big as its hom-sets.
-/
abbrev HasColimits (C : Type u) [Category.{v} C] : Prop :=
  HasColimitsOfSize.{v, v} C

theorem HasColimits.has_colimits_of_shape {C : Type u} [Category.{v} C] [HasColimits C] (J : Type v) [Category.{v} J] :
    HasColimitsOfShape J C :=
  HasColimitsOfSize.has_colimits_of_shape J

variable {J C}

-- see Note [lower instance priority]
instance (priority := 100) has_colimit_of_has_colimits_of_shape {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
    [H : HasColimitsOfShape J C] (F : J ‚•§ C) : HasColimit F :=
  HasColimitsOfShape.has_colimit F

-- see Note [lower instance priority]
instance (priority := 100) has_colimits_of_shape_of_has_colimits_of_size {J : Type u‚ÇÅ} [Category.{v‚ÇÅ} J]
    [H : HasColimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C] : HasColimitsOfShape J C :=
  HasColimitsOfSize.has_colimits_of_shape J

/-- An arbitrary choice of colimit cocone of a functor. -/
-- Interface to the `has_colimit` class.
def Colimit.cocone (F : J ‚•§ C) [HasColimit F] : Cocone F :=
  (getColimitCocone F).Cocone

/-- An arbitrary choice of colimit object of a functor. -/
def colimit (F : J ‚•§ C) [HasColimit F] :=
  (Colimit.cocone F).x

/-- The coprojection from a value of the functor to the colimit object. -/
def colimit.Œπ (F : J ‚•§ C) [HasColimit F] (j : J) : F.obj j ‚ü∂ colimit F :=
  (Colimit.cocone F).Œπ.app j

@[simp]
theorem colimit.cocone_Œπ {F : J ‚•§ C} [HasColimit F] (j : J) : (Colimit.cocone F).Œπ.app j = colimit.Œπ _ j :=
  rfl

@[simp]
theorem colimit.cocone_X {F : J ‚•§ C} [HasColimit F] : (Colimit.cocone F).x = colimit F :=
  rfl

@[simp, reassoc]
theorem colimit.w (F : J ‚•§ C) [HasColimit F] {j j' : J} (f : j ‚ü∂ j') : F.map f ‚â´ colimit.Œπ F j' = colimit.Œπ F j :=
  (Colimit.cocone F).w f

/-- Evidence that the arbitrary choice of cocone is a colimit cocone. -/
def colimit.isColimit (F : J ‚•§ C) [HasColimit F] : IsColimit (Colimit.cocone F) :=
  (getColimitCocone F).IsColimit

/-- The morphism from the colimit object to the cone point of any other cocone. -/
def colimit.desc (F : J ‚•§ C) [HasColimit F] (c : Cocone F) : colimit F ‚ü∂ c.x :=
  (colimit.isColimit F).desc c

@[simp]
theorem colimit.is_colimit_desc {F : J ‚•§ C} [HasColimit F] (c : Cocone F) :
    (colimit.isColimit F).desc c = colimit.desc F c :=
  rfl

/-- We have lots of lemmas describing how to simplify `colimit.Œπ F j ‚â´ _`,
and combined with `colimit.ext` we rely on these lemmas for many calculations.

However, since `category.assoc` is a `@[simp]` lemma, often expressions are
right associated, and it's hard to apply these lemmas about `colimit.Œπ`.

We thus use `reassoc` to define additional `@[simp]` lemmas, with an arbitrary extra morphism.
(see `tactic/reassoc_axiom.lean`)
 -/
@[simp, reassoc]
theorem colimit.Œπ_desc {F : J ‚•§ C} [HasColimit F] (c : Cocone F) (j : J) :
    colimit.Œπ F j ‚â´ colimit.desc F c = c.Œπ.app j :=
  IsColimit.fac _ c j

/-- Functoriality of colimits.

Usually this morphism should be accessed through `colim.map`,
but may be needed separately when you have specified colimits for the source and target functors,
but not necessarily for all functors of shape `J`.
-/
def colimMap {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (Œ± : F ‚ü∂ G) : colimit F ‚ü∂ colimit G :=
  IsColimit.map (colimit.isColimit F) _ Œ±

@[simp, reassoc]
theorem Œπ_colim_map {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (Œ± : F ‚ü∂ G) (j : J) :
    colimit.Œπ F j ‚â´ colimMap Œ± = Œ±.app j ‚â´ colimit.Œπ G j :=
  colimit.Œπ_desc _ j

/-- The cocone morphism from the arbitrary choice of colimit cocone to any cocone. -/
def colimit.coconeMorphism {F : J ‚•§ C} [HasColimit F] (c : Cocone F) : Colimit.cocone F ‚ü∂ c :=
  (colimit.isColimit F).descCoconeMorphism c

@[simp]
theorem colimit.cocone_morphism_hom {F : J ‚•§ C} [HasColimit F] (c : Cocone F) :
    (colimit.coconeMorphism c).Hom = colimit.desc F c :=
  rfl

theorem colimit.Œπ_cocone_morphism {F : J ‚•§ C} [HasColimit F] (c : Cocone F) (j : J) :
    colimit.Œπ F j ‚â´ (colimit.coconeMorphism c).Hom = c.Œπ.app j := by
  simp

@[simp, reassoc]
theorem colimit.comp_cocone_point_unique_up_to_iso_hom {F : J ‚•§ C} [HasColimit F] {c : Cocone F} (hc : IsColimit c)
    (j : J) : colimit.Œπ F j ‚â´ (IsColimit.coconePointUniqueUpToIso (colimit.isColimit _) hc).Hom = c.Œπ.app j :=
  IsColimit.comp_cocone_point_unique_up_to_iso_hom _ _ _

@[simp, reassoc]
theorem colimit.comp_cocone_point_unique_up_to_iso_inv {F : J ‚•§ C} [HasColimit F] {c : Cocone F} (hc : IsColimit c)
    (j : J) : colimit.Œπ F j ‚â´ (IsColimit.coconePointUniqueUpToIso hc (colimit.isColimit _)).inv = c.Œπ.app j :=
  IsColimit.comp_cocone_point_unique_up_to_iso_inv _ _ _

theorem colimit.exists_unique {F : J ‚•§ C} [HasColimit F] (t : Cocone F) :
    ‚àÉ! d : colimit F ‚ü∂ t.x, ‚àÄ j, colimit.Œπ F j ‚â´ d = t.Œπ.app j :=
  (colimit.isColimit F).ExistsUnique _

/-- Given any other colimit cocone for `F`, the chosen `colimit F` is isomorphic to the cocone point.
-/
def colimit.isoColimitCocone {F : J ‚•§ C} [HasColimit F] (t : ColimitCocone F) : colimit F ‚âÖ t.Cocone.x :=
  IsColimit.coconePointUniqueUpToIso (colimit.isColimit F) t.IsColimit

@[simp, reassoc]
theorem colimit.iso_colimit_cocone_Œπ_hom {F : J ‚•§ C} [HasColimit F] (t : ColimitCocone F) (j : J) :
    colimit.Œπ F j ‚â´ (colimit.isoColimitCocone t).Hom = t.Cocone.Œπ.app j := by
  dsimp' [‚Üê colimit.iso_colimit_cocone, ‚Üê is_colimit.cocone_point_unique_up_to_iso]
  tidy

@[simp, reassoc]
theorem colimit.iso_colimit_cocone_Œπ_inv {F : J ‚•§ C} [HasColimit F] (t : ColimitCocone F) (j : J) :
    t.Cocone.Œπ.app j ‚â´ (colimit.isoColimitCocone t).inv = colimit.Œπ F j := by
  dsimp' [‚Üê colimit.iso_colimit_cocone, ‚Üê is_colimit.cocone_point_unique_up_to_iso]
  tidy

@[ext]
theorem colimit.hom_ext {F : J ‚•§ C} [HasColimit F] {X : C} {f f' : colimit F ‚ü∂ X}
    (w : ‚àÄ j, colimit.Œπ F j ‚â´ f = colimit.Œπ F j ‚â´ f') : f = f' :=
  (colimit.isColimit F).hom_ext w

@[simp]
theorem colimit.desc_cocone {F : J ‚•§ C} [HasColimit F] : colimit.desc F (Colimit.cocone F) = ùüô (colimit F) :=
  (colimit.isColimit _).desc_self

/-- The isomorphism (in `Type`) between
morphisms from the colimit object to a specified object `W`,
and cocones with cone point `W`.
-/
def colimit.homIso (F : J ‚•§ C) [HasColimit F] (W : C) : ULift.{u‚ÇÅ} (colimit F ‚ü∂ W : Type v) ‚âÖ F.cocones.obj W :=
  (colimit.isColimit F).homIso W

@[simp]
theorem colimit.hom_iso_hom (F : J ‚•§ C) [HasColimit F] {W : C} (f : ULift (colimit F ‚ü∂ W)) :
    (colimit.homIso F W).Hom f = (Colimit.cocone F).Œπ ‚â´ (const J).map f.down :=
  (colimit.isColimit F).hom_iso_hom f

/-- The isomorphism (in `Type`) between
morphisms from the colimit object to a specified object `W`,
and an explicit componentwise description of cocones with cone point `W`.
-/
def colimit.homIso' (F : J ‚•§ C) [HasColimit F] (W : C) :
    ULift.{u‚ÇÅ} (colimit F ‚ü∂ W : Type v) ‚âÖ { p : ‚àÄ j, F.obj j ‚ü∂ W // ‚àÄ {j j'} (f : j ‚ü∂ j'), F.map f ‚â´ p j' = p j } :=
  (colimit.isColimit F).homIso' W

theorem colimit.desc_extend (F : J ‚•§ C) [HasColimit F] (c : Cocone F) {X : C} (f : c.x ‚ü∂ X) :
    colimit.desc F (c.extend f) = colimit.desc F c ‚â´ f := by
  ext1
  rw [‚Üê category.assoc]
  simp

/-- If `F` has a colimit, so does any naturally isomorphic functor.
-/
-- This has the isomorphism pointing in the opposite direction than in `has_limit_of_iso`.
-- This is intentional; it seems to help with elaboration.
theorem has_colimit_of_iso {F G : J ‚•§ C} [HasColimit F] (Œ± : G ‚âÖ F) : HasColimit G :=
  HasColimit.mk
    { Cocone := (Cocones.precompose Œ±.Hom).obj (Colimit.cocone F),
      IsColimit :=
        { desc := fun s => colimit.desc F ((Cocones.precompose Œ±.inv).obj s),
          fac' := fun s j => by
            rw [cocones.precompose_obj_Œπ, nat_trans.comp_app, colimit.cocone_Œπ]
            rw [category.assoc, colimit.Œπ_desc, ‚Üê nat_iso.app_hom, ‚Üê iso.eq_inv_comp]
            rfl,
          uniq' := fun s m w => by
            apply colimit.hom_ext
            intro j
            rw [colimit.Œπ_desc, cocones.precompose_obj_Œπ, nat_trans.comp_app, ‚Üê nat_iso.app_inv, iso.eq_inv_comp]
            simpa using w j } }

/-- If a functor `G` has the same collection of cocones as a functor `F`
which has a colimit, then `G` also has a colimit. -/
theorem HasColimit.of_cocones_iso {K : Type u‚ÇÅ} [Category.{v‚ÇÇ} K] (F : J ‚•§ C) (G : K ‚•§ C) (h : F.cocones ‚âÖ G.cocones)
    [HasColimit F] : HasColimit G :=
  HasColimit.mk ‚ü®_, IsColimit.ofNatIso (IsColimit.natIso (colimit.isColimit F) ‚â™‚â´ h)‚ü©

/-- The colimits of `F : J ‚•§ C` and `G : J ‚•§ C` are isomorphic,
if the functors are naturally isomorphic.
-/
def HasColimit.isoOfNatIso {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (w : F ‚âÖ G) : colimit F ‚âÖ colimit G :=
  IsColimit.coconePointsIsoOfNatIso (colimit.isColimit F) (colimit.isColimit G) w

@[simp, reassoc]
theorem HasColimit.iso_of_nat_iso_Œπ_hom {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (w : F ‚âÖ G) (j : J) :
    colimit.Œπ F j ‚â´ (HasColimit.isoOfNatIso w).Hom = w.Hom.app j ‚â´ colimit.Œπ G j :=
  IsColimit.comp_cocone_points_iso_of_nat_iso_hom _ _ _ _

@[simp, reassoc]
theorem HasColimit.iso_of_nat_iso_Œπ_inv {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (w : F ‚âÖ G) (j : J) :
    colimit.Œπ G j ‚â´ (HasColimit.isoOfNatIso w).inv = w.inv.app j ‚â´ colimit.Œπ F j :=
  IsColimit.comp_cocone_points_iso_of_nat_iso_inv _ _ _ _

@[simp, reassoc]
theorem HasColimit.iso_of_nat_iso_hom_desc {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (t : Cocone G) (w : F ‚âÖ G) :
    (HasColimit.isoOfNatIso w).Hom ‚â´ colimit.desc G t = colimit.desc F ((Cocones.precompose w.Hom).obj _) :=
  IsColimit.cocone_points_iso_of_nat_iso_hom_desc _ _ _

@[simp, reassoc]
theorem HasColimit.iso_of_nat_iso_inv_desc {F G : J ‚•§ C} [HasColimit F] [HasColimit G] (t : Cocone F) (w : F ‚âÖ G) :
    (HasColimit.isoOfNatIso w).inv ‚â´ colimit.desc F t = colimit.desc G ((Cocones.precompose w.inv).obj _) :=
  IsColimit.cocone_points_iso_of_nat_iso_inv_desc _ _ _

/-- The colimits of `F : J ‚•§ C` and `G : K ‚•§ C` are isomorphic,
if there is an equivalence `e : J ‚âå K` making the triangle commute up to natural isomorphism.
-/
def HasColimit.isoOfEquivalence {F : J ‚•§ C} [HasColimit F] {G : K ‚•§ C} [HasColimit G] (e : J ‚âå K)
    (w : e.Functor ‚ãô G ‚âÖ F) : colimit F ‚âÖ colimit G :=
  IsColimit.coconePointsIsoOfEquivalence (colimit.isColimit F) (colimit.isColimit G) e w

@[simp]
theorem HasColimit.iso_of_equivalence_hom_œÄ {F : J ‚•§ C} [HasColimit F] {G : K ‚•§ C} [HasColimit G] (e : J ‚âå K)
    (w : e.Functor ‚ãô G ‚âÖ F) (j : J) :
    colimit.Œπ F j ‚â´ (HasColimit.isoOfEquivalence e w).Hom = F.map (e.Unit.app j) ‚â´ w.inv.app _ ‚â´ colimit.Œπ G _ := by
  simp [‚Üê has_colimit.iso_of_equivalence, ‚Üê is_colimit.cocone_points_iso_of_equivalence_inv]
  dsimp'
  simp

@[simp]
theorem HasColimit.iso_of_equivalence_inv_œÄ {F : J ‚•§ C} [HasColimit F] {G : K ‚•§ C} [HasColimit G] (e : J ‚âå K)
    (w : e.Functor ‚ãô G ‚âÖ F) (k : K) :
    colimit.Œπ G k ‚â´ (HasColimit.isoOfEquivalence e w).inv =
      G.map (e.counitInv.app k) ‚â´ w.Hom.app (e.inverse.obj k) ‚â´ colimit.Œπ F (e.inverse.obj k) :=
  by
  simp [‚Üê has_colimit.iso_of_equivalence, ‚Üê is_colimit.cocone_points_iso_of_equivalence_inv]
  dsimp'
  simp

section Pre

variable (F) [HasColimit F] (E : K ‚•§ J) [HasColimit (E ‚ãô F)]

/-- The canonical morphism from the colimit of `E ‚ãô F` to the colimit of `F`.
-/
def colimit.pre : colimit (E ‚ãô F) ‚ü∂ colimit F :=
  colimit.desc (E ‚ãô F) ((Colimit.cocone F).whisker E)

@[simp, reassoc]
theorem colimit.Œπ_pre (k : K) : colimit.Œπ (E ‚ãô F) k ‚â´ colimit.pre F E = colimit.Œπ F (E.obj k) := by
  erw [is_colimit.fac]
  rfl

@[simp, reassoc]
theorem colimit.pre_desc (c : Cocone F) : colimit.pre F E ‚â´ colimit.desc F c = colimit.desc (E ‚ãô F) (c.whisker E) := by
  ext <;> rw [‚Üê assoc, colimit.Œπ_pre] <;> simp

variable {L : Type u‚ÇÉ} [Category.{v‚ÇÉ} L]

variable (D : L ‚•§ K) [HasColimit (D ‚ãô E ‚ãô F)]

@[simp]
theorem colimit.pre_pre : colimit.pre (E ‚ãô F) D ‚â´ colimit.pre F E = colimit.pre F (D ‚ãô E) := by
  ext j
  rw [‚Üê assoc, colimit.Œπ_pre, colimit.Œπ_pre]
  let this : has_colimit ((D ‚ãô E) ‚ãô F) :=
    show has_colimit (D ‚ãô E ‚ãô F) by
      infer_instance
  exact (colimit.Œπ_pre F (D ‚ãô E) j).symm

variable {E F}

/-- -
If we have particular colimit cocones available for `E ‚ãô F` and for `F`,
we obtain a formula for `colimit.pre F E`.
-/
theorem colimit.pre_eq (s : ColimitCocone (E ‚ãô F)) (t : ColimitCocone F) :
    colimit.pre F E =
      (colimit.isoColimitCocone s).Hom ‚â´ s.IsColimit.desc (t.Cocone.whisker E) ‚â´ (colimit.isoColimitCocone t).inv :=
  by
  tidy

end Pre

section Post

variable {D : Type u'} [Category.{v'} D]

variable (F) [HasColimit F] (G : C ‚•§ D) [HasColimit (F ‚ãô G)]

/-- The canonical morphism from `G` applied to the colimit of `F ‚ãô G`
to `G` applied to the colimit of `F`.
-/
def colimit.post : colimit (F ‚ãô G) ‚ü∂ G.obj (colimit F) :=
  colimit.desc (F ‚ãô G) (G.mapCocone (Colimit.cocone F))

@[simp, reassoc]
theorem colimit.Œπ_post (j : J) : colimit.Œπ (F ‚ãô G) j ‚â´ colimit.post F G = G.map (colimit.Œπ F j) := by
  erw [is_colimit.fac]
  rfl

@[simp]
theorem colimit.post_desc (c : Cocone F) :
    colimit.post F G ‚â´ G.map (colimit.desc F c) = colimit.desc (F ‚ãô G) (G.mapCocone c) := by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê G.map_comp, colimit.Œπ_desc, colimit.Œπ_desc]
  rfl

@[simp]
theorem colimit.post_post {E : Type u''} [Category.{v''} E] (H : D ‚•§ E)
    [HasColimit ((F ‚ãô G) ‚ãô H)] :-- H G (colimit F) ‚ü∂ H (colimit (F ‚ãô G)) ‚ü∂ colimit ((F ‚ãô G) ‚ãô H) equals 
          -- H G (colimit F) ‚ü∂ colimit (F ‚ãô (G ‚ãô H))
          colimit.post
          (F ‚ãô G) H ‚â´
        H.map (colimit.post F G) =
      colimit.post F (G ‚ãô H) :=
  by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê H.map_comp, colimit.Œπ_post]
  exact (colimit.Œπ_post F (G ‚ãô H) j).symm

end Post

theorem colimit.pre_post {D : Type u'} [Category.{v'} D] (E : K ‚•§ J) (F : J ‚•§ C) (G : C ‚•§ D) [HasColimit F]
    [HasColimit (E ‚ãô F)] [HasColimit (F ‚ãô G)]
    [H : HasColimit ((E ‚ãô F) ‚ãô G)] :-- G (colimit F) ‚ü∂ G (colimit (E ‚ãô F)) ‚ü∂ colimit ((E ‚ãô F) ‚ãô G) vs 
          -- G (colimit F) ‚ü∂ colimit F ‚ãô G ‚ü∂ colimit (E ‚ãô (F ‚ãô G)) or
          colimit.post
          (E ‚ãô F) G ‚â´
        G.map (colimit.pre F E) =
      (@colimit.pre _ _ _ (F ‚ãô G) _ E H ‚â´ colimit.post F G : _) :=
  by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê G.map_comp, colimit.Œπ_pre, ‚Üê assoc]
  let this : has_colimit (E ‚ãô F ‚ãô G) :=
    show has_colimit ((E ‚ãô F) ‚ãô G) by
      infer_instance
  erw [colimit.Œπ_pre (F ‚ãô G) E j, colimit.Œπ_post]

open CategoryTheory.Equivalence

instance has_colimit_equivalence_comp (e : K ‚âå J) [HasColimit F] : HasColimit (e.Functor ‚ãô F) :=
  HasColimit.mk
    { Cocone := Cocone.whisker e.Functor (Colimit.cocone F),
      IsColimit := IsColimit.whiskerEquivalence (colimit.isColimit F) e }

/-- If a `E ‚ãô F` has a colimit, and `E` is an equivalence, we can construct a colimit of `F`.
-/
theorem has_colimit_of_equivalence_comp (e : K ‚âå J) [HasColimit (e.Functor ‚ãô F)] : HasColimit F := by
  have : has_colimit (e.inverse ‚ãô e.functor ‚ãô F) := limits.has_colimit_equivalence_comp e.symm
  apply has_colimit_of_iso (e.inv_fun_id_assoc F).symm

section ColimFunctor

variable [HasColimitsOfShape J C]

section

attribute [local simp] colim_map

/-- `colimit F` is functorial in `F`, when `C` has all colimits of shape `J`. -/
@[simps obj]
def colim : (J ‚•§ C) ‚•§ C where
  obj := fun F => colimit F
  map := fun F G Œ± => colimMap Œ±
  map_id' := fun F => by
    ext
    erw [Œπ_colim_map, id_comp, comp_id]
  map_comp' := fun F G H Œ± Œ≤ => by
    ext
    erw [‚Üê assoc, is_colimit.fac, is_colimit.fac, assoc, is_colimit.fac, ‚Üê assoc]
    rfl

end

variable {F} {G : J ‚•§ C} (Œ± : F ‚ü∂ G)

@[simp, reassoc]
theorem colimit.Œπ_map (j : J) : colimit.Œπ F j ‚â´ colim.map Œ± = Œ±.app j ‚â´ colimit.Œπ G j := by
  apply is_colimit.fac

@[simp]
theorem colimit.map_desc (c : Cocone G) :
    colim.map Œ± ‚â´ colimit.desc G c = colimit.desc F ((Cocones.precompose Œ±).obj c) := by
  ext <;> rw [‚Üê assoc, colimit.Œπ_map, assoc, colimit.Œπ_desc, colimit.Œπ_desc] <;> rfl

theorem colimit.pre_map [HasColimitsOfShape K C] (E : K ‚•§ J) :
    colimit.pre F E ‚â´ colim.map Œ± = colim.map (whiskerLeft E Œ±) ‚â´ colimit.pre G E := by
  ext <;> rw [‚Üê assoc, colimit.Œπ_pre, colimit.Œπ_map, ‚Üê assoc, colimit.Œπ_map, assoc, colimit.Œπ_pre] <;> rfl

theorem colimit.pre_map' [HasColimitsOfShape K C] (F : J ‚•§ C) {E‚ÇÅ E‚ÇÇ : K ‚•§ J} (Œ± : E‚ÇÅ ‚ü∂ E‚ÇÇ) :
    colimit.pre F E‚ÇÅ = colim.map (whiskerRight Œ± F) ‚â´ colimit.pre F E‚ÇÇ := by
  ext1 <;> simp [category.assoc]

theorem colimit.pre_id (F : J ‚•§ C) : colimit.pre F (ùü≠ _) = colim.map (Functor.leftUnitor F).Hom := by
  tidy

theorem colimit.map_post {D : Type u'} [Category.{v'} D] [HasColimitsOfShape J D]
    (H : C ‚•§ D) :/- H (colimit F) ‚ü∂ H (colimit G) ‚ü∂ colimit (G ‚ãô H) vs
             H (colimit F) ‚ü∂ colimit (F ‚ãô H) ‚ü∂ colimit (G ‚ãô H) -/
          colimit.post
          F H ‚â´
        H.map (colim.map Œ±) =
      colim.map (whiskerRight Œ± H) ‚â´ colimit.post G H :=
  by
  ext
  rw [‚Üê assoc, colimit.Œπ_post, ‚Üê H.map_comp, colimit.Œπ_map, H.map_comp]
  rw [‚Üê assoc, colimit.Œπ_map, assoc, colimit.Œπ_post]
  rfl

/-- The isomorphism between
morphisms from the cone point of the colimit cocone for `F` to `W`
and cocones over `F` with cone point `W`
is natural in `F`.
-/
def colimCoyoneda : colim.op ‚ãô coyoneda ‚ãô (whiskeringRight _ _ _).obj uliftFunctor.{u‚ÇÅ} ‚âÖ CategoryTheory.cocones J C :=
  NatIso.ofComponents
    (fun F =>
      NatIso.ofComponents (colimit.homIso (unop F))
        (by
          tidy))
    (by
      tidy)

end ColimFunctor

/-- We can transport colimits of shape `J` along an equivalence `J ‚âå J'`.
-/
theorem has_colimits_of_shape_of_equivalence {J' : Type u‚ÇÇ} [Category.{v‚ÇÇ} J'] (e : J ‚âå J') [HasColimitsOfShape J C] :
    HasColimitsOfShape J' C := by
  constructor
  intro F
  apply has_colimit_of_equivalence_comp e
  infer_instance

variable (C)

/-- `has_colimits_of_size_shrink.{v u} C` tries to obtain `has_colimits_of_size.{v u} C`
from some other `has_colimits_of_size C`.
-/
theorem has_colimits_of_size_shrink [HasColimitsOfSize.{max v‚ÇÅ v‚ÇÇ, max u‚ÇÅ u‚ÇÇ} C] : HasColimitsOfSize.{v‚ÇÅ, u‚ÇÅ} C :=
  ‚ü®fun J hJ => has_colimits_of_shape_of_equivalence (UliftHomUliftCategory.equiv.{v‚ÇÇ, u‚ÇÇ} J).symm‚ü©

instance (priority := 100) has_smallest_colimits_of_has_colimits [HasColimits C] : HasColimitsOfSize.{0, 0} C :=
  has_colimits_of_size_shrink.{0, 0} C

end Colimit

section Opposite

/-- If `t : cone F` is a limit cone, then `t.op : cocone F.op` is a colimit cocone.
-/
def IsLimit.op {t : Cone F} (P : IsLimit t) : IsColimit t.op where
  desc := fun s => (P.lift s.unop).op
  fac' := fun s j => congr_arg Quiver.Hom.op (P.fac s.unop (unop j))
  uniq' := fun s m w => by
    rw [‚Üê P.uniq s.unop m.unop]
    ¬∑ rfl
      
    ¬∑ dsimp'
      intro j
      rw [‚Üê w]
      rfl
      

/-- If `t : cocone F` is a colimit cocone, then `t.op : cone F.op` is a limit cone.
-/
def IsColimit.op {t : Cocone F} (P : IsColimit t) : IsLimit t.op where
  lift := fun s => (P.desc s.unop).op
  fac' := fun s j => congr_arg Quiver.Hom.op (P.fac s.unop (unop j))
  uniq' := fun s m w => by
    rw [‚Üê P.uniq s.unop m.unop]
    ¬∑ rfl
      
    ¬∑ dsimp'
      intro j
      rw [‚Üê w]
      rfl
      

/-- If `t : cone F.op` is a limit cone, then `t.unop : cocone F` is a colimit cocone.
-/
def IsLimit.unop {t : Cone F.op} (P : IsLimit t) : IsColimit t.unop where
  desc := fun s => (P.lift s.op).unop
  fac' := fun s j => congr_arg Quiver.Hom.unop (P.fac s.op (op j))
  uniq' := fun s m w => by
    rw [‚Üê P.uniq s.op m.op]
    ¬∑ rfl
      
    ¬∑ dsimp'
      intro j
      rw [‚Üê w]
      rfl
      

/-- If `t : cocone F.op` is a colimit cocone, then `t.unop : cone F.` is a limit cone.
-/
def IsColimit.unop {t : Cocone F.op} (P : IsColimit t) : IsLimit t.unop where
  lift := fun s => (P.desc s.op).unop
  fac' := fun s j => congr_arg Quiver.Hom.unop (P.fac s.op (op j))
  uniq' := fun s m w => by
    rw [‚Üê P.uniq s.op m.op]
    ¬∑ rfl
      
    ¬∑ dsimp'
      intro j
      rw [‚Üê w]
      rfl
      

/-- `t : cone F` is a limit cone if and only is `t.op : cocone F.op` is a colimit cocone.
-/
def isLimitEquivIsColimitOp {t : Cone F} : IsLimit t ‚âÉ IsColimit t.op :=
  equivOfSubsingletonOfSubsingleton IsLimit.op fun P =>
    P.unop.ofIsoLimit
      (Cones.ext (Iso.refl _)
        (by
          tidy))

/-- `t : cocone F` is a colimit cocone if and only is `t.op : cone F.op` is a limit cone.
-/
def isColimitEquivIsLimitOp {t : Cocone F} : IsColimit t ‚âÉ IsLimit t.op :=
  equivOfSubsingletonOfSubsingleton IsColimit.op fun P =>
    P.unop.ofIsoColimit
      (Cocones.ext (Iso.refl _)
        (by
          tidy))

end Opposite

end CategoryTheory.Limits

