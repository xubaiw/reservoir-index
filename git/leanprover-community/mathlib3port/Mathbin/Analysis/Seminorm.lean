/-
Copyright (c) 2019 Jean Lo. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jean Lo, Ya√´l Dillies, Moritz Doll
-/
import Mathbin.Analysis.LocallyConvex.Basic
import Mathbin.Data.Real.Pointwise
import Mathbin.Data.Real.Sqrt
import Mathbin.Topology.Algebra.FilterBasis
import Mathbin.Topology.Algebra.Module.LocallyConvex

/-!
# Seminorms

This file defines seminorms.

A seminorm is a function to the reals which is positive-semidefinite, absolutely homogeneous, and
subadditive. They are closely related to convex sets and a topological vector space is locally
convex if and only if its topology is induced by a family of seminorms.

## Main declarations

For an addditive group:
* `add_group_seminorm`: A function `f` from an add_group `G` to the reals that preserves zero,
takes nonnegative values, is subadditive and such that `f (-x) = f x` for all `x ‚àà G`.

For a module over a normed ring:
* `seminorm`: A function to the reals that is positive-semidefinite, absolutely homogeneous, and
  subadditive.
* `norm_seminorm ùïú E`: The norm on `E` as a seminorm.

## References

* [H. H. Schaefer, *Topological Vector Spaces*][schaefer1966]

## Tags

seminorm, locally convex, LCTVS
-/


open NormedField Set

open BigOperators Nnreal Pointwise TopologicalSpace

variable {R R' ùïú E F G Œπ : Type _}

/-- A seminorm on an add_group `G` is a function A function `f : G ‚Üí ‚Ñù` that preserves zero, takes
nonnegative values, is subadditive and such that `f (-x) = f x` for all `x ‚àà G`. -/
structure AddGroupSeminorm (G : Type _) [AddGroup‚Çì G] extends ZeroHom G ‚Ñù where
  nonneg' : ‚àÄ r, 0 ‚â§ to_fun r
  add_le' : ‚àÄ r s, to_fun (r + s) ‚â§ to_fun r + to_fun s
  neg' : ‚àÄ r, to_fun (-r) = to_fun r

attribute [nolint doc_blame] AddGroupSeminorm.toZeroHom

namespace AddGroupSeminorm

variable [AddGroup‚Çì E]

instance zeroHomClass : ZeroHomClass (AddGroupSeminorm E) E ‚Ñù where
  coe := fun f => f.toFun
  coe_injective' := fun f g h => by
    cases f <;> cases g <;> congr
  map_zero := fun f => f.map_zero'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`. -/
instance : CoeFun (AddGroupSeminorm E) fun _ => E ‚Üí ‚Ñù :=
  ‚ü®fun p => p.toFun‚ü©

@[ext]
theorem ext {p q : AddGroupSeminorm E} (h : ‚àÄ x, (p : E ‚Üí ‚Ñù) x = q x) : p = q :=
  FunLike.ext p q h

instance : Zero (AddGroupSeminorm E) :=
  ‚ü®{ toFun := 0, nonneg' := fun r => le_refl‚Çì _, map_zero' := Pi.zero_apply _,
      add_le' := fun _ _ => Eq.ge (zero_add‚Çì _), neg' := fun x => rfl }‚ü©

@[simp]
theorem coe_zero : ‚áë(0 : AddGroupSeminorm E) = 0 :=
  rfl

@[simp]
theorem zero_apply (x : E) : (0 : AddGroupSeminorm E) x = 0 :=
  rfl

instance : Inhabited (AddGroupSeminorm E) :=
  ‚ü®0‚ü©

variable (p : AddGroupSeminorm E) (x y : E) (r : ‚Ñù)

protected theorem nonneg : 0 ‚â§ p x :=
  p.nonneg' _

@[simp]
protected theorem map_zero : p 0 = 0 :=
  p.map_zero'

protected theorem add_le : p (x + y) ‚â§ p x + p y :=
  p.add_le' _ _

@[simp]
protected theorem neg : p (-x) = p x :=
  p.neg' _

/-- Any action on `‚Ñù` which factors through `‚Ñù‚â•0` applies to an `add_group_seminorm`. -/
instance [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] :
    HasSmul R (AddGroupSeminorm E) where smul := fun r p =>
    { toFun := fun x => r ‚Ä¢ p x,
      nonneg' := fun x => by
        simp only [smul_one_smul ‚Ñù‚â•0 r (_ : ‚Ñù), ‚Üê Nnreal.smul_def, ‚Üê smul_eq_mul]
        exact mul_nonneg (Nnreal.coe_nonneg _) (p.nonneg _),
      map_zero' := by
        simp only [smul_one_smul ‚Ñù‚â•0 r (_ : ‚Ñù), ‚Üê Nnreal.smul_def, ‚Üê smul_eq_mul, ‚Üê p.map_zero, ‚Üê mul_zero],
      add_le' := fun _ _ => by
        simp only [smul_one_smul ‚Ñù‚â•0 r (_ : ‚Ñù), ‚Üê Nnreal.smul_def, ‚Üê smul_eq_mul]
        exact (mul_le_mul_of_nonneg_left (p.add_le _ _) (Nnreal.coe_nonneg _)).trans_eq (mul_add‚Çì _ _ _),
      neg' := fun x => by
        rw [p.neg] }

instance [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] [HasSmul R' ‚Ñù] [HasSmul R' ‚Ñù‚â•0 ]
    [IsScalarTower R' ‚Ñù‚â•0 ‚Ñù] [HasSmul R R'] [IsScalarTower R R' ‚Ñù] :
    IsScalarTower R R' (AddGroupSeminorm E) where smul_assoc := fun r a p => ext fun x => smul_assoc r a (p x)

@[simp]
theorem coe_smul [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] (r : R) (p : AddGroupSeminorm E) :
    ‚áë(r ‚Ä¢ p) = r ‚Ä¢ p :=
  rfl

@[simp]
theorem smul_apply [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] (r : R) (p : AddGroupSeminorm E) (x : E) :
    (r ‚Ä¢ p) x = r ‚Ä¢ p x :=
  rfl

instance :
    Add
      (AddGroupSeminorm
        E) where add := fun p q =>
    { toFun := fun x => p x + q x, nonneg' := fun x => add_nonneg (p.Nonneg _) (q.Nonneg _),
      map_zero' := by
        rw [p.map_zero, q.map_zero, zero_add‚Çì],
      add_le' := fun _ _ => LE.le.trans_eq (add_le_add (p.add_le _ _) (q.add_le _ _)) (add_add_add_comm‚Çì _ _ _ _),
      neg' := fun x => by
        rw [p.neg, q.neg] }

@[simp]
theorem coe_add (p q : AddGroupSeminorm E) : ‚áë(p + q) = p + q :=
  rfl

@[simp]
theorem add_apply (p q : AddGroupSeminorm E) (x : E) : (p + q) x = p x + q x :=
  rfl

-- TODO: define `has_Sup` too, from the skeleton at
-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345
noncomputable instance :
    HasSup (AddGroupSeminorm E) where sup := fun p q =>
    { toFun := p‚äîq,
      nonneg' := fun x => by
        simp only [‚Üê Pi.sup_apply, ‚Üê le_sup_iff]
        exact Or.intro_left _ (p.nonneg _),
      map_zero' := by
        simp only [‚Üê Pi.sup_apply]
        rw [‚Üê p.map_zero, sup_eq_left, p.map_zero, q.map_zero],
      add_le' := fun x y =>
        sup_le ((p.add_le x y).trans <| add_le_add le_sup_left le_sup_left)
          ((q.add_le x y).trans <| add_le_add le_sup_right le_sup_right),
      neg' := fun x => by
        rw [Pi.sup_apply, Pi.sup_apply, p.neg, q.neg] }

@[simp]
theorem coe_sup (p q : AddGroupSeminorm E) : ‚áë(p‚äîq) = p‚äîq :=
  rfl

theorem sup_apply (p q : AddGroupSeminorm E) (x : E) : (p‚äîq) x = p x‚äîq x :=
  rfl

theorem smul_sup [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] (r : R) (p q : AddGroupSeminorm E) :
    r ‚Ä¢ (p‚äîq) = r ‚Ä¢ p‚äîr ‚Ä¢ q :=
  have real.smul_max : ‚àÄ x y : ‚Ñù, r ‚Ä¢ max x y = max (r ‚Ä¢ x) (r ‚Ä¢ y) := fun x y => by
    simpa only [smul_eq_mul, Nnreal.smul_def, ‚Üê smul_one_smul ‚Ñù‚â•0 r (_ : ‚Ñù)] using
      mul_max_of_nonneg x y (r ‚Ä¢ 1 : ‚Ñù‚â•0 ).Prop
  ext fun x => real.smul_max _ _

instance : PartialOrder‚Çì (AddGroupSeminorm E) :=
  PartialOrder‚Çì.lift _ FunLike.coe_injective

theorem le_def (p q : AddGroupSeminorm E) : p ‚â§ q ‚Üî (p : E ‚Üí ‚Ñù) ‚â§ q :=
  Iff.rfl

theorem lt_def (p q : AddGroupSeminorm E) : p < q ‚Üî (p : E ‚Üí ‚Ñù) < q :=
  Iff.rfl

noncomputable instance : SemilatticeSup (AddGroupSeminorm E) :=
  Function.Injective.semilatticeSup _ FunLike.coe_injective coe_sup

section AddCommGroup‚Çì

variable [AddCommGroup‚Çì G]

variable (q : AddGroupSeminorm G)

protected theorem sub_le (x y : G) : q (x - y) ‚â§ q x + q y :=
  calc
    q (x - y) = q (x + -y) := by
      rw [sub_eq_add_neg]
    _ ‚â§ q x + q (-y) := q.add_le x (-y)
    _ = q x + q y := by
      rw [q.neg]
    

theorem sub_rev (x y : G) : q (x - y) = q (y - x) := by
  rw [‚Üê neg_sub, q.neg]

/-- The direct path from 0 to y is shorter than the path with x "inserted" in between. -/
theorem le_insert (x y : G) : q y ‚â§ q x + q (x - y) :=
  calc
    q y = q (x - (x - y)) := by
      rw [sub_sub_cancel]
    _ ‚â§ q x + q (x - y) := q.sub_le _ _
    

/-- The direct path from 0 to x is shorter than the path with y "inserted" in between. -/
theorem le_insert' (x y : G) : q x ‚â§ q y + q (x - y) := by
  rw [sub_rev]
  exact le_insert _ _ _

private theorem bdd_below_range_add (x : G) (p q : AddGroupSeminorm G) :
    BddBelow (Range fun u : G => p u + q (x - u)) := by
  use 0
  rintro _ ‚ü®x, rfl‚ü©
  exact add_nonneg (p.nonneg _) (q.nonneg _)

noncomputable instance :
    HasInf
      (AddGroupSeminorm
        G) where inf := fun p q =>
    { toFun := fun x => ‚®Ö u : G, p u + q (x - u),
      map_zero' :=
        cinfi_eq_of_forall_ge_of_forall_gt_exists_lt (fun x => add_nonneg (p.Nonneg _) (q.Nonneg _)) fun r hr =>
          ‚ü®0, by
            simpa [‚Üê sub_zero, ‚Üê p.map_zero, ‚Üê q.map_zero, ‚Üê add_zero‚Çì] using hr‚ü©,
      nonneg' := fun x => le_cinfi fun x => add_nonneg (p.Nonneg _) (q.Nonneg _),
      add_le' := fun x y => by
        refine' le_cinfi_add_cinfi fun u v => _
        apply cinfi_le_of_le (bdd_below_range_add _ _ _) (v + u)
        dsimp' only
        convert add_le_add (p.add_le v u) (q.add_le (y - v) (x - u)) using 1
        ¬∑ rw
            [show x + y - (v + u) = y - v + (x - u) by
              abel]
          
        ¬∑ abel
          ,
      neg' := fun x => by
        have : (‚®Ö u : G, p u + q (x - u) : ‚Ñù) = ‚®Ö u : G, p (-u) + q (x + u) := by
          apply Function.Surjective.infi_congr (fun x : G => -x) neg_surjective
          ¬∑ intro u
            simp only [‚Üê neg_neg‚Çì, ‚Üê add_right_inj‚Çì, ‚Üê sub_eq_add_neg]
            
        rw [this]
        apply congr_arg
        ext u
        rw [p.neg, sub_eq_add_neg, ‚Üê neg_add_rev, add_comm‚Çì u, q.neg] }

@[simp]
theorem inf_apply (p q : AddGroupSeminorm G) (x : G) : (p‚äìq) x = ‚®Ö u : G, p u + q (x - u) :=
  rfl

noncomputable instance : Lattice (AddGroupSeminorm G) :=
  { AddGroupSeminorm.semilatticeSup with inf := (¬∑‚äì¬∑),
    inf_le_left := fun p q x => by
      apply cinfi_le_of_le (bdd_below_range_add _ _ _) x
      simp only [‚Üê sub_self, ‚Üê map_zero, ‚Üê add_zero‚Çì],
    inf_le_right := fun p q x => by
      apply cinfi_le_of_le (bdd_below_range_add _ _ _) (0 : G)
      simp only [‚Üê sub_self, ‚Üê map_zero, ‚Üê zero_add‚Çì, ‚Üê sub_zero],
    le_inf := fun a b c hab hac x => le_cinfi fun u => le_trans‚Çì (a.le_insert' _ _) (add_le_add (hab _) (hac _)) }

end AddCommGroup‚Çì

section Comp

variable [AddGroup‚Çì F] [AddGroup‚Çì G]

/-- Composition of an add_group_seminorm with an add_monoid_hom is an add_group_seminorm. -/
def comp (p : AddGroupSeminorm F) (f : E ‚Üí+ F) : AddGroupSeminorm E where
  toFun := fun x => p (f x)
  nonneg' := fun x => p.Nonneg _
  map_zero' := by
    rw [f.map_zero, p.map_zero]
  add_le' := fun _ _ => by
    apply Eq.trans_le (congr_arg p (f.map_add _ _)) (p.add_le _ _)
  neg' := fun x => by
    rw [map_neg, p.neg]

@[simp]
theorem coe_comp (p : AddGroupSeminorm F) (f : E ‚Üí+ F) : ‚áë(p.comp f) = p ‚àò f :=
  rfl

@[simp]
theorem comp_apply (p : AddGroupSeminorm F) (f : E ‚Üí+ F) (x : E) : (p.comp f) x = p (f x) :=
  rfl

@[simp]
theorem comp_id (p : AddGroupSeminorm E) : p.comp (AddMonoidHom.id _) = p :=
  ext fun _ => rfl

@[simp]
theorem comp_zero (p : AddGroupSeminorm F) : p.comp (0 : E ‚Üí+ F) = 0 :=
  ext fun _ => map_zero p

@[simp]
theorem zero_comp (f : E ‚Üí+ F) : (0 : AddGroupSeminorm F).comp f = 0 :=
  ext fun _ => rfl

theorem comp_comp (p : AddGroupSeminorm G) (g : F ‚Üí+ G) (f : E ‚Üí+ F) : p.comp (g.comp f) = (p.comp g).comp f :=
  ext fun _ => rfl

theorem add_comp (p q : AddGroupSeminorm F) (f : E ‚Üí+ F) : (p + q).comp f = p.comp f + q.comp f :=
  ext fun _ => rfl

theorem comp_add_le {A B : Type _} [AddCommGroup‚Çì A] [AddCommGroup‚Çì B] (p : AddGroupSeminorm B) (f g : A ‚Üí+ B) :
    p.comp (f + g) ‚â§ p.comp f + p.comp g := fun _ => p.add_le _ _

theorem comp_mono {p : AddGroupSeminorm F} {q : AddGroupSeminorm F} (f : E ‚Üí+ F) (hp : p ‚â§ q) : p.comp f ‚â§ q.comp f :=
  fun _ => hp _

end Comp

end AddGroupSeminorm

/-- A seminorm on a module over a normed ring is a function to the reals that is positive
semidefinite, positive homogeneous, and subadditive. -/
structure Seminorm (ùïú : Type _) (E : Type _) [SemiNormedRing ùïú] [AddGroup‚Çì E] [HasSmul ùïú E] extends
  AddGroupSeminorm E where
  smul' : ‚àÄ (a : ùïú) (x : E), to_fun (a ‚Ä¢ x) = ‚à•a‚à• * to_fun x

attribute [nolint doc_blame] Seminorm.toAddGroupSeminorm

private theorem map_zero.of_smul {ùïú : Type _} {E : Type _} [SemiNormedRing ùïú] [AddGroup‚Çì E] [SmulWithZero ùïú E]
    {f : E ‚Üí ‚Ñù} (smul : ‚àÄ (a : ùïú) (x : E), f (a ‚Ä¢ x) = ‚à•a‚à• * f x) : f 0 = 0 :=
  calc
    f 0 = f ((0 : ùïú) ‚Ä¢ 0) := by
      rw [zero_smul]
    _ = 0 := by
      rw [smul, norm_zero, zero_mul]
    

private theorem neg.of_smul {ùïú : Type _} {E : Type _} [SemiNormedRing ùïú] [AddCommGroup‚Çì E] [Module ùïú E] {f : E ‚Üí ‚Ñù}
    (smul : ‚àÄ (a : ùïú) (x : E), f (a ‚Ä¢ x) = ‚à•a‚à• * f x) (x : E) : f (-x) = f x := by
  rw [‚Üê neg_one_smul ùïú, smul, norm_neg, ‚Üê smul, one_smul]

private theorem nonneg.of {ùïú : Type _} {E : Type _} [SemiNormedRing ùïú] [AddCommGroup‚Çì E] [Module ùïú E] {f : E ‚Üí ‚Ñù}
    (add_le : ‚àÄ x y : E, f (x + y) ‚â§ f x + f y) (smul : ‚àÄ (a : ùïú) (x : E), f (a ‚Ä¢ x) = ‚à•a‚à• * f x) (x : E) : 0 ‚â§ f x :=
  have h : 0 ‚â§ 2 * f x :=
    calc
      0 = f (x + -x) := by
        rw [add_neg_self‚Çì, map_zero.of_smul smul]
      _ ‚â§ f x + f (-x) := add_le _ _
      _ = 2 * f x := by
        rw [neg.of_smul smul, two_mul]
      
  nonneg_of_mul_nonneg_right h zero_lt_two

/-- Alternative constructor for a `seminorm` on an `add_comm_group E` that is a module over a
`semi_norm_ring ùïú`. -/
def Seminorm.of {ùïú : Type _} {E : Type _} [SemiNormedRing ùïú] [AddCommGroup‚Çì E] [Module ùïú E] (f : E ‚Üí ‚Ñù)
    (add_le : ‚àÄ x y : E, f (x + y) ‚â§ f x + f y) (smul : ‚àÄ (a : ùïú) (x : E), f (a ‚Ä¢ x) = ‚à•a‚à• * f x) : Seminorm ùïú E where
  toFun := f
  map_zero' := MapZero.of_smul smul
  nonneg' := Nonneg.of add_le smul
  add_le' := add_le
  smul' := smul
  neg' := Neg.of_smul smul

namespace Seminorm

section SemiNormedRing

variable [SemiNormedRing ùïú]

section AddGroup‚Çì

variable [AddGroup‚Çì E]

section HasSmul

variable [HasSmul ùïú E]

instance zeroHomClass : ZeroHomClass (Seminorm ùïú E) E ‚Ñù where
  coe := fun f => f.toFun
  coe_injective' := fun f g h => by
    cases f <;> cases g <;> congr
  map_zero := fun f => f.map_zero'

/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`. -/
instance : CoeFun (Seminorm ùïú E) fun _ => E ‚Üí ‚Ñù :=
  ‚ü®fun p => p.toFun‚ü©

@[ext]
theorem ext {p q : Seminorm ùïú E} (h : ‚àÄ x, (p : E ‚Üí ‚Ñù) x = q x) : p = q :=
  FunLike.ext p q h

instance : Zero (Seminorm ùïú E) :=
  ‚ü®{ AddGroupSeminorm.hasZero.zero with smul' := fun _ _ => (mul_zero _).symm }‚ü©

@[simp]
theorem coe_zero : ‚áë(0 : Seminorm ùïú E) = 0 :=
  rfl

@[simp]
theorem zero_apply (x : E) : (0 : Seminorm ùïú E) x = 0 :=
  rfl

instance : Inhabited (Seminorm ùïú E) :=
  ‚ü®0‚ü©

variable (p : Seminorm ùïú E) (c : ùïú) (x y : E) (r : ‚Ñù)

protected theorem nonneg : 0 ‚â§ p x :=
  p.nonneg' _

protected theorem map_zero : p 0 = 0 :=
  p.map_zero'

protected theorem smul : p (c ‚Ä¢ x) = ‚à•c‚à• * p x :=
  p.smul' _ _

protected theorem add_le : p (x + y) ‚â§ p x + p y :=
  p.add_le' _ _

/-- Any action on `‚Ñù` which factors through `‚Ñù‚â•0` applies to a seminorm. -/
instance [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] :
    HasSmul R
      (Seminorm ùïú
        E) where smul := fun r p =>
    { r ‚Ä¢ p.toAddGroupSeminorm with toFun := fun x => r ‚Ä¢ p x,
      smul' := fun _ _ => by
        simp only [smul_one_smul ‚Ñù‚â•0 r (_ : ‚Ñù), ‚Üê Nnreal.smul_def, ‚Üê smul_eq_mul]
        rw [p.smul, mul_left_comm‚Çì] }

instance [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] [HasSmul R' ‚Ñù] [HasSmul R' ‚Ñù‚â•0 ]
    [IsScalarTower R' ‚Ñù‚â•0 ‚Ñù] [HasSmul R R'] [IsScalarTower R R' ‚Ñù] :
    IsScalarTower R R' (Seminorm ùïú E) where smul_assoc := fun r a p => ext fun x => smul_assoc r a (p x)

theorem coe_smul [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] (r : R) (p : Seminorm ùïú E) : ‚áë(r ‚Ä¢ p) = r ‚Ä¢ p :=
  rfl

@[simp]
theorem smul_apply [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] (r : R) (p : Seminorm ùïú E) (x : E) :
    (r ‚Ä¢ p) x = r ‚Ä¢ p x :=
  rfl

instance :
    Add
      (Seminorm ùïú
        E) where add := fun p q =>
    { p.toAddGroupSeminorm + q.toAddGroupSeminorm with toFun := fun x => p x + q x,
      smul' := fun a x => by
        simp only [‚Üê p.smul, ‚Üê q.smul, ‚Üê mul_add‚Çì] }

theorem coe_add (p q : Seminorm ùïú E) : ‚áë(p + q) = p + q :=
  rfl

@[simp]
theorem add_apply (p q : Seminorm ùïú E) (x : E) : (p + q) x = p x + q x :=
  rfl

instance : AddMonoid‚Çì (Seminorm ùïú E) :=
  FunLike.coe_injective.AddMonoid _ rfl coe_add fun p n => coe_smul n p

instance : OrderedCancelAddCommMonoid (Seminorm ùïú E) :=
  FunLike.coe_injective.OrderedCancelAddCommMonoid _ rfl coe_add fun p n => coe_smul n p

instance [Monoid‚Çì R] [MulAction R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] : MulAction R (Seminorm ùïú E) :=
  FunLike.coe_injective.MulAction _ coe_smul

variable (ùïú E)

/-- `coe_fn` as an `add_monoid_hom`. Helper definition for showing that `seminorm ùïú E` is
a module. -/
@[simps]
def coeFnAddMonoidHom : AddMonoidHom (Seminorm ùïú E) (E ‚Üí ‚Ñù) :=
  ‚ü®coeFn, coe_zero, coe_add‚ü©

theorem coe_fn_add_monoid_hom_injective : Function.Injective (coeFnAddMonoidHom ùïú E) :=
  show @Function.Injective (Seminorm ùïú E) (E ‚Üí ‚Ñù) coeFn from FunLike.coe_injective

variable {ùïú E}

instance [Monoid‚Çì R] [DistribMulAction R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] :
    DistribMulAction R (Seminorm ùïú E) :=
  (coe_fn_add_monoid_hom_injective ùïú E).DistribMulAction _ coe_smul

instance [Semiring‚Çì R] [Module R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] : Module R (Seminorm ùïú E) :=
  (coe_fn_add_monoid_hom_injective ùïú E).Module R _ coe_smul

-- TODO: define `has_Sup` too, from the skeleton at
-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345
noncomputable instance :
    HasSup
      (Seminorm ùïú
        E) where sup := fun p q =>
    { p.toAddGroupSeminorm‚äîq.toAddGroupSeminorm with toFun := p‚äîq,
      smul' := fun x v =>
        (congr_arg2‚Çì max (p.smul x v) (q.smul x v)).trans <| (mul_max_of_nonneg _ _ <| norm_nonneg x).symm }

@[simp]
theorem coe_sup (p q : Seminorm ùïú E) : ‚áë(p‚äîq) = p‚äîq :=
  rfl

theorem sup_apply (p q : Seminorm ùïú E) (x : E) : (p‚äîq) x = p x‚äîq x :=
  rfl

theorem smul_sup [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] (r : R) (p q : Seminorm ùïú E) :
    r ‚Ä¢ (p‚äîq) = r ‚Ä¢ p‚äîr ‚Ä¢ q :=
  have real.smul_max : ‚àÄ x y : ‚Ñù, r ‚Ä¢ max x y = max (r ‚Ä¢ x) (r ‚Ä¢ y) := fun x y => by
    simpa only [smul_eq_mul, Nnreal.smul_def, ‚Üê smul_one_smul ‚Ñù‚â•0 r (_ : ‚Ñù)] using
      mul_max_of_nonneg x y (r ‚Ä¢ 1 : ‚Ñù‚â•0 ).Prop
  ext fun x => real.smul_max _ _

instance : PartialOrder‚Çì (Seminorm ùïú E) :=
  PartialOrder‚Çì.lift _ FunLike.coe_injective

theorem le_def (p q : Seminorm ùïú E) : p ‚â§ q ‚Üî (p : E ‚Üí ‚Ñù) ‚â§ q :=
  Iff.rfl

theorem lt_def (p q : Seminorm ùïú E) : p < q ‚Üî (p : E ‚Üí ‚Ñù) < q :=
  Iff.rfl

noncomputable instance : SemilatticeSup (Seminorm ùïú E) :=
  Function.Injective.semilatticeSup _ FunLike.coe_injective coe_sup

end HasSmul

end AddGroup‚Çì

section Module

variable [AddCommGroup‚Çì E] [AddCommGroup‚Çì F] [AddCommGroup‚Çì G]

variable [Module ùïú E] [Module ùïú F] [Module ùïú G]

variable [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù]

/-- Composition of a seminorm with a linear map is a seminorm. -/
def comp (p : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) : Seminorm ùïú E :=
  { p.toAddGroupSeminorm.comp f.toAddMonoidHom with toFun := fun x => p (f x),
    smul' := fun _ _ => (congr_arg p (f.map_smul _ _)).trans (p.smul _ _) }

theorem coe_comp (p : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) : ‚áë(p.comp f) = p ‚àò f :=
  rfl

@[simp]
theorem comp_apply (p : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) (x : E) : (p.comp f) x = p (f x) :=
  rfl

@[simp]
theorem comp_id (p : Seminorm ùïú E) : p.comp LinearMap.id = p :=
  ext fun _ => rfl

@[simp]
theorem comp_zero (p : Seminorm ùïú F) : p.comp (0 : E ‚Üí‚Çó[ùïú] F) = 0 :=
  ext fun _ => map_zero p

@[simp]
theorem zero_comp (f : E ‚Üí‚Çó[ùïú] F) : (0 : Seminorm ùïú F).comp f = 0 :=
  ext fun _ => rfl

theorem comp_comp (p : Seminorm ùïú G) (g : F ‚Üí‚Çó[ùïú] G) (f : E ‚Üí‚Çó[ùïú] F) : p.comp (g.comp f) = (p.comp g).comp f :=
  ext fun _ => rfl

theorem add_comp (p q : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) : (p + q).comp f = p.comp f + q.comp f :=
  ext fun _ => rfl

theorem comp_add_le (p : Seminorm ùïú F) (f g : E ‚Üí‚Çó[ùïú] F) : p.comp (f + g) ‚â§ p.comp f + p.comp g := fun _ => p.add_le _ _

theorem smul_comp (p : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) (c : R) : (c ‚Ä¢ p).comp f = c ‚Ä¢ p.comp f :=
  ext fun _ => rfl

theorem comp_mono {p : Seminorm ùïú F} {q : Seminorm ùïú F} (f : E ‚Üí‚Çó[ùïú] F) (hp : p ‚â§ q) : p.comp f ‚â§ q.comp f := fun _ =>
  hp _

/-- The composition as an `add_monoid_hom`. -/
@[simps]
def pullback (f : E ‚Üí‚Çó[ùïú] F) : AddMonoidHom (Seminorm ùïú F) (Seminorm ùïú E) :=
  ‚ü®fun p => p.comp f, zero_comp f, fun p q => add_comp p q f‚ü©

section

variable (p : Seminorm ùïú E)

@[simp]
protected theorem neg (x : E) : p (-x) = p x := by
  rw [‚Üê neg_one_smul ùïú, Seminorm.smul, norm_neg, ‚Üê Seminorm.smul, one_smul]

protected theorem sub_le (x y : E) : p (x - y) ‚â§ p x + p y :=
  calc
    p (x - y) = p (x + -y) := by
      rw [sub_eq_add_neg]
    _ ‚â§ p x + p (-y) := p.add_le x (-y)
    _ = p x + p y := by
      rw [p.neg]
    

theorem sub_rev (x y : E) : p (x - y) = p (y - x) := by
  rw [‚Üê neg_sub, p.neg]

/-- The direct path from 0 to y is shorter than the path with x "inserted" in between. -/
theorem le_insert (x y : E) : p y ‚â§ p x + p (x - y) :=
  calc
    p y = p (x - (x - y)) := by
      rw [sub_sub_cancel]
    _ ‚â§ p x + p (x - y) := p.sub_le _ _
    

/-- The direct path from 0 to x is shorter than the path with y "inserted" in between. -/
theorem le_insert' (x y : E) : p x ‚â§ p y + p (x - y) := by
  rw [sub_rev]
  exact le_insert _ _ _

end

instance : OrderBot (Seminorm ùïú E) :=
  ‚ü®0, Seminorm.nonneg‚ü©

@[simp]
theorem coe_bot : ‚áë(‚ä• : Seminorm ùïú E) = 0 :=
  rfl

theorem bot_eq_zero : (‚ä• : Seminorm ùïú E) = 0 :=
  rfl

theorem smul_le_smul {p q : Seminorm ùïú E} {a b : ‚Ñù‚â•0 } (hpq : p ‚â§ q) (hab : a ‚â§ b) : a ‚Ä¢ p ‚â§ b ‚Ä¢ q := by
  simp_rw [le_def, Pi.le_def, coe_smul]
  intro x
  simp_rw [Pi.smul_apply, Nnreal.smul_def, smul_eq_mul]
  exact mul_le_mul hab (hpq x) (p.nonneg x) (Nnreal.coe_nonneg b)

theorem finset_sup_apply (p : Œπ ‚Üí Seminorm ùïú E) (s : Finset Œπ) (x : E) :
    s.sup p x = ‚Üë(s.sup fun i => ‚ü®p i x, (p i).Nonneg x‚ü© : ‚Ñù‚â•0 ) := by
  induction' s using Finset.cons_induction_on with a s ha ih
  ¬∑ rw [Finset.sup_empty, Finset.sup_empty, coe_bot, _root_.bot_eq_zero, Pi.zero_apply, Nonneg.coe_zero]
    
  ¬∑ rw [Finset.sup_cons, Finset.sup_cons, coe_sup, sup_eq_max, Pi.sup_apply, sup_eq_max, Nnreal.coe_max, Subtype.coe_mk,
      ih]
    

theorem finset_sup_le_sum (p : Œπ ‚Üí Seminorm ùïú E) (s : Finset Œπ) : s.sup p ‚â§ ‚àë i in s, p i := by
  classical
  refine' finset.sup_le_iff.mpr _
  intro i hi
  rw [Finset.sum_eq_sum_diff_singleton_add hi, le_add_iff_nonneg_left]
  exact bot_le

theorem finset_sup_apply_le {p : Œπ ‚Üí Seminorm ùïú E} {s : Finset Œπ} {x : E} {a : ‚Ñù} (ha : 0 ‚â§ a)
    (h : ‚àÄ i, i ‚àà s ‚Üí p i x ‚â§ a) : s.sup p x ‚â§ a := by
  lift a to ‚Ñù‚â•0 using ha
  rw [finset_sup_apply, Nnreal.coe_le_coe]
  exact Finset.sup_le h

theorem finset_sup_apply_lt {p : Œπ ‚Üí Seminorm ùïú E} {s : Finset Œπ} {x : E} {a : ‚Ñù} (ha : 0 < a)
    (h : ‚àÄ i, i ‚àà s ‚Üí p i x < a) : s.sup p x < a := by
  lift a to ‚Ñù‚â•0 using ha.le
  rw [finset_sup_apply, Nnreal.coe_lt_coe, Finset.sup_lt_iff]
  ¬∑ exact h
    
  ¬∑ exact nnreal.coe_pos.mpr ha
    

end Module

end SemiNormedRing

section SemiNormedCommRing

variable [SemiNormedCommRing ùïú] [AddCommGroup‚Çì E] [AddCommGroup‚Çì F] [Module ùïú E] [Module ùïú F]

theorem comp_smul (p : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) (c : ùïú) : p.comp (c ‚Ä¢ f) = ‚à•c‚à•‚Çä ‚Ä¢ p.comp f :=
  ext fun _ => by
    rw [comp_apply, smul_apply, LinearMap.smul_apply, p.smul, Nnreal.smul_def, coe_nnnorm, smul_eq_mul, comp_apply]

theorem comp_smul_apply (p : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) (c : ùïú) (x : E) : p.comp (c ‚Ä¢ f) x = ‚à•c‚à• * p (f x) :=
  p.smul _ _

end SemiNormedCommRing

section NormedField

variable [NormedField ùïú] [AddCommGroup‚Çì E] [Module ùïú E]

private theorem bdd_below_range_add (x : E) (p q : Seminorm ùïú E) : BddBelow (Range fun u : E => p u + q (x - u)) := by
  use 0
  rintro _ ‚ü®x, rfl‚ü©
  exact add_nonneg (p.nonneg _) (q.nonneg _)

noncomputable instance :
    HasInf
      (Seminorm ùïú
        E) where inf := fun p q =>
    { p.toAddGroupSeminorm‚äìq.toAddGroupSeminorm with toFun := fun x => ‚®Ö u : E, p u + q (x - u),
      smul' := by
        intro a x
        obtain rfl | ha := eq_or_ne a 0
        ¬∑ rw [norm_zero, zero_mul, zero_smul]
          refine'
            cinfi_eq_of_forall_ge_of_forall_gt_exists_lt (fun i => add_nonneg (p.nonneg _) (q.nonneg _)) fun x hx =>
              ‚ü®0, by
                rwa [map_zero, sub_zero, map_zero, add_zero‚Çì]‚ü©
          
        simp_rw [Real.mul_infi_of_nonneg (norm_nonneg a), mul_add‚Çì, ‚Üê p.smul, ‚Üê q.smul, smul_sub]
        refine' Function.Surjective.infi_congr ((¬∑ ‚Ä¢ ¬∑) a‚Åª¬π : E ‚Üí E) (fun u => ‚ü®a ‚Ä¢ u, inv_smul_smul‚ÇÄ ha u‚ü©) fun u => _
        rw [smul_inv_smul‚ÇÄ ha] }

@[simp]
theorem inf_apply (p q : Seminorm ùïú E) (x : E) : (p‚äìq) x = ‚®Ö u : E, p u + q (x - u) :=
  rfl

noncomputable instance : Lattice (Seminorm ùïú E) :=
  { Seminorm.semilatticeSup with inf := (¬∑‚äì¬∑),
    inf_le_left := fun p q x => by
      apply cinfi_le_of_le (bdd_below_range_add _ _ _) x
      simp only [‚Üê sub_self, ‚Üê map_zero, ‚Üê add_zero‚Çì],
    inf_le_right := fun p q x => by
      apply cinfi_le_of_le (bdd_below_range_add _ _ _) (0 : E)
      simp only [‚Üê sub_self, ‚Üê map_zero, ‚Üê zero_add‚Çì, ‚Üê sub_zero],
    le_inf := fun a b c hab hac x => le_cinfi fun u => le_trans‚Çì (a.le_insert' _ _) (add_le_add (hab _) (hac _)) }

theorem smul_inf [HasSmul R ‚Ñù] [HasSmul R ‚Ñù‚â•0 ] [IsScalarTower R ‚Ñù‚â•0 ‚Ñù] (r : R) (p q : Seminorm ùïú E) :
    r ‚Ä¢ (p‚äìq) = r ‚Ä¢ p‚äìr ‚Ä¢ q := by
  ext
  simp_rw [smul_apply, inf_apply, smul_apply, ‚Üê smul_one_smul ‚Ñù‚â•0 r (_ : ‚Ñù), Nnreal.smul_def, smul_eq_mul,
    Real.mul_infi_of_nonneg (Subtype.prop _), mul_add‚Çì]

end NormedField

/-! ### Seminorm ball -/


section SemiNormedRing

variable [SemiNormedRing ùïú]

section AddCommGroup‚Çì

variable [AddCommGroup‚Çì E]

section HasSmul

variable [HasSmul ùïú E] (p : Seminorm ùïú E)

/-- The ball of radius `r` at `x` with respect to seminorm `p` is the set of elements `y` with
`p (y - x) < `r`. -/
def Ball (x : E) (r : ‚Ñù) :=
  { y : E | p (y - x) < r }

variable {x y : E} {r : ‚Ñù}

@[simp]
theorem mem_ball : y ‚àà Ball p x r ‚Üî p (y - x) < r :=
  Iff.rfl

theorem mem_ball_zero : y ‚àà Ball p 0 r ‚Üî p y < r := by
  rw [mem_ball, sub_zero]

theorem ball_zero_eq : Ball p 0 r = { y : E | p y < r } :=
  Set.ext fun x => p.mem_ball_zero

@[simp]
theorem ball_zero' (x : E) (hr : 0 < r) : Ball (0 : Seminorm ùïú E) x r = Set.Univ := by
  rw [Set.eq_univ_iff_forall, ball]
  simp [‚Üê hr]

theorem ball_smul (p : Seminorm ùïú E) {c : Nnreal} (hc : 0 < c) (r : ‚Ñù) (x : E) : (c ‚Ä¢ p).ball x r = p.ball x (r / c) :=
  by
  ext
  rw [mem_ball, mem_ball, smul_apply, Nnreal.smul_def, smul_eq_mul, mul_comm, lt_div_iff (nnreal.coe_pos.mpr hc)]

theorem ball_sup (p : Seminorm ùïú E) (q : Seminorm ùïú E) (e : E) (r : ‚Ñù) : Ball (p‚äîq) e r = Ball p e r ‚à© Ball q e r := by
  simp_rw [ball, ‚Üê Set.set_of_and, coe_sup, Pi.sup_apply, sup_lt_iff]

theorem ball_finset_sup' (p : Œπ ‚Üí Seminorm ùïú E) (s : Finset Œπ) (H : s.Nonempty) (e : E) (r : ‚Ñù) :
    Ball (s.sup' H p) e r = s.inf' H fun i => Ball (p i) e r := by
  induction' H using Finset.Nonempty.cons_induction with a a s ha hs ih
  ¬∑ classical
    simp
    
  ¬∑ rw [Finset.sup'_cons hs, Finset.inf'_cons hs, ball_sup, inf_eq_inter, ih]
    

theorem ball_mono {p : Seminorm ùïú E} {r‚ÇÅ r‚ÇÇ : ‚Ñù} (h : r‚ÇÅ ‚â§ r‚ÇÇ) : p.ball x r‚ÇÅ ‚äÜ p.ball x r‚ÇÇ := fun _ (hx : _ < _) =>
  hx.trans_le h

theorem ball_antitone {p q : Seminorm ùïú E} (h : q ‚â§ p) : p.ball x r ‚äÜ q.ball x r := fun _ => (h _).trans_lt

theorem ball_add_ball_subset (p : Seminorm ùïú E) (r‚ÇÅ r‚ÇÇ : ‚Ñù) (x‚ÇÅ x‚ÇÇ : E) :
    p.ball (x‚ÇÅ : E) r‚ÇÅ + p.ball (x‚ÇÇ : E) r‚ÇÇ ‚äÜ p.ball (x‚ÇÅ + x‚ÇÇ) (r‚ÇÅ + r‚ÇÇ) := by
  rintro x ‚ü®y‚ÇÅ, y‚ÇÇ, hy‚ÇÅ, hy‚ÇÇ, rfl‚ü©
  rw [mem_ball, add_sub_add_comm]
  exact (p.add_le _ _).trans_lt (add_lt_add hy‚ÇÅ hy‚ÇÇ)

end HasSmul

section Module

variable [Module ùïú E]

variable [AddCommGroup‚Çì F] [Module ùïú F]

theorem ball_comp (p : Seminorm ùïú F) (f : E ‚Üí‚Çó[ùïú] F) (x : E) (r : ‚Ñù) : (p.comp f).ball x r = f ‚Åª¬π' p.ball (f x) r := by
  ext
  simp_rw [ball, mem_preimage, comp_apply, Set.mem_set_of_eq, map_sub]

variable (p : Seminorm ùïú E)

theorem ball_zero_eq_preimage_ball {r : ‚Ñù} : p.ball 0 r = p ‚Åª¬π' Metric.Ball 0 r := by
  ext x
  simp only [‚Üê mem_ball, ‚Üê sub_zero, ‚Üê mem_preimage, ‚Üê mem_ball_zero_iff]
  rw [Real.norm_of_nonneg]
  exact p.nonneg _

@[simp]
theorem ball_bot {r : ‚Ñù} (x : E) (hr : 0 < r) : Ball (‚ä• : Seminorm ùïú E) x r = Set.Univ :=
  ball_zero' x hr

/-- Seminorm-balls at the origin are balanced. -/
theorem balanced_ball_zero (r : ‚Ñù) : Balanced ùïú (Ball p 0 r) := by
  rintro a ha x ‚ü®y, hy, hx‚ü©
  rw [mem_ball_zero, ‚Üê hx, p.smul]
  calc _ ‚â§ p y := mul_le_of_le_one_left (p.nonneg _) ha _ < r := by
      rwa [mem_ball_zero] at hy

theorem ball_finset_sup_eq_Inter (p : Œπ ‚Üí Seminorm ùïú E) (s : Finset Œπ) (x : E) {r : ‚Ñù} (hr : 0 < r) :
    Ball (s.sup p) x r = ‚ãÇ i ‚àà s, Ball (p i) x r := by
  lift r to Nnreal using hr.le
  simp_rw [ball, Inter_set_of, finset_sup_apply, Nnreal.coe_lt_coe, Finset.sup_lt_iff (show ‚ä• < r from hr), ‚Üê
    Nnreal.coe_lt_coe, Subtype.coe_mk]

theorem ball_finset_sup (p : Œπ ‚Üí Seminorm ùïú E) (s : Finset Œπ) (x : E) {r : ‚Ñù} (hr : 0 < r) :
    Ball (s.sup p) x r = s.inf fun i => Ball (p i) x r := by
  rw [Finset.inf_eq_infi]
  exact ball_finset_sup_eq_Inter _ _ _ hr

theorem ball_smul_ball (p : Seminorm ùïú E) (r‚ÇÅ r‚ÇÇ : ‚Ñù) : Metric.Ball (0 : ùïú) r‚ÇÅ ‚Ä¢ p.ball 0 r‚ÇÇ ‚äÜ p.ball 0 (r‚ÇÅ * r‚ÇÇ) := by
  rw [Set.subset_def]
  intro x hx
  rw [Set.mem_smul] at hx
  rcases hx with ‚ü®a, y, ha, hy, hx‚ü©
  rw [‚Üê hx, mem_ball_zero, Seminorm.smul]
  exact mul_lt_mul'' (mem_ball_zero_iff.mp ha) (p.mem_ball_zero.mp hy) (norm_nonneg a) (p.nonneg y)

@[simp]
theorem ball_eq_emptyset (p : Seminorm ùïú E) {x : E} {r : ‚Ñù} (hr : r ‚â§ 0) : p.ball x r = ‚àÖ := by
  ext
  rw [Seminorm.mem_ball, Set.mem_empty_eq, iff_false‚Çì, not_lt‚Çì]
  exact hr.trans (p.nonneg _)

end Module

end AddCommGroup‚Çì

end SemiNormedRing

section NormedField

variable [NormedField ùïú] [AddCommGroup‚Çì E] [Module ùïú E] (p : Seminorm ùïú E) {A B : Set E} {a : ùïú} {r : ‚Ñù} {x : E}

theorem smul_ball_zero {p : Seminorm ùïú E} {k : ùïú} {r : ‚Ñù} (hk : 0 < ‚à•k‚à•) : k ‚Ä¢ p.ball 0 r = p.ball 0 (‚à•k‚à• * r) := by
  ext
  rw [Set.mem_smul_set, Seminorm.mem_ball_zero]
  constructor <;> intro h
  ¬∑ rcases h with ‚ü®y, hy, h‚ü©
    rw [‚Üê h, Seminorm.smul]
    rw [Seminorm.mem_ball_zero] at hy
    exact (mul_lt_mul_left hk).mpr hy
    
  refine' ‚ü®k‚Åª¬π ‚Ä¢ x, _, _‚ü©
  ¬∑ rw [Seminorm.mem_ball_zero, Seminorm.smul, norm_inv, ‚Üê mul_lt_mul_left hk, ‚Üê mul_assoc, ‚Üê div_eq_mul_inv ‚à•k‚à• ‚à•k‚à•,
      div_self (ne_of_gt‚Çì hk), one_mul‚Çì]
    exact h
    
  rw [‚Üê smul_assoc, smul_eq_mul, ‚Üê div_eq_mul_inv, div_self (norm_pos_iff.mp hk), one_smul]

theorem ball_zero_absorbs_ball_zero (p : Seminorm ùïú E) {r‚ÇÅ r‚ÇÇ : ‚Ñù} (hr‚ÇÅ : 0 < r‚ÇÅ) :
    Absorbs ùïú (p.ball 0 r‚ÇÅ) (p.ball 0 r‚ÇÇ) := by
  by_cases' hr‚ÇÇ : r‚ÇÇ ‚â§ 0
  ¬∑ rw [ball_eq_emptyset p hr‚ÇÇ]
    exact absorbs_empty
    
  rw [not_le‚Çì] at hr‚ÇÇ
  rcases exists_between hr‚ÇÅ with ‚ü®r, hr, hr'‚ü©
  refine' ‚ü®r‚ÇÇ / r, div_pos hr‚ÇÇ hr, _‚ü©
  simp_rw [Set.subset_def]
  intro a ha x hx
  have ha' : 0 < ‚à•a‚à• := lt_of_lt_of_le‚Çì (div_pos hr‚ÇÇ hr) ha
  rw [smul_ball_zero ha', p.mem_ball_zero]
  rw [p.mem_ball_zero] at hx
  rw [div_le_iff hr] at ha
  exact hx.trans (lt_of_le_of_lt‚Çì ha ((mul_lt_mul_left ha').mpr hr'))

/-- Seminorm-balls at the origin are absorbent. -/
protected theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (Ball p (0 : E) r) := by
  rw [absorbent_iff_nonneg_lt]
  rintro x
  have hxr : 0 ‚â§ p x / r := div_nonneg (p.nonneg _) hr.le
  refine' ‚ü®p x / r, hxr, fun a ha => _‚ü©
  have ha‚ÇÄ : 0 < ‚à•a‚à• := hxr.trans_lt ha
  refine' ‚ü®a‚Åª¬π ‚Ä¢ x, _, smul_inv_smul‚ÇÄ (norm_pos_iff.1 ha‚ÇÄ) x‚ü©
  rwa [mem_ball_zero, p.smul, norm_inv, inv_mul_lt_iff ha‚ÇÄ, ‚Üê div_lt_iff hr]

/-- Seminorm-balls containing the origin are absorbent. -/
protected theorem absorbent_ball (hpr : p x < r) : Absorbent ùïú (Ball p x r) := by
  refine' (p.absorbent_ball_zero <| sub_pos.2 hpr).Subset fun y hy => _
  rw [p.mem_ball_zero] at hy
  exact p.mem_ball.2 ((p.sub_le _ _).trans_lt <| add_lt_of_lt_sub_right hy)

theorem symmetric_ball_zero (r : ‚Ñù) (hx : x ‚àà Ball p 0 r) : -x ‚àà Ball p 0 r :=
  balanced_ball_zero p r (-1)
    (by
      rw [norm_neg, norm_one])
    ‚ü®x, hx, by
      rw [neg_smul, one_smul]‚ü©

@[simp]
theorem neg_ball (p : Seminorm ùïú E) (r : ‚Ñù) (x : E) : -Ball p x r = Ball p (-x) r := by
  ext
  rw [mem_neg, mem_ball, mem_ball, ‚Üê neg_add', sub_neg_eq_add, p.neg]

@[simp]
theorem smul_ball_preimage (p : Seminorm ùïú E) (y : E) (r : ‚Ñù) (a : ùïú) (ha : a ‚â† 0) :
    (¬∑ ‚Ä¢ ¬∑) a ‚Åª¬π' p.ball y r = p.ball (a‚Åª¬π ‚Ä¢ y) (r / ‚à•a‚à•) :=
  Set.ext fun _ => by
    rw [mem_preimage, mem_ball, mem_ball, lt_div_iff (norm_pos_iff.mpr ha), mul_comm, ‚Üê p.smul, smul_sub,
      smul_inv_smul‚ÇÄ ha]

end NormedField

section Convex

variable [NormedField ùïú] [AddCommGroup‚Çì E] [NormedSpace ‚Ñù ùïú] [Module ùïú E]

section HasSmul

variable [HasSmul ‚Ñù E] [IsScalarTower ‚Ñù ùïú E] (p : Seminorm ùïú E)

/-- A seminorm is convex. Also see `convex_on_norm`. -/
protected theorem convex_on : ConvexOn ‚Ñù Univ p := by
  refine' ‚ü®convex_univ, fun x y _ _ a b ha hb hab => _‚ü©
  calc p (a ‚Ä¢ x + b ‚Ä¢ y) ‚â§ p (a ‚Ä¢ x) + p (b ‚Ä¢ y) := p.add_le _ _ _ = ‚à•a ‚Ä¢ (1 : ùïú)‚à• * p x + ‚à•b ‚Ä¢ (1 : ùïú)‚à• * p y := by
      rw [‚Üê p.smul, ‚Üê p.smul, smul_one_smul, smul_one_smul]_ = a * p x + b * p y := by
      rw [norm_smul, norm_smul, norm_one, mul_one‚Çì, mul_one‚Çì, Real.norm_of_nonneg ha, Real.norm_of_nonneg hb]

end HasSmul

section Module

variable [Module ‚Ñù E] [IsScalarTower ‚Ñù ùïú E] (p : Seminorm ùïú E) (x : E) (r : ‚Ñù)

/-- Seminorm-balls are convex. -/
theorem convex_ball : Convex ‚Ñù (Ball p x r) := by
  convert (p.convex_on.translate_left (-x)).convex_lt r
  ext y
  rw [preimage_univ, sep_univ, p.mem_ball, sub_eq_add_neg]
  rfl

end Module

end Convex

end Seminorm

/-! ### The norm as a seminorm -/


section normSeminorm

variable (ùïú) (E) [NormedField ùïú] [SemiNormedGroup E] [NormedSpace ùïú E] {r : ‚Ñù}

/-- The norm of a seminormed group as an add_monoid seminorm. -/
def normAddGroupSeminorm : AddGroupSeminorm E :=
  ‚ü®norm, norm_zero, norm_nonneg, norm_add_le, norm_neg‚ü©

@[simp]
theorem coe_norm_add_group_seminorm : ‚áë(normAddGroupSeminorm E) = norm :=
  rfl

/-- The norm of a seminormed group as a seminorm. -/
def normSeminorm : Seminorm ùïú E :=
  { normAddGroupSeminorm E with smul' := norm_smul }

@[simp]
theorem coe_norm_seminorm : ‚áë(normSeminorm ùïú E) = norm :=
  rfl

@[simp]
theorem ball_norm_seminorm : (normSeminorm ùïú E).ball = Metric.Ball := by
  ext x r y
  simp only [‚Üê Seminorm.mem_ball, ‚Üê Metric.mem_ball, ‚Üê coe_norm_seminorm, ‚Üê dist_eq_norm]

variable {ùïú E} {x : E}

/-- Balls at the origin are absorbent. -/
theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ùïú (Metric.Ball (0 : E) r) := by
  rw [‚Üê ball_norm_seminorm ùïú]
  exact (normSeminorm _ _).absorbent_ball_zero hr

/-- Balls containing the origin are absorbent. -/
theorem absorbent_ball (hx : ‚à•x‚à• < r) : Absorbent ùïú (Metric.Ball x r) := by
  rw [‚Üê ball_norm_seminorm ùïú]
  exact (normSeminorm _ _).absorbent_ball hx

/-- Balls at the origin are balanced. -/
theorem balanced_ball_zero : Balanced ùïú (Metric.Ball (0 : E) r) := by
  rw [‚Üê ball_norm_seminorm ùïú]
  exact (normSeminorm _ _).balanced_ball_zero r

end normSeminorm

