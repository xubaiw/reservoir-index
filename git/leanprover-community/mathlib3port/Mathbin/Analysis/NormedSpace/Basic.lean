/-
Copyright (c) 2018 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot, Johannes H√∂lzl
-/
import Mathbin.Analysis.Normed.Field.Basic
import Mathbin.Analysis.Normed.Group.InfiniteSum
import Mathbin.Data.Real.Sqrt
import Mathbin.Data.Matrix.Basic
import Mathbin.Topology.Sequences

/-!
# Normed spaces

In this file we define (semi)normed spaces and algebras. We also prove some theorems
about these definitions.
-/


variable {Œ± : Type _} {Œ≤ : Type _} {Œ≥ : Type _} {Œπ : Type _}

noncomputable section

open Filter Metric Function Set

open TopologicalSpace BigOperators Nnreal Ennreal uniformity Pointwise

section SeminormedAddCommGroup

section Prio

-- ./././Mathport/Syntax/Translate/Basic.lean:335:40: warning: unsupported option extends_priority
set_option extends_priority 920

-- Here, we set a rather high priority for the instance `[normed_space Œ± Œ≤] : module Œ± Œ≤`
-- to take precedence over `semiring.to_module` as this leads to instance paths with better
-- unification properties.
/-- A normed space over a normed field is a vector space endowed with a norm which satisfies the
equality `‚à•c ‚Ä¢ x‚à• = ‚à•c‚à• ‚à•x‚à•`. We require only `‚à•c ‚Ä¢ x‚à• ‚â§ ‚à•c‚à• ‚à•x‚à•` in the definition, then prove
`‚à•c ‚Ä¢ x‚à• = ‚à•c‚à• ‚à•x‚à•` in `norm_smul`.

Note that since this requires `seminormed_add_comm_group` and not `normed_add_comm_group`, this
typeclass can be used for "semi normed spaces" too, just as `module` can be used for
"semi modules". -/
class NormedSpace (Œ± : Type _) (Œ≤ : Type _) [NormedField Œ±] [SeminormedAddCommGroup Œ≤] extends Module Œ± Œ≤ where
  norm_smul_le : ‚àÄ (a : Œ±) (b : Œ≤), ‚à•a ‚Ä¢ b‚à• ‚â§ ‚à•a‚à• * ‚à•b‚à•

end Prio

variable [NormedField Œ±] [SeminormedAddCommGroup Œ≤]

-- see Note [lower instance priority]
instance (priority := 100) NormedSpace.has_bounded_smul [NormedSpace Œ± Œ≤] : HasBoundedSmul Œ± Œ≤ where
  dist_smul_pair' := fun x y‚ÇÅ y‚ÇÇ => by
    simpa [dist_eq_norm, smul_sub] using NormedSpace.norm_smul_le x (y‚ÇÅ - y‚ÇÇ)
  dist_pair_smul' := fun x‚ÇÅ x‚ÇÇ y => by
    simpa [dist_eq_norm, sub_smul] using NormedSpace.norm_smul_le (x‚ÇÅ - x‚ÇÇ) y

instance NormedField.toNormedSpace : NormedSpace Œ± Œ± where norm_smul_le := fun a b => le_of_eq‚Çì (norm_mul a b)

theorem norm_smul [NormedSpace Œ± Œ≤] (s : Œ±) (x : Œ≤) : ‚à•s ‚Ä¢ x‚à• = ‚à•s‚à• * ‚à•x‚à• := by
  by_cases' h : s = 0
  ¬∑ simp [h]
    
  ¬∑ refine' le_antisymm‚Çì (NormedSpace.norm_smul_le s x) _
    calc
      ‚à•s‚à• * ‚à•x‚à• = ‚à•s‚à• * ‚à•s‚Åª¬π ‚Ä¢ s ‚Ä¢ x‚à• := by
        rw [inv_smul_smul‚ÇÄ h]
      _ ‚â§ ‚à•s‚à• * (‚à•s‚Åª¬π‚à• * ‚à•s ‚Ä¢ x‚à•) := mul_le_mul_of_nonneg_left (NormedSpace.norm_smul_le _ _) (norm_nonneg _)
      _ = ‚à•s ‚Ä¢ x‚à• := by
        rw [norm_inv, ‚Üê mul_assoc, mul_inv_cancel (mt norm_eq_zero.1 h), one_mul‚Çì]
      
    

@[simp]
theorem abs_norm_eq_norm (z : Œ≤) : abs ‚à•z‚à• = ‚à•z‚à• :=
  (abs_eq (norm_nonneg z)).mpr (Or.inl rfl)

theorem inv_norm_smul_mem_closed_unit_ball [NormedSpace ‚Ñù Œ≤] (x : Œ≤) : ‚à•x‚à•‚Åª¬π ‚Ä¢ x ‚àà ClosedBall (0 : Œ≤) 1 := by
  simp only [mem_closed_ball_zero_iff, norm_smul, norm_inv, norm_norm, ‚Üê div_eq_inv_mul, div_self_le_one]

theorem dist_smul [NormedSpace Œ± Œ≤] (s : Œ±) (x y : Œ≤) : dist (s ‚Ä¢ x) (s ‚Ä¢ y) = ‚à•s‚à• * dist x y := by
  simp only [dist_eq_norm, (norm_smul _ _).symm, smul_sub]

theorem nnnorm_smul [NormedSpace Œ± Œ≤] (s : Œ±) (x : Œ≤) : ‚à•s ‚Ä¢ x‚à•‚Çä = ‚à•s‚à•‚Çä * ‚à•x‚à•‚Çä :=
  Nnreal.eq <| norm_smul s x

theorem nndist_smul [NormedSpace Œ± Œ≤] (s : Œ±) (x y : Œ≤) : nndist (s ‚Ä¢ x) (s ‚Ä¢ y) = ‚à•s‚à•‚Çä * nndist x y :=
  Nnreal.eq <| dist_smul s x y

theorem lipschitz_with_smul [NormedSpace Œ± Œ≤] (s : Œ±) : LipschitzWith ‚à•s‚à•‚Çä ((¬∑ ‚Ä¢ ¬∑) s : Œ≤ ‚Üí Œ≤) :=
  lipschitz_with_iff_dist_le_mul.2 fun x y => by
    rw [dist_smul, coe_nnnorm]

theorem norm_smul_of_nonneg [NormedSpace ‚Ñù Œ≤] {t : ‚Ñù} (ht : 0 ‚â§ t) (x : Œ≤) : ‚à•t ‚Ä¢ x‚à• = t * ‚à•x‚à• := by
  rw [norm_smul, Real.norm_eq_abs, abs_of_nonneg ht]

variable {E : Type _} [SeminormedAddCommGroup E] [NormedSpace Œ± E]

variable {F : Type _} [SeminormedAddCommGroup F] [NormedSpace Œ± F]

theorem eventually_nhds_norm_smul_sub_lt (c : Œ±) (x : E) {Œµ : ‚Ñù} (h : 0 < Œµ) : ‚àÄ·∂† y in ùìù x, ‚à•c ‚Ä¢ (y - x)‚à• < Œµ :=
  have : Tendsto (fun y => ‚à•c ‚Ä¢ (y - x)‚à•) (ùìù x) (ùìù 0) :=
    ((continuous_id.sub continuous_const).const_smul _).norm.tendsto' _ _
      (by
        simp )
  this.Eventually (gt_mem_nhds h)

theorem Filter.Tendsto.zero_smul_is_bounded_under_le {f : Œπ ‚Üí Œ±} {g : Œπ ‚Üí E} {l : Filter Œπ} (hf : Tendsto f l (ùìù 0))
    (hg : IsBoundedUnder (¬∑ ‚â§ ¬∑) l (norm ‚àò g)) : Tendsto (fun x => f x ‚Ä¢ g x) l (ùìù 0) :=
  hf.op_zero_is_bounded_under_le hg (¬∑ ‚Ä¢ ¬∑) fun x y => (norm_smul x y).le

theorem Filter.IsBoundedUnder.smul_tendsto_zero {f : Œπ ‚Üí Œ±} {g : Œπ ‚Üí E} {l : Filter Œπ}
    (hf : IsBoundedUnder (¬∑ ‚â§ ¬∑) l (norm ‚àò f)) (hg : Tendsto g l (ùìù 0)) : Tendsto (fun x => f x ‚Ä¢ g x) l (ùìù 0) :=
  hg.op_zero_is_bounded_under_le hf (flip (¬∑ ‚Ä¢ ¬∑)) fun x y => ((norm_smul y x).trans (mul_comm _ _)).le

theorem closure_ball [NormedSpace ‚Ñù E] (x : E) {r : ‚Ñù} (hr : r ‚â† 0) : Closure (Ball x r) = ClosedBall x r := by
  refine' subset.antisymm closure_ball_subset_closed_ball fun y hy => _
  have : ContinuousWithinAt (fun c : ‚Ñù => c ‚Ä¢ (y - x) + x) (Ico 0 1) 1 :=
    ((continuous_id.smul continuous_const).add continuous_const).ContinuousWithinAt
  convert this.mem_closure _ _
  ¬∑ rw [one_smul, sub_add_cancel]
    
  ¬∑ simp [closure_Ico (@zero_ne_one ‚Ñù _ _), zero_le_one]
    
  ¬∑ rintro c ‚ü®hc0, hc1‚ü©
    rw [mem_ball, dist_eq_norm, add_sub_cancel, norm_smul, Real.norm_eq_abs, abs_of_nonneg hc0, mul_comm, ‚Üê mul_one‚Çì r]
    rw [mem_closed_ball, dist_eq_norm] at hy
    replace hr : 0 < r
    exact ((norm_nonneg _).trans hy).lt_of_ne hr.symm
    apply mul_lt_mul' <;> assumption
    

theorem frontier_ball [NormedSpace ‚Ñù E] (x : E) {r : ‚Ñù} (hr : r ‚â† 0) : Frontier (Ball x r) = Sphere x r := by
  rw [Frontier, closure_ball x hr, is_open_ball.interior_eq]
  ext x
  exact (@eq_iff_le_not_lt‚Çì ‚Ñù _ _ _).symm

theorem interior_closed_ball [NormedSpace ‚Ñù E] (x : E) {r : ‚Ñù} (hr : r ‚â† 0) : Interior (ClosedBall x r) = Ball x r := by
  cases' hr.lt_or_lt with hr hr
  ¬∑ rw [closed_ball_eq_empty.2 hr, ball_eq_empty.2 hr.le, interior_empty]
    
  refine' subset.antisymm _ ball_subset_interior_closed_ball
  intro y hy
  rcases(mem_closed_ball.1 <| interior_subset hy).lt_or_eq with (hr | rfl)
  ¬∑ exact hr
    
  set f : ‚Ñù ‚Üí E := fun c : ‚Ñù => c ‚Ä¢ (y - x) + x
  suffices f ‚Åª¬π' closed_ball x (dist y x) ‚äÜ Icc (-1) 1 by
    have hfc : Continuous f := (continuous_id.smul continuous_const).add continuous_const
    have hf1 : (1 : ‚Ñù) ‚àà f ‚Åª¬π' Interior (closed_ball x <| dist y x) := by
      simpa [f]
    have h1 : (1 : ‚Ñù) ‚àà Interior (Icc (-1 : ‚Ñù) 1) :=
      interior_mono this (preimage_interior_subset_interior_preimage hfc hf1)
    contrapose h1
    simp
  intro c hc
  rw [mem_Icc, ‚Üê abs_le, ‚Üê Real.norm_eq_abs, ‚Üê mul_le_mul_right hr]
  simpa [f, dist_eq_norm, norm_smul] using hc

theorem frontier_closed_ball [NormedSpace ‚Ñù E] (x : E) {r : ‚Ñù} (hr : r ‚â† 0) : Frontier (ClosedBall x r) = Sphere x r :=
  by
  rw [Frontier, closure_closed_ball, interior_closed_ball x hr, closed_ball_diff_ball]

-- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:64:14: unsupported tactic `positivity #[]
-- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:64:14: unsupported tactic `positivity #[]
-- ./././Mathport/Syntax/Translate/Tactic/Builtin.lean:64:14: unsupported tactic `positivity #[]
/-- A (semi) normed real vector space is homeomorphic to the unit ball in the same space.
This homeomorphism sends `x : E` to `(1 + ‚à•x‚à•¬≤)^(- ¬Ω) ‚Ä¢ x`.

In many cases the actual implementation is not important, so we don't mark the projection lemmas
`homeomorph_unit_ball_apply_coe` and `homeomorph_unit_ball_symm_apply` as `@[simp]`.

See also `cont_diff_homeomorph_unit_ball` and `cont_diff_on_homeomorph_unit_ball_symm` for
smoothness properties that hold when `E` is an inner-product space. -/
@[simps (config := { attrs := [] })]
def homeomorphUnitBall [NormedSpace ‚Ñù E] : E ‚âÉ‚Çú Ball (0 : E) 1 where
  toFun := fun x =>
    ‚ü®(1 + ‚à•x‚à• ^ 2).sqrt‚Åª¬π ‚Ä¢ x, by
      have : 0 < 1 + ‚à•x‚à• ^ 2 := by
        trace "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:64:14: unsupported tactic `positivity #[]"
      rw [mem_ball_zero_iff, norm_smul, Real.norm_eq_abs, abs_inv, ‚Üê div_eq_inv_mul,
        div_lt_one (abs_pos.mpr <| real.sqrt_ne_zero'.mpr this), ‚Üê abs_norm_eq_norm x, ‚Üê sq_lt_sq, abs_norm_eq_norm,
        Real.sq_sqrt this.le]
      exact lt_one_add _‚ü©
  invFun := fun y => (1 - ‚à•(y : E)‚à• ^ 2).sqrt‚Åª¬π ‚Ä¢ (y : E)
  left_inv := fun x => by
    have : 0 < 1 + ‚à•x‚à• ^ 2 := by
      trace "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:64:14: unsupported tactic `positivity #[]"
    field_simp [norm_smul, smul_smul, this.ne', Real.sq_sqrt this.le, ‚Üê Real.sqrt_div this.le]
  right_inv := fun y => by
    have : 0 < 1 - ‚à•(y : E)‚à• ^ 2 := by
      nlinarith [norm_nonneg (y : E), (mem_ball_zero_iff.1 y.2 : ‚à•(y : E)‚à• < 1)]
    field_simp [norm_smul, smul_smul, this.ne', Real.sq_sqrt this.le, ‚Üê Real.sqrt_div this.le]
  continuous_to_fun :=
    continuous_subtype_mk _ <| by
      suffices Continuous fun x => (1 + ‚à•x‚à• ^ 2).sqrt‚Åª¬π by
        exact this.smul continuous_id
      refine'
        Continuous.inv‚ÇÄ _ fun x =>
          real.sqrt_ne_zero'.mpr
            (by
              trace "./././Mathport/Syntax/Translate/Tactic/Builtin.lean:64:14: unsupported tactic `positivity #[]")
      continuity
  continuous_inv_fun := by
    suffices ‚àÄ y : ball (0 : E) 1, (1 - ‚à•(y : E)‚à• ^ 2).sqrt ‚â† 0 by
      continuity
    intro y
    rw [Real.sqrt_ne_zero']
    nlinarith [norm_nonneg (y : E), (mem_ball_zero_iff.1 y.2 : ‚à•(y : E)‚à• < 1)]

@[simp]
theorem coe_homeomorph_unit_ball_apply_zero [NormedSpace ‚Ñù E] : (homeomorphUnitBall (0 : E) : E) = 0 := by
  simp [homeomorphUnitBall]

open NormedField

instance : NormedSpace Œ± (ULift E) :=
  { ULift.normedAddCommGroup, ULift.module' with norm_smul_le := fun s x => (NormedSpace.norm_smul_le s x.down : _) }

/-- The product of two normed spaces is a normed space, with the sup norm. -/
instance Prod.normedSpace : NormedSpace Œ± (E √ó F) :=
  { Prod.normedAddCommGroup, Prod.module with
    norm_smul_le := fun s x =>
      le_of_eq‚Çì <| by
        simp [Prod.norm_def, norm_smul, mul_max_of_nonneg] }

/-- The product of finitely many normed spaces is a normed space, with the sup norm. -/
instance Pi.normedSpace {E : Œπ ‚Üí Type _} [Fintype Œπ] [‚àÄ i, SeminormedAddCommGroup (E i)] [‚àÄ i, NormedSpace Œ± (E i)] :
    NormedSpace Œ±
      (‚àÄ i,
        E
          i) where norm_smul_le := fun a f =>
    le_of_eq‚Çì <|
      show
        (‚Üë(Finset.sup Finset.univ fun b : Œπ => ‚à•a ‚Ä¢ f b‚à•‚Çä) : ‚Ñù) = ‚à•a‚à•‚Çä * ‚Üë(Finset.sup Finset.univ fun b : Œπ => ‚à•f b‚à•‚Çä)
        by
        simp only [(Nnreal.coe_mul _ _).symm, Nnreal.mul_finset_sup, nnnorm_smul]

/-- A subspace of a normed space is also a normed space, with the restriction of the norm. -/
instance Submodule.normedSpace {ùïú R : Type _} [HasSmul ùïú R] [NormedField ùïú] [Ring‚Çì R] {E : Type _}
    [SeminormedAddCommGroup E] [NormedSpace ùïú E] [Module R E] [IsScalarTower ùïú R E] (s : Submodule R E) :
    NormedSpace ùïú s where norm_smul_le := fun c x => le_of_eq‚Çì <| norm_smul c (x : E)

/-- If there is a scalar `c` with `‚à•c‚à•>1`, then any element with nonzero norm can be
moved by scalar multiplication to any shell of width `‚à•c‚à•`. Also recap information on the norm of
the rescaling element that shows up in applications. -/
theorem rescale_to_shell_semi_normed {c : Œ±} (hc : 1 < ‚à•c‚à•) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) {x : E} (hx : ‚à•x‚à• ‚â† 0) :
    ‚àÉ d : Œ±, d ‚â† 0 ‚àß ‚à•d ‚Ä¢ x‚à• < Œµ ‚àß Œµ / ‚à•c‚à• ‚â§ ‚à•d ‚Ä¢ x‚à• ‚àß ‚à•d‚à•‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à• := by
  have xŒµpos : 0 < ‚à•x‚à• / Œµ := div_pos ((Ne.symm hx).le_iff_lt.1 (norm_nonneg x)) Œµpos
  rcases exists_mem_Ico_zpow xŒµpos hc with ‚ü®n, hn‚ü©
  have cpos : 0 < ‚à•c‚à• := lt_trans‚Çì (zero_lt_one : (0 : ‚Ñù) < 1) hc
  have cnpos : 0 < ‚à•c ^ (n + 1)‚à• := by
    rw [norm_zpow]
    exact lt_trans‚Çì xŒµpos hn.2
  refine' ‚ü®(c ^ (n + 1))‚Åª¬π, _, _, _, _‚ü©
  show (c ^ (n + 1))‚Åª¬π ‚â† 0
  ¬∑ rwa [Ne.def, inv_eq_zero, ‚Üê Ne.def, ‚Üê norm_pos_iff]
    
  show ‚à•(c ^ (n + 1))‚Åª¬π ‚Ä¢ x‚à• < Œµ
  ¬∑ rw [norm_smul, norm_inv, ‚Üê div_eq_inv_mul, div_lt_iff cnpos, mul_comm, norm_zpow]
    exact (div_lt_iff Œµpos).1 hn.2
    
  show Œµ / ‚à•c‚à• ‚â§ ‚à•(c ^ (n + 1))‚Åª¬π ‚Ä¢ x‚à•
  ¬∑ rw [div_le_iff cpos, norm_smul, norm_inv, norm_zpow, zpow_add‚ÇÄ (ne_of_gt‚Çì cpos), zpow_one, mul_inv_rev, mul_comm, ‚Üê
      mul_assoc, ‚Üê mul_assoc, mul_inv_cancel (ne_of_gt‚Çì cpos), one_mul‚Çì, ‚Üê div_eq_inv_mul,
      le_div_iff (zpow_pos_of_pos cpos _), mul_comm]
    exact (le_div_iff Œµpos).1 hn.1
    
  show ‚à•(c ^ (n + 1))‚Åª¬π‚à•‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à•
  ¬∑ have : Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à• = Œµ‚Åª¬π * ‚à•x‚à• * ‚à•c‚à• := by
      ring
    rw [norm_inv, inv_inv‚Çì, norm_zpow, zpow_add‚ÇÄ (ne_of_gt‚Çì cpos), zpow_one, this, ‚Üê div_eq_inv_mul]
    exact mul_le_mul_of_nonneg_right hn.1 (norm_nonneg _)
    

end SeminormedAddCommGroup

section NormedAddCommGroup

variable [NormedField Œ±]

variable {E : Type _} [NormedAddCommGroup E] [NormedSpace Œ± E]

variable {F : Type _} [NormedAddCommGroup F] [NormedSpace Œ± F]

open NormedField

/-- While this may appear identical to `normed_space.to_module`, it contains an implicit argument
involving `normed_add_comm_group.to_seminormed_add_comm_group` that typeclass inference has trouble
inferring.

Specifically, the following instance cannot be found without this `normed_space.to_module'`:
```lean
example
  (ùïú Œπ : Type*) (E : Œπ ‚Üí Type*)
  [normed_field ùïú] [Œ† i, normed_add_comm_group (E i)] [Œ† i, normed_space ùïú (E i)] :
  Œ† i, module ùïú (E i) := by apply_instance
```

[This Zulip thread](https://leanprover.zulipchat.com/#narrow/stream/113488-general/topic/Typeclass.20resolution.20under.20binders/near/245151099)
gives some more context. -/
instance (priority := 100) NormedSpace.toModule' : Module Œ± F :=
  NormedSpace.toModule

section Surj

variable (E) [NormedSpace ‚Ñù E] [Nontrivial E]

theorem exists_norm_eq {c : ‚Ñù} (hc : 0 ‚â§ c) : ‚àÉ x : E, ‚à•x‚à• = c := by
  rcases exists_ne (0 : E) with ‚ü®x, hx‚ü©
  rw [‚Üê norm_ne_zero_iff] at hx
  use c ‚Ä¢ ‚à•x‚à•‚Åª¬π ‚Ä¢ x
  simp [norm_smul, Real.norm_of_nonneg hc, hx]

@[simp]
theorem range_norm : Range (norm : E ‚Üí ‚Ñù) = Ici 0 :=
  Subset.antisymm (range_subset_iff.2 norm_nonneg) fun _ => exists_norm_eq E

theorem nnnorm_surjective : Surjective (nnnorm : E ‚Üí ‚Ñù‚â•0 ) := fun c =>
  (exists_norm_eq E c.coe_nonneg).imp fun x h => Nnreal.eq h

@[simp]
theorem range_nnnorm : Range (nnnorm : E ‚Üí ‚Ñù‚â•0 ) = univ :=
  (nnnorm_surjective E).range_eq

end Surj

theorem interior_closed_ball' [NormedSpace ‚Ñù E] [Nontrivial E] (x : E) (r : ‚Ñù) : Interior (ClosedBall x r) = Ball x r :=
  by
  rcases eq_or_ne r 0 with (rfl | hr)
  ¬∑ rw [closed_ball_zero, ball_zero, interior_singleton]
    
  ¬∑ exact interior_closed_ball x hr
    

theorem frontier_closed_ball' [NormedSpace ‚Ñù E] [Nontrivial E] (x : E) (r : ‚Ñù) :
    Frontier (ClosedBall x r) = Sphere x r := by
  rw [Frontier, closure_closed_ball, interior_closed_ball' x r, closed_ball_diff_ball]

variable {Œ±}

/-- If there is a scalar `c` with `‚à•c‚à•>1`, then any element can be moved by scalar multiplication to
any shell of width `‚à•c‚à•`. Also recap information on the norm of the rescaling element that shows
up in applications. -/
theorem rescale_to_shell {c : Œ±} (hc : 1 < ‚à•c‚à•) {Œµ : ‚Ñù} (Œµpos : 0 < Œµ) {x : E} (hx : x ‚â† 0) :
    ‚àÉ d : Œ±, d ‚â† 0 ‚àß ‚à•d ‚Ä¢ x‚à• < Œµ ‚àß Œµ / ‚à•c‚à• ‚â§ ‚à•d ‚Ä¢ x‚à• ‚àß ‚à•d‚à•‚Åª¬π ‚â§ Œµ‚Åª¬π * ‚à•c‚à• * ‚à•x‚à• :=
  rescale_to_shell_semi_normed hc Œµpos (ne_of_lt‚Çì (norm_pos_iff.2 hx)).symm

end NormedAddCommGroup

section NontriviallyNormedSpace

variable (ùïú E : Type _) [NontriviallyNormedField ùïú] [NormedAddCommGroup E] [NormedSpace ùïú E] [Nontrivial E]

include ùïú

/-- If `E` is a nontrivial normed space over a nontrivially normed field `ùïú`, then `E` is unbounded:
for any `c : ‚Ñù`, there exists a vector `x : E` with norm strictly greater than `c`. -/
theorem NormedSpace.exists_lt_norm (c : ‚Ñù) : ‚àÉ x : E, c < ‚à•x‚à• := by
  rcases exists_ne (0 : E) with ‚ü®x, hx‚ü©
  rcases NormedField.exists_lt_norm ùïú (c / ‚à•x‚à•) with ‚ü®r, hr‚ü©
  use r ‚Ä¢ x
  rwa [norm_smul, ‚Üê div_lt_iff]
  rwa [norm_pos_iff]

protected theorem NormedSpace.unbounded_univ : ¬¨Bounded (Univ : Set E) := fun h =>
  let ‚ü®R, hR‚ü© := bounded_iff_forall_norm_le.1 h
  let ‚ü®x, hx‚ü© := NormedSpace.exists_lt_norm ùïú E R
  hx.not_le (hR x trivial‚Çì)

/-- A normed vector space over a nontrivially normed field is a noncompact space. This cannot be
an instance because in order to apply it, Lean would have to search for `normed_space ùïú E` with
unknown `ùïú`. We register this as an instance in two cases: `ùïú = E` and `ùïú = ‚Ñù`. -/
protected theorem NormedSpace.noncompact_space : NoncompactSpace E :=
  ‚ü®fun h => NormedSpace.unbounded_univ ùïú _ h.Bounded‚ü©

instance (priority := 100) NontriviallyNormedField.noncompact_space : NoncompactSpace ùïú :=
  NormedSpace.noncompact_space ùïú ùïú

omit ùïú

instance (priority := 100) RealNormedSpace.noncompact_space [NormedSpace ‚Ñù E] : NoncompactSpace E :=
  NormedSpace.noncompact_space ‚Ñù E

end NontriviallyNormedSpace

section NormedAlgebra

/-- A normed algebra `ùïú'` over `ùïú` is normed module that is also an algebra.

See the implementation notes for `algebra` for a discussion about non-unital algebras. Following
the strategy there, a non-unital *normed* algebra can be written as:
```lean
variables [normed_field ùïú] [non_unital_semi_normed_ring ùïú']
variables [normed_module ùïú ùïú'] [smul_comm_class ùïú ùïú' ùïú'] [is_scalar_tower ùïú ùïú' ùïú']
```
-/
class NormedAlgebra (ùïú : Type _) (ùïú' : Type _) [NormedField ùïú] [SemiNormedRing ùïú'] extends Algebra ùïú ùïú' where
  norm_smul_le : ‚àÄ (r : ùïú) (x : ùïú'), ‚à•r ‚Ä¢ x‚à• ‚â§ ‚à•r‚à• * ‚à•x‚à•

variable {ùïú : Type _} (ùïú' : Type _) [NormedField ùïú] [SemiNormedRing ùïú'] [NormedAlgebra ùïú ùïú']

instance (priority := 100) NormedAlgebra.toNormedSpace :
    NormedSpace ùïú ùïú' where norm_smul_le := NormedAlgebra.norm_smul_le

/-- While this may appear identical to `normed_algebra.to_normed_space`, it contains an implicit
argument involving `normed_ring.to_semi_normed_ring` that typeclass inference has trouble inferring.

Specifically, the following instance cannot be found without this `normed_space.to_module'`:
```lean
example
  (ùïú Œπ : Type*) (E : Œπ ‚Üí Type*)
  [normed_field ùïú] [Œ† i, normed_ring (E i)] [Œ† i, normed_algebra ùïú (E i)] :
  Œ† i, module ùïú (E i) := by apply_instance
```

See `normed_space.to_module'` for a similar situation. -/
instance (priority := 100) NormedAlgebra.toNormedSpace' {ùïú'} [NormedRing ùïú'] [NormedAlgebra ùïú ùïú'] : NormedSpace ùïú ùïú' :=
  by
  infer_instance

theorem norm_algebra_map (x : ùïú) : ‚à•algebraMap ùïú ùïú' x‚à• = ‚à•x‚à• * ‚à•(1 : ùïú')‚à• := by
  rw [Algebra.algebra_map_eq_smul_one]
  exact norm_smul _ _

theorem nnnorm_algebra_map (x : ùïú) : ‚à•algebraMap ùïú ùïú' x‚à•‚Çä = ‚à•x‚à•‚Çä * ‚à•(1 : ùïú')‚à•‚Çä :=
  Subtype.ext <| norm_algebra_map ùïú' x

@[simp]
theorem norm_algebra_map' [NormOneClass ùïú'] (x : ùïú) : ‚à•algebraMap ùïú ùïú' x‚à• = ‚à•x‚à• := by
  rw [norm_algebra_map, norm_one, mul_one‚Çì]

@[simp]
theorem nnnorm_algebra_map' [NormOneClass ùïú'] (x : ùïú) : ‚à•algebraMap ùïú ùïú' x‚à•‚Çä = ‚à•x‚à•‚Çä :=
  Subtype.ext <| norm_algebra_map' _ _

variable (ùïú ùïú')

/-- In a normed algebra, the inclusion of the base field in the extended field is an isometry. -/
theorem algebra_map_isometry [NormOneClass ùïú'] : Isometry (algebraMap ùïú ùïú') := by
  refine' Isometry.of_dist_eq fun x y => _
  rw [dist_eq_norm, dist_eq_norm, ‚Üê RingHom.map_sub, norm_algebra_map']

/-- The inclusion of the base field in a normed algebra as a continuous linear map. -/
@[simps]
def algebraMapClm : ùïú ‚ÜíL[ùïú] ùïú' where
  toFun := algebraMap ùïú ùïú'
  map_add' := (algebraMap ùïú ùïú').map_add
  map_smul' := fun r x => by
    rw [Algebra.id.smul_eq_mul, map_mul, RingHom.id_apply, Algebra.smul_def]
  cont :=
    have : LipschitzWith ‚à•(1 : ùïú')‚à•‚Çä (algebraMap ùïú ùïú') := fun x y => by
      rw [edist_eq_coe_nnnorm_sub, edist_eq_coe_nnnorm_sub, ‚Üê map_sub, ‚Üê Ennreal.coe_mul, Ennreal.coe_le_coe, mul_comm]
      exact (nnnorm_algebra_map _ _).le
    this.Continuous

theorem algebra_map_clm_coe : (algebraMapClm ùïú ùïú' : ùïú ‚Üí ùïú') = (algebraMap ùïú ùïú' : ùïú ‚Üí ùïú') :=
  rfl

theorem algebra_map_clm_to_linear_map : (algebraMapClm ùïú ùïú').toLinearMap = Algebra.linearMap ùïú ùïú' :=
  rfl

instance NormedAlgebra.id : NormedAlgebra ùïú ùïú :=
  { NormedField.toNormedSpace, Algebra.id ùïú with }

/-- Any normed characteristic-zero division ring that is a normed_algebra over the reals is also a
normed algebra over the rationals.

Phrased another way, if `ùïú` is a normed algebra over the reals, then `algebra_rat` respects that
norm. -/
instance normedAlgebraRat {ùïú} [NormedDivisionRing ùïú] [CharZero ùïú] [NormedAlgebra ‚Ñù ùïú] :
    NormedAlgebra ‚Ñö ùïú where norm_smul_le := fun q x => by
    rw [‚Üê smul_one_smul ‚Ñù q x, Rat.smul_one_eq_coe, norm_smul, Rat.norm_cast_real]

instance PUnit.normedAlgebra :
    NormedAlgebra ùïú PUnit where norm_smul_le := fun q x => by
    simp only [PUnit.norm_eq_zero, mul_zero]

instance : NormedAlgebra ùïú (ULift ùïú') :=
  { ULift.normedSpace with }

/-- The product of two normed algebras is a normed algebra, with the sup norm. -/
instance Prod.normedAlgebra {E F : Type _} [SemiNormedRing E] [SemiNormedRing F] [NormedAlgebra ùïú E]
    [NormedAlgebra ùïú F] : NormedAlgebra ùïú (E √ó F) :=
  { Prod.normedSpace with }

/-- The product of finitely many normed algebras is a normed algebra, with the sup norm. -/
instance Pi.normedAlgebra {E : Œπ ‚Üí Type _} [Fintype Œπ] [‚àÄ i, SemiNormedRing (E i)] [‚àÄ i, NormedAlgebra ùïú (E i)] :
    NormedAlgebra ùïú (‚àÄ i, E i) :=
  { Pi.normedSpace, Pi.algebra _ E with }

end NormedAlgebra

section RestrictScalars

variable (ùïú : Type _) (ùïú' : Type _) [NormedField ùïú] [NormedField ùïú'] [NormedAlgebra ùïú ùïú'] (E : Type _)
  [SeminormedAddCommGroup E] [NormedSpace ùïú' E]

instance {ùïú : Type _} {ùïú' : Type _} {E : Type _} [I : SeminormedAddCommGroup E] :
    SeminormedAddCommGroup (RestrictScalars ùïú ùïú' E) :=
  I

instance {ùïú : Type _} {ùïú' : Type _} {E : Type _} [I : NormedAddCommGroup E] :
    NormedAddCommGroup (RestrictScalars ùïú ùïú' E) :=
  I

/-- If `E` is a normed space over `ùïú'` and `ùïú` is a normed algebra over `ùïú'`, then
`restrict_scalars.module` is additionally a `normed_space`. -/
instance : NormedSpace ùïú (RestrictScalars ùïú ùïú' E) :=
  { RestrictScalars.module ùïú ùïú' E with
    norm_smul_le := fun c x =>
      (NormedSpace.norm_smul_le (algebraMap ùïú ùïú' c) (_ : E)).trans_eq <| by
        rw [norm_algebra_map'] }

-- If you think you need this, consider instead reproducing `restrict_scalars.lsmul`
-- appropriately modified here.
/-- The action of the original normed_field on `restrict_scalars ùïú ùïú' E`.
This is not an instance as it would be contrary to the purpose of `restrict_scalars`.
-/
def Module.RestrictScalars.normedSpaceOrig {ùïú : Type _} {ùïú' : Type _} {E : Type _} [NormedField ùïú']
    [SeminormedAddCommGroup E] [I : NormedSpace ùïú' E] : NormedSpace ùïú' (RestrictScalars ùïú ùïú' E) :=
  I

/-- Warning: This declaration should be used judiciously.
Please consider using `is_scalar_tower` and/or `restrict_scalars ùïú ùïú' E` instead.

This definition allows the `restrict_scalars.normed_space` instance to be put directly on `E`
rather on `restrict_scalars ùïú ùïú' E`. This would be a very bad instance; both because `ùïú'` cannot be
inferred, and because it is likely to create instance diamonds.
-/
def NormedSpace.restrictScalars : NormedSpace ùïú E :=
  RestrictScalars.normedSpace _ ùïú' _

end RestrictScalars

