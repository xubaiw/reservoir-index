/-
Copyright (c) 2020 S√©bastien Gou√´zel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: S√©bastien Gou√´zel, Floris van Doorn
-/
import Mathbin.Analysis.Calculus.IteratedDeriv
import Mathbin.Analysis.InnerProductSpace.EuclideanDist
import Mathbin.MeasureTheory.Function.LocallyIntegrable
import Mathbin.MeasureTheory.Integral.SetIntegral

/-!
# Infinitely smooth bump function

In this file we construct several infinitely smooth functions with properties that an analytic
function cannot have:

* `exp_neg_inv_glue` is equal to zero for `x ‚â§ 0` and is strictly positive otherwise; it is given by
  `x ‚Ü¶ exp (-1/x)` for `x > 0`;

* `real.smooth_transition` is equal to zero for `x ‚â§ 0` and is equal to one for `x ‚â• 1`; it is given
  by `exp_neg_inv_glue x / (exp_neg_inv_glue x + exp_neg_inv_glue (1 - x))`;

* `f : cont_diff_bump_of_inner c`, where `c` is a point in an inner product space, is
  a bundled smooth function such that

  - `f` is equal to `1` in `metric.closed_ball c f.r`;
  - `support f = metric.ball c f.R`;
  - `0 ‚â§ f x ‚â§ 1` for all `x`.

  The structure `cont_diff_bump_of_inner` contains the data required to construct the
  function: real numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available
  through `coe_fn`.

* If `f : cont_diff_bump_of_inner c` and `Œº` is a measure on the domain of `f`, then `f.normed Œº`
  is a smooth bump function with integral `1` w.r.t. `Œº`.

* `f : cont_diff_bump c`, where `c` is a point in a finite dimensional real vector space, is a
  bundled smooth function such that

  - `f` is equal to `1` in `euclidean.closed_ball c f.r`;
  - `support f = euclidean.ball c f.R`;
  - `0 ‚â§ f x ‚â§ 1` for all `x`.

  The structure `cont_diff_bump` contains the data required to construct the function: real
  numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available through `coe_fn`.
-/


noncomputable section

open Classical TopologicalSpace

open Polynomial Real Filter Set Function

/-- `exp_neg_inv_glue` is the real function given by `x ‚Ü¶ exp (-1/x)` for `x > 0` and `0`
for `x ‚â§ 0`. It is a basic building block to construct smooth partitions of unity. Its main property
is that it vanishes for `x ‚â§ 0`, it is positive for `x > 0`, and the junction between the two
behaviors is flat enough to retain smoothness. The fact that this function is `C^‚àû` is proved in
`exp_neg_inv_glue.smooth`. -/
def expNegInvGlue (x : ‚Ñù) : ‚Ñù :=
  if x ‚â§ 0 then 0 else exp (-x‚Åª¬π)

namespace expNegInvGlue

/-- Our goal is to prove that `exp_neg_inv_glue` is `C^‚àû`. For this, we compute its successive
derivatives for `x > 0`. The `n`-th derivative is of the form `P_aux n (x) exp(-1/x) / x^(2 n)`,
where `P_aux n` is computed inductively. -/
noncomputable def pAux : ‚Ñï ‚Üí Polynomial ‚Ñù
  | 0 => 1
  | n + 1 => X ^ 2 * (P_aux n).derivative + (1 - c ‚Üë(2 * n) * X) * P_aux n

/-- Formula for the `n`-th derivative of `exp_neg_inv_glue`, as an auxiliary function `f_aux`. -/
def fAux (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù :=
  if x ‚â§ 0 then 0 else (pAux n).eval x * exp (-x‚Åª¬π) / x ^ (2 * n)

/-- The `0`-th auxiliary function `f_aux 0` coincides with `exp_neg_inv_glue`, by definition. -/
theorem f_aux_zero_eq : fAux 0 = expNegInvGlue := by
  ext x
  by_cases' h : x ‚â§ 0
  ¬∑ simp [‚Üê expNegInvGlue, ‚Üê f_aux, ‚Üê h]
    
  ¬∑ simp [‚Üê h, ‚Üê expNegInvGlue, ‚Üê f_aux, ‚Üê ne_of_gt‚Çì (not_le‚Çì.1 h), ‚Üê P_aux]
    

/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`
(given in this statement in unfolded form) is the `n+1`-th auxiliary function, since
the polynomial `P_aux (n+1)` was chosen precisely to ensure this. -/
theorem f_aux_deriv (n : ‚Ñï) (x : ‚Ñù) (hx : x ‚â† 0) :
    HasDerivAt (fun x => (pAux n).eval x * exp (-x‚Åª¬π) / x ^ (2 * n))
      ((pAux (n + 1)).eval x * exp (-x‚Åª¬π) / x ^ (2 * (n + 1))) x :=
  by
  have A : ‚àÄ k : ‚Ñï, 2 * (k + 1) - 1 = 2 * k + 1 := fun k => rfl
  convert
    (((P_aux n).HasDerivAt x).mul ((has_deriv_at_exp _).comp x (has_deriv_at_inv hx).neg)).div
      (has_deriv_at_pow (2 * n) x) (pow_ne_zero _ hx) using
    1
  field_simp [‚Üê hx, ‚Üê P_aux]
  -- `ring_exp` can't solve `p ‚à® q` goal generated by `mul_eq_mul_right_iff`
    cases n <;>
    simp [‚Üê Nat.succ_eq_add_one, ‚Üê A, -mul_eq_mul_right_iff] <;> ring_exp

/-- For positive values, the derivative of the `n`-th auxiliary function `f_aux n`
is the `n+1`-th auxiliary function. -/
theorem f_aux_deriv_pos (n : ‚Ñï) (x : ‚Ñù) (hx : 0 < x) :
    HasDerivAt (fAux n) ((pAux (n + 1)).eval x * exp (-x‚Åª¬π) / x ^ (2 * (n + 1))) x := by
  apply (f_aux_deriv n x (ne_of_gt‚Çì hx)).congr_of_eventually_eq
  filter_upwards [lt_mem_nhds hx] with _ hy
  simp [‚Üê f_aux, ‚Üê hy.not_le]

/-- To get differentiability at `0` of the auxiliary functions, we need to know that their limit
is `0`, to be able to apply general differentiability extension theorems. This limit is checked in
this lemma. -/
theorem f_aux_limit (n : ‚Ñï) : Tendsto (fun x => (pAux n).eval x * exp (-x‚Åª¬π) / x ^ (2 * n)) (ùìù[>] 0) (ùìù 0) := by
  have A : tendsto (fun x => (P_aux n).eval x) (ùìù[>] 0) (ùìù ((P_aux n).eval 0)) := (P_aux n).ContinuousWithinAt
  have B : tendsto (fun x => exp (-x‚Åª¬π) / x ^ (2 * n)) (ùìù[>] 0) (ùìù 0) := by
    convert (tendsto_pow_mul_exp_neg_at_top_nhds_0 (2 * n)).comp tendsto_inv_zero_at_top
    ext x
    field_simp
  convert A.mul B <;> simp [‚Üê mul_div_assoc]

/-- Deduce from the limiting behavior at `0` of its derivative and general differentiability
extension theorems that the auxiliary function `f_aux n` is differentiable at `0`,
with derivative `0`. -/
theorem f_aux_deriv_zero (n : ‚Ñï) : HasDerivAt (fAux n) 0 0 := by
  -- we check separately differentiability on the left and on the right
  have A : HasDerivWithinAt (f_aux n) (0 : ‚Ñù) (Iic 0) 0 := by
    apply (has_deriv_at_const (0 : ‚Ñù) (0 : ‚Ñù)).HasDerivWithinAt.congr
    ¬∑ intro y hy
      simp at hy
      simp [‚Üê f_aux, ‚Üê hy]
      
    ¬∑ simp [‚Üê f_aux, ‚Üê le_refl‚Çì]
      
  have B : HasDerivWithinAt (f_aux n) (0 : ‚Ñù) (Ici 0) 0 := by
    have diff : DifferentiableOn ‚Ñù (f_aux n) (Ioi 0) := fun x hx =>
      (f_aux_deriv_pos n x hx).DifferentiableAt.DifferentiableWithinAt
    -- next line is the nontrivial bit of this proof, appealing to differentiability
    -- extension results.
    apply has_deriv_at_interval_left_endpoint_of_tendsto_deriv diff _ self_mem_nhds_within
    ¬∑ refine' (f_aux_limit (n + 1)).congr' _
      apply mem_of_superset self_mem_nhds_within fun x hx => _
      simp [‚Üê (f_aux_deriv_pos n x hx).deriv]
      
    ¬∑ have : f_aux n 0 = 0 := by
        simp [‚Üê f_aux, ‚Üê le_refl‚Çì]
      simp only [‚Üê ContinuousWithinAt, ‚Üê this]
      refine' (f_aux_limit n).congr' _
      apply mem_of_superset self_mem_nhds_within fun x hx => _
      have : ¬¨x ‚â§ 0 := by
        simpa using hx
      simp [‚Üê f_aux, ‚Üê this]
      
  simpa using A.union B

/-- At every point, the auxiliary function `f_aux n` has a derivative which is
equal to `f_aux (n+1)`. -/
theorem f_aux_has_deriv_at (n : ‚Ñï) (x : ‚Ñù) : HasDerivAt (fAux n) (fAux (n + 1) x) x := by
  -- check separately the result for `x < 0`, where it is trivial, for `x > 0`, where it is done
  -- in `f_aux_deriv_pos`, and for `x = 0`, done in
  -- `f_aux_deriv_zero`.
  rcases lt_trichotomy‚Çì x 0 with (hx | hx | hx)
  ¬∑ have : f_aux (n + 1) x = 0 := by
      simp [‚Üê f_aux, ‚Üê le_of_lt‚Çì hx]
    rw [this]
    apply (has_deriv_at_const x (0 : ‚Ñù)).congr_of_eventually_eq
    filter_upwards [gt_mem_nhds hx] with _ hy
    simp [‚Üê f_aux, ‚Üê hy.le]
    
  ¬∑ have : f_aux (n + 1) 0 = 0 := by
      simp [‚Üê f_aux, ‚Üê le_refl‚Çì]
    rw [hx, this]
    exact f_aux_deriv_zero n
    
  ¬∑ have : f_aux (n + 1) x = (P_aux (n + 1)).eval x * exp (-x‚Åª¬π) / x ^ (2 * (n + 1)) := by
      simp [‚Üê f_aux, ‚Üê not_le_of_gt‚Çì hx]
    rw [this]
    exact f_aux_deriv_pos n x hx
    

/-- The successive derivatives of the auxiliary function `f_aux 0` are the
functions `f_aux n`, by induction. -/
theorem f_aux_iterated_deriv (n : ‚Ñï) : iteratedDeriv n (fAux 0) = fAux n := by
  induction' n with n IH
  ¬∑ simp
    
  ¬∑ simp [‚Üê iterated_deriv_succ, ‚Üê IH]
    ext x
    exact (f_aux_has_deriv_at n x).deriv
    

/-- The function `exp_neg_inv_glue` is smooth. -/
protected theorem cont_diff {n} : ContDiff ‚Ñù n expNegInvGlue := by
  rw [‚Üê f_aux_zero_eq]
  apply cont_diff_of_differentiable_iterated_deriv fun m hm => _
  rw [f_aux_iterated_deriv m]
  exact fun x => (f_aux_has_deriv_at m x).DifferentiableAt

/-- The function `exp_neg_inv_glue` vanishes on `(-‚àû, 0]`. -/
theorem zero_of_nonpos {x : ‚Ñù} (hx : x ‚â§ 0) : expNegInvGlue x = 0 := by
  simp [‚Üê expNegInvGlue, ‚Üê hx]

/-- The function `exp_neg_inv_glue` is positive on `(0, +‚àû)`. -/
theorem pos_of_pos {x : ‚Ñù} (hx : 0 < x) : 0 < expNegInvGlue x := by
  simp [‚Üê expNegInvGlue, ‚Üê not_le‚Çì.2 hx, ‚Üê exp_pos]

/-- The function exp_neg_inv_glue` is nonnegative. -/
theorem nonneg (x : ‚Ñù) : 0 ‚â§ expNegInvGlue x := by
  cases le_or_gt‚Çì x 0
  ¬∑ exact ge_of_eq (zero_of_nonpos h)
    
  ¬∑ exact le_of_lt‚Çì (pos_of_pos h)
    

end expNegInvGlue

/-- An infinitely smooth function `f : ‚Ñù ‚Üí ‚Ñù` such that `f x = 0` for `x ‚â§ 0`,
`f x = 1` for `1 ‚â§ x`, and `0 < f x < 1` for `0 < x < 1`. -/
def Real.smoothTransition (x : ‚Ñù) : ‚Ñù :=
  expNegInvGlue x / (expNegInvGlue x + expNegInvGlue (1 - x))

namespace Real

namespace SmoothTransition

variable {x : ‚Ñù}

open expNegInvGlue

theorem pos_denom x : 0 < expNegInvGlue x + expNegInvGlue (1 - x) :=
  ((@zero_lt_one ‚Ñù _ _).lt_or_lt x).elim (fun hx => add_pos_of_pos_of_nonneg (pos_of_pos hx) (nonneg _)) fun hx =>
    add_pos_of_nonneg_of_pos (nonneg _) (pos_of_pos <| sub_pos.2 hx)

theorem one_of_one_le (h : 1 ‚â§ x) : smoothTransition x = 1 :=
  (div_eq_one_iff_eq <| (pos_denom x).ne').2 <| by
    rw [zero_of_nonpos (sub_nonpos.2 h), add_zero‚Çì]

theorem zero_of_nonpos (h : x ‚â§ 0) : smoothTransition x = 0 := by
  rw [smooth_transition, zero_of_nonpos h, zero_div]

@[simp]
protected theorem zero : smoothTransition 0 = 0 :=
  zero_of_nonpos le_rfl

@[simp]
protected theorem one : smoothTransition 1 = 1 :=
  one_of_one_le le_rfl

theorem le_one (x : ‚Ñù) : smoothTransition x ‚â§ 1 :=
  (div_le_one (pos_denom x)).2 <| le_add_of_nonneg_right (nonneg _)

theorem nonneg (x : ‚Ñù) : 0 ‚â§ smoothTransition x :=
  div_nonneg (expNegInvGlue.nonneg _) (pos_denom x).le

theorem lt_one_of_lt_one (h : x < 1) : smoothTransition x < 1 :=
  (div_lt_one <| pos_denom x).2 <| lt_add_of_pos_right _ <| pos_of_pos <| sub_pos.2 h

theorem pos_of_pos (h : 0 < x) : 0 < smoothTransition x :=
  div_pos (expNegInvGlue.pos_of_pos h) (pos_denom x)

protected theorem cont_diff {n} : ContDiff ‚Ñù n smoothTransition :=
  (expNegInvGlue.cont_diff.div
      (expNegInvGlue.cont_diff.add <| expNegInvGlue.cont_diff.comp <| cont_diff_const.sub cont_diff_id))
    fun x => (pos_denom x).ne'

protected theorem cont_diff_at {x n} : ContDiffAt ‚Ñù n smoothTransition x :=
  smoothTransition.cont_diff.ContDiffAt

protected theorem continuous : Continuous smoothTransition :=
  (@smoothTransition.cont_diff 0).Continuous

end SmoothTransition

end Real

variable {E X : Type _}

/-- `f : cont_diff_bump_of_inner c`, where `c` is a point in an inner product space, is a
bundled smooth function such that

- `f` is equal to `1` in `metric.closed_ball c f.r`;
- `support f = metric.ball c f.R`;
- `0 ‚â§ f x ‚â§ 1` for all `x`.

The structure `cont_diff_bump_of_inner` contains the data required to construct the function:
real numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available through
`coe_fn`. -/
structure ContDiffBumpOfInner (c : E) where
  (R r : ‚Ñù)
  r_pos : 0 < r
  r_lt_R : r < R

namespace ContDiffBumpOfInner

theorem R_pos {c : E} (f : ContDiffBumpOfInner c) : 0 < f.r :=
  f.r_pos.trans f.r_lt_R

instance (c : E) : Inhabited (ContDiffBumpOfInner c) :=
  ‚ü®‚ü®1, 2, zero_lt_one, one_lt_two‚ü©‚ü©

variable [InnerProductSpace ‚Ñù E] [NormedGroup X] [NormedSpace ‚Ñù X]

variable {c : E} (f : ContDiffBumpOfInner c) {x : E} {n : WithTop ‚Ñï}

/-- The function defined by `f : cont_diff_bump_of_inner c`. Use automatic coercion to
function instead. -/
def toFun (f : ContDiffBumpOfInner c) : E ‚Üí ‚Ñù := fun x => Real.smoothTransition ((f.r - dist x c) / (f.r - f.R))

instance : CoeFun (ContDiffBumpOfInner c) fun _ => E ‚Üí ‚Ñù :=
  ‚ü®toFun‚ü©

protected theorem def (x : E) : f x = Real.smoothTransition ((f.r - dist x c) / (f.r - f.R)) :=
  rfl

protected theorem sub (x : E) : f (c - x) = f (c + x) := by
  simp_rw [f.def, dist_self_sub_left, dist_self_add_left]

protected theorem neg (f : ContDiffBumpOfInner (0 : E)) (x : E) : f (-x) = f x := by
  simp_rw [‚Üê zero_sub, f.sub, zero_add‚Çì]

open Real (smoothTransition)

open Real.smoothTransition Metric

theorem one_of_mem_closed_ball (hx : x ‚àà ClosedBall c f.R) : f x = 1 :=
  one_of_one_le <| (one_le_div (sub_pos.2 f.r_lt_R)).2 <| sub_le_sub_left hx _

theorem nonneg : 0 ‚â§ f x :=
  nonneg _

/-- A version of `cont_diff_bump_of_inner.nonneg` with `x` explicit -/
theorem nonneg' (x : E) : 0 ‚â§ f x :=
  f.Nonneg

theorem le_one : f x ‚â§ 1 :=
  le_one _

theorem pos_of_mem_ball (hx : x ‚àà Ball c f.r) : 0 < f x :=
  pos_of_pos <| div_pos (sub_pos.2 hx) (sub_pos.2 f.r_lt_R)

theorem lt_one_of_lt_dist (h : f.R < dist x c) : f x < 1 :=
  lt_one_of_lt_one <| (div_lt_one (sub_pos.2 f.r_lt_R)).2 <| sub_lt_sub_left h _

theorem zero_of_le_dist (hx : f.r ‚â§ dist x c) : f x = 0 :=
  zero_of_nonpos <| div_nonpos_of_nonpos_of_nonneg (sub_nonpos.2 hx) (sub_nonneg.2 f.r_lt_R.le)

theorem support_eq : Support (f : E ‚Üí ‚Ñù) = Metric.Ball c f.r := by
  ext x
  suffices f x ‚â† 0 ‚Üî dist x c < f.R by
    simpa [‚Üê mem_support]
  cases' lt_or_le‚Çì (dist x c) f.R with hx hx
  ¬∑ simp [‚Üê hx, ‚Üê (f.pos_of_mem_ball hx).ne']
    
  ¬∑ simp [‚Üê hx.not_lt, ‚Üê f.zero_of_le_dist hx]
    

theorem tsupport_eq : Tsupport f = ClosedBall c f.r := by
  simp_rw [Tsupport, f.support_eq, closure_ball _ f.R_pos.ne']

protected theorem has_compact_support [FiniteDimensional ‚Ñù E] : HasCompactSupport f := by
  simp_rw [HasCompactSupport, f.tsupport_eq, is_compact_closed_ball]

theorem eventually_eq_one_of_mem_ball (h : x ‚àà Ball c f.R) : f =·∂†[ùìù x] 1 :=
  ((is_open_lt (continuous_id.dist continuous_const) continuous_const).eventually_mem h).mono fun z hz =>
    f.one_of_mem_closed_ball (le_of_lt‚Çì hz)

theorem eventually_eq_one : f =·∂†[ùìù c] 1 :=
  f.eventually_eq_one_of_mem_ball (mem_ball_self f.r_pos)

/-- `cont_diff_bump` is `ùíû‚Åø` in all its arguments. -/
protected theorem _root_.cont_diff_at.cont_diff_bump {c g : X ‚Üí E} {f : ‚àÄ x, ContDiffBumpOfInner (c x)} {x : X}
    (hc : ContDiffAt ‚Ñù n c x) (hr : ContDiffAt ‚Ñù n (fun x => (f x).R) x) (hR : ContDiffAt ‚Ñù n (fun x => (f x).r) x)
    (hg : ContDiffAt ‚Ñù n g x) : ContDiffAt ‚Ñù n (fun x => f x (g x)) x := by
  rcases eq_or_ne (g x) (c x) with (hx | hx)
  ¬∑ have : (fun x => f x (g x)) =·∂†[ùìù x] fun x => 1 := by
      have : dist (g x) (c x) < (f x).R := by
        simp_rw [hx, dist_self, (f x).r_pos]
      have := ContinuousAt.eventually_lt (hg.continuous_at.dist hc.continuous_at) hr.continuous_at this
      exact eventually_of_mem this fun x hx => (f x).one_of_mem_closed_ball (mem_set_of_eq.mp hx).le
    exact cont_diff_at_const.congr_of_eventually_eq this
    
  ¬∑ refine' real.smooth_transition.cont_diff_at.comp x _
    refine' (hR.sub <| hg.dist hc hx).div (hR.sub hr) (sub_pos.mpr (f x).r_lt_R).ne'
    

theorem _root_.cont_diff.cont_diff_bump {c g : X ‚Üí E} {f : ‚àÄ x, ContDiffBumpOfInner (c x)} (hc : ContDiff ‚Ñù n c)
    (hr : ContDiff ‚Ñù n fun x => (f x).R) (hR : ContDiff ‚Ñù n fun x => (f x).r) (hg : ContDiff ‚Ñù n g) :
    ContDiff ‚Ñù n fun x => f x (g x) := by
  rw [cont_diff_iff_cont_diff_at] at *
  exact fun x => (hc x).cont_diff_bump (hr x) (hR x) (hg x)

protected theorem cont_diff : ContDiff ‚Ñù n f :=
  cont_diff_const.cont_diff_bump cont_diff_const cont_diff_const cont_diff_id

protected theorem cont_diff_at : ContDiffAt ‚Ñù n f x :=
  f.ContDiff.ContDiffAt

protected theorem cont_diff_within_at {s : Set E} : ContDiffWithinAt ‚Ñù n f s x :=
  f.ContDiffAt.ContDiffWithinAt

protected theorem continuous : Continuous f :=
  cont_diff_zero.mp f.ContDiff

open MeasureTheory

variable [MeasurableSpace E] {Œº : Measure‚Çì E}

/-- A bump function normed so that `‚à´ x, f.normed Œº x ‚àÇŒº = 1`. -/
protected def normed (Œº : Measure‚Çì E) : E ‚Üí ‚Ñù := fun x => f x / ‚à´ x, f x ‚àÇŒº

theorem normed_def {Œº : Measure‚Çì E} (x : E) : f.normed Œº x = f x / ‚à´ x, f x ‚àÇŒº :=
  rfl

theorem nonneg_normed (x : E) : 0 ‚â§ f.normed Œº x :=
  div_nonneg f.Nonneg <| integral_nonneg f.nonneg'

theorem cont_diff_normed {n : WithTop ‚Ñï} : ContDiff ‚Ñù n (f.normed Œº) :=
  f.ContDiff.div_const

theorem continuous_normed : Continuous (f.normed Œº) :=
  f.Continuous.div_const

theorem normed_sub (x : E) : f.normed Œº (c - x) = f.normed Œº (c + x) := by
  simp_rw [f.normed_def, f.sub]

theorem normed_neg (f : ContDiffBumpOfInner (0 : E)) (x : E) : f.normed Œº (-x) = f.normed Œº x := by
  simp_rw [f.normed_def, f.neg]

variable [BorelSpace E] [FiniteDimensional ‚Ñù E] [IsLocallyFiniteMeasure Œº]

protected theorem integrable : Integrable f Œº :=
  f.Continuous.integrable_of_has_compact_support f.HasCompactSupport

protected theorem integrable_normed : Integrable (f.normed Œº) Œº :=
  f.Integrable.div_const _

variable [Œº.IsOpenPosMeasure]

theorem integral_pos : 0 < ‚à´ x, f x ‚àÇŒº := by
  refine' (integral_pos_iff_support_of_nonneg f.nonneg' f.integrable).mpr _
  rw [f.support_eq]
  refine' is_open_ball.measure_pos _ (nonempty_ball.mpr f.R_pos)

theorem integral_normed : (‚à´ x, f.normed Œº x ‚àÇŒº) = 1 := by
  simp_rw [ContDiffBumpOfInner.normed, div_eq_mul_inv, mul_comm (f _), ‚Üê smul_eq_mul, integral_smul]
  exact inv_mul_cancel f.integral_pos.ne'

theorem support_normed_eq : Support (f.normed Œº) = Metric.Ball c f.r := by
  simp_rw [ContDiffBumpOfInner.normed, support_div, f.support_eq, support_const f.integral_pos.ne', inter_univ]

theorem tsupport_normed_eq : Tsupport (f.normed Œº) = Metric.ClosedBall c f.r := by
  simp_rw [Tsupport, f.support_normed_eq, closure_ball _ f.R_pos.ne']

theorem has_compact_support_normed : HasCompactSupport (f.normed Œº) := by
  simp_rw [HasCompactSupport, f.tsupport_normed_eq, is_compact_closed_ball]

variable (Œº)

theorem integral_normed_smul (z : X) [CompleteSpace X] : (‚à´ x, f.normed Œº x ‚Ä¢ z ‚àÇŒº) = z := by
  simp_rw [integral_smul_const, f.integral_normed, one_smul]

end ContDiffBumpOfInner

/-- `f : cont_diff_bump c`, where `c` is a point in a finite dimensional real vector space, is
a bundled smooth function such that

  - `f` is equal to `1` in `euclidean.closed_ball c f.r`;
  - `support f = euclidean.ball c f.R`;
  - `0 ‚â§ f x ‚â§ 1` for all `x`.

The structure `cont_diff_bump` contains the data required to construct the function: real
numbers `r`, `R`, and proofs of `0 < r < R`. The function itself is available through `coe_fn`.-/
structure ContDiffBump [NormedGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] (c : E) extends
  ContDiffBumpOfInner (toEuclidean c)

namespace ContDiffBump

variable [NormedGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] {c x : E} (f : ContDiffBump c)

/-- The function defined by `f : cont_diff_bump c`. Use automatic coercion to function
instead. -/
def toFun (f : ContDiffBump c) : E ‚Üí ‚Ñù :=
  f.toContDiffBumpOfInner ‚àò toEuclidean

instance : CoeFun (ContDiffBump c) fun _ => E ‚Üí ‚Ñù :=
  ‚ü®toFun‚ü©

instance (c : E) : Inhabited (ContDiffBump c) :=
  ‚ü®‚ü®default‚ü©‚ü©

theorem R_pos : 0 < f.r :=
  f.toContDiffBumpOfInner.R_pos

theorem coe_eq_comp : ‚áëf = f.toContDiffBumpOfInner ‚àò toEuclidean :=
  rfl

theorem one_of_mem_closed_ball (hx : x ‚àà Euclidean.ClosedBall c f.R) : f x = 1 :=
  f.toContDiffBumpOfInner.one_of_mem_closed_ball hx

theorem nonneg : 0 ‚â§ f x :=
  f.toContDiffBumpOfInner.Nonneg

theorem le_one : f x ‚â§ 1 :=
  f.toContDiffBumpOfInner.le_one

theorem pos_of_mem_ball (hx : x ‚àà Euclidean.Ball c f.r) : 0 < f x :=
  f.toContDiffBumpOfInner.pos_of_mem_ball hx

theorem lt_one_of_lt_dist (h : f.R < Euclidean.dist x c) : f x < 1 :=
  f.toContDiffBumpOfInner.lt_one_of_lt_dist h

theorem zero_of_le_dist (hx : f.r ‚â§ Euclidean.dist x c) : f x = 0 :=
  f.toContDiffBumpOfInner.zero_of_le_dist hx

theorem support_eq : Support (f : E ‚Üí ‚Ñù) = Euclidean.Ball c f.r := by
  rw [Euclidean.ball_eq_preimage, ‚Üê f.to_cont_diff_bump_of_inner.support_eq, ‚Üê support_comp_eq_preimage, coe_eq_comp]

theorem tsupport_eq : Tsupport f = Euclidean.ClosedBall c f.r := by
  rw [Tsupport, f.support_eq, Euclidean.closure_ball _ f.R_pos.ne']

protected theorem has_compact_support : HasCompactSupport f := by
  simp_rw [HasCompactSupport, f.tsupport_eq, Euclidean.is_compact_closed_ball]

theorem eventually_eq_one_of_mem_ball (h : x ‚àà Euclidean.Ball c f.R) : f =·∂†[ùìù x] 1 :=
  toEuclidean.ContinuousAt (f.toContDiffBumpOfInner.eventually_eq_one_of_mem_ball h)

theorem eventually_eq_one : f =·∂†[ùìù c] 1 :=
  f.eventually_eq_one_of_mem_ball <| Euclidean.mem_ball_self f.r_pos

protected theorem cont_diff {n} : ContDiff ‚Ñù n f :=
  f.toContDiffBumpOfInner.ContDiff.comp (toEuclidean : E ‚âÉL[‚Ñù] _).ContDiff

protected theorem cont_diff_at {n} : ContDiffAt ‚Ñù n f x :=
  f.ContDiff.ContDiffAt

protected theorem cont_diff_within_at {s n} : ContDiffWithinAt ‚Ñù n f s x :=
  f.ContDiffAt.ContDiffWithinAt

theorem exists_tsupport_subset {s : Set E} (hs : s ‚àà ùìù c) : ‚àÉ f : ContDiffBump c, Tsupport f ‚äÜ s :=
  let ‚ü®R, h0, hR‚ü© := Euclidean.nhds_basis_closed_ball.mem_iff.1 hs
  ‚ü®‚ü®‚ü®R / 2, R, half_pos h0, half_lt_self h0‚ü©‚ü©, by
    rwa [tsupport_eq]‚ü©

theorem exists_closure_subset {R : ‚Ñù} (hR : 0 < R) {s : Set E} (hs : IsClosed s) (hsR : s ‚äÜ Euclidean.Ball c R) :
    ‚àÉ f : ContDiffBump c, f.r = R ‚àß s ‚äÜ Euclidean.Ball c f.R := by
  rcases Euclidean.exists_pos_lt_subset_ball hR hs hsR with ‚ü®r, hr, hsr‚ü©
  exact ‚ü®‚ü®‚ü®r, R, hr.1, hr.2‚ü©‚ü©, rfl, hsr‚ü©

end ContDiffBump

open FiniteDimensional Metric

/-- If `E` is a finite dimensional normed space over `‚Ñù`, then for any point `x : E` and its
neighborhood `s` there exists an infinitely smooth function with the following properties:

* `f y = 1` in a neighborhood of `x`;
* `f y = 0` outside of `s`;
*  moreover, `tsupport f ‚äÜ s` and `f` has compact support;
* `f y ‚àà [0, 1]` for all `y`.

This lemma is a simple wrapper around lemmas about bundled smooth bump functions, see
`cont_diff_bump`. -/
theorem exists_cont_diff_bump_function_of_mem_nhds [NormedGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] {x : E}
    {s : Set E} (hs : s ‚àà ùìù x) :
    ‚àÉ f : E ‚Üí ‚Ñù, f =·∂†[ùìù x] 1 ‚àß (‚àÄ y, f y ‚àà Icc (0 : ‚Ñù) 1) ‚àß ContDiff ‚Ñù ‚ä§ f ‚àß HasCompactSupport f ‚àß Tsupport f ‚äÜ s :=
  let ‚ü®f, hf‚ü© := ContDiffBump.exists_tsupport_subset hs
  ‚ü®f, f.eventually_eq_one, fun y => ‚ü®f.Nonneg, f.le_one‚ü©, f.ContDiff, f.HasCompactSupport, hf‚ü©

