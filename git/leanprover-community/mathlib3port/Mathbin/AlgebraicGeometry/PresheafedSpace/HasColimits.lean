/-
Copyright (c) 2020 Scott Morrison. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Scott Morrison
-/
import Mathbin.AlgebraicGeometry.PresheafedSpace
import Mathbin.Topology.Category.Top.Limits
import Mathbin.Topology.Sheaves.Limits
import Mathbin.CategoryTheory.Limits.ConcreteCategory

/-!
# `PresheafedSpace C` has colimits.

If `C` has limits, then the category `PresheafedSpace C` has colimits,
and the forgetful functor to `Top` preserves these colimits.

When restricted to a diagram where the underlying continuous maps are open embeddings,
this says that we can glue presheaved spaces.

Given a diagram `F : J ‚•§ PresheafedSpace C`,
we first build the colimit of the underlying topological spaces,
as `colimit (F ‚ãô PresheafedSpace.forget C)`. Call that colimit space `X`.

Our strategy is to push each of the presheaves `F.obj j`
forward along the continuous map `colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j` to `X`.
Since pushforward is functorial, we obtain a diagram `J ‚•§ (presheaf C X)·µí·µñ`
of presheaves on a single space `X`.
(Note that the arrows now point the other direction,
because this is the way `PresheafedSpace C` is set up.)

The limit of this diagram then constitutes the colimit presheaf.
-/


noncomputable section

universe v u

open CategoryTheory

open Top

open Top.Presheaf

open TopologicalSpace

open Opposite

open CategoryTheory.Category

open CategoryTheory.Limits

open CategoryTheory.Functor

variable {J : Type v} [SmallCategory J]

variable {C : Type u} [Category.{v} C]

namespace AlgebraicGeometry

namespace PresheafedSpace

@[simp]
theorem map_id_c_app (F : J ‚•§ PresheafedSpace C) j U :
    (F.map (ùüô j)).c.app (op U) =
      (Pushforward.id (F.obj j).Presheaf).inv.app (op U) ‚â´
        (pushforwardEq
                (by
                  simp
                  rfl)
                (F.obj j).Presheaf).Hom.app
          (op U) :=
  by
  cases U
  dsimp'
  simp [PresheafedSpace.congr_app (F.map_id j)]
  rfl

@[simp]
theorem map_comp_c_app (F : J ‚•§ PresheafedSpace C) {j‚ÇÅ j‚ÇÇ j‚ÇÉ} (f : j‚ÇÅ ‚ü∂ j‚ÇÇ) (g : j‚ÇÇ ‚ü∂ j‚ÇÉ) U :
    (F.map (f ‚â´ g)).c.app (op U) =
      (F.map g).c.app (op U) ‚â´
        (pushforwardMap (F.map g).base (F.map f).c).app (op U) ‚â´
          (Pushforward.comp (F.obj j‚ÇÅ).Presheaf (F.map f).base (F.map g).base).inv.app (op U) ‚â´
            (pushforwardEq
                    (by
                      rw [F.map_comp]
                      rfl)
                    _).Hom.app
              _ :=
  by
  cases U
  dsimp'
  simp only [PresheafedSpace.congr_app (F.map_comp f g)]
  dsimp'
  simp
  dsimp'
  simp

/-- Given a diagram of presheafed spaces,
we can push all the presheaves forward to the colimit `X` of the underlying topological spaces,
obtaining a diagram in `(presheaf C X)·µí·µñ`.
-/
-- See note [dsimp, simp]
@[simps]
def pushforwardDiagramToColimit (F : J ‚•§ PresheafedSpace C) :
    J ‚•§ (Presheaf C (colimit (F ‚ãô PresheafedSpace.forget C)))·µí·µñ where
  obj := fun j => op (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j _* (F.obj j).Presheaf)
  map := fun j j' f =>
    (pushforwardMap (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j') (F.map f).c ‚â´
        (Pushforward.comp (F.obj j).Presheaf ((F ‚ãô PresheafedSpace.forget C).map f)
              (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j')).inv ‚â´
          (pushforwardEq (colimit.w (F ‚ãô PresheafedSpace.forget C) f) (F.obj j).Presheaf).Hom).op
  map_id' := fun j => by
    apply (op_equiv _ _).Injective
    ext U
    induction U using Opposite.rec
    cases U
    dsimp'
    simp
    dsimp'
    simp
  map_comp' := fun j‚ÇÅ j‚ÇÇ j‚ÇÉ f g => by
    apply (op_equiv _ _).Injective
    ext U
    dsimp'
    simp only [map_comp_c_app, id.def, eq_to_hom_op, pushforward_map_app, eq_to_hom_map, assoc, id_comp,
      pushforward.comp_inv_app, pushforward_eq_hom_app]
    dsimp'
    simp only [eq_to_hom_trans, id_comp]
    congr 1
    -- The key fact is `(F.map f).c.congr`,
    -- which allows us in rewrite in the argument of `(F.map f).c.app`.
    rw [(F.map f).c.congr]
    -- Now we pick up the pieces. First, we say what we want to replace that open set by:
    pick_goal 3
    refine' op ((opens.map (colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j‚ÇÇ)).obj (unop U))
    -- Now we show the open sets are equal.
    swap
    ¬∑ apply unop_injective
      rw [‚Üê opens.map_comp_obj]
      congr
      exact colimit.w (F ‚ãô PresheafedSpace.forget C) g
      
    -- Finally, the original goal is now easy:
    swap
    ¬∑ simp
      rfl
      

variable [HasLimits C]

/-- Auxiliary definition for `PresheafedSpace.has_colimits`.
-/
def colimit (F : J ‚•§ PresheafedSpace C) : PresheafedSpace C where
  Carrier := colimit (F ‚ãô PresheafedSpace.forget C)
  Presheaf := limit (pushforwardDiagramToColimit F).leftOp

@[simp]
theorem colimit_carrier (F : J ‚•§ PresheafedSpace C) :
    (colimit F).Carrier = Limits.colimit (F ‚ãô PresheafedSpace.forget C) :=
  rfl

@[simp]
theorem colimit_presheaf (F : J ‚•§ PresheafedSpace C) :
    (colimit F).Presheaf = limit (pushforwardDiagramToColimit F).leftOp :=
  rfl

/-- Auxiliary definition for `PresheafedSpace.has_colimits`.
-/
@[simps]
def colimitCocone (F : J ‚•§ PresheafedSpace C) : Cocone F where
  x := colimit F
  Œπ :=
    { app := fun j => { base := colimit.Œπ (F ‚ãô PresheafedSpace.forget C) j, c := limit.œÄ _ (op j) },
      naturality' := fun j j' f => by
        fapply PresheafedSpace.ext
        ¬∑ ext x
          exact colimit.w_apply (F ‚ãô PresheafedSpace.forget C) f x
          
        ¬∑ ext U
          induction U using Opposite.rec
          cases U
          dsimp'
          simp only [PresheafedSpace.id_c_app, eq_to_hom_op, eq_to_hom_map, assoc, pushforward.comp_inv_app]
          rw [‚Üê congr_arg‚Çì nat_trans.app (limit.w (pushforward_diagram_to_colimit F).leftOp f.op)]
          dsimp'
          simp only [eq_to_hom_op, eq_to_hom_map, assoc, id_comp, pushforward.comp_inv_app]
          congr
          dsimp'
          simp only [id_comp]
          simpa
           }

namespace ColimitCoconeIsColimit

/-- Auxiliary definition for `PresheafedSpace.colimit_cocone_is_colimit`.
-/
def descCApp (F : J ‚•§ PresheafedSpace C) (s : Cocone F) (U : (Opens ‚Ü•s.x.Carrier)·µí·µñ) :
    s.x.Presheaf.obj U ‚ü∂
      (colimit.desc (F ‚ãô PresheafedSpace.forget C) ((PresheafedSpace.forget C).mapCocone s) _*
            limit (pushforwardDiagramToColimit F).leftOp).obj
        U :=
  by
  refine'
    limit.lift _ { x := s.X.presheaf.obj U, œÄ := { app := fun j => _, naturality' := fun j j' f => _ } } ‚â´
      (limit_obj_iso_limit_comp_evaluation _ _).inv
  -- We still need to construct the `app` and `naturality'` fields omitted above.
  ¬∑ refine' (s.Œπ.app (unop j)).c.app U ‚â´ (F.obj (unop j)).Presheaf.map (eq_to_hom _)
    dsimp'
    rw [‚Üê opens.map_comp_obj]
    simp
    
  ¬∑ rw [PresheafedSpace.congr_app (s.w f.unop).symm U]
    dsimp'
    have w :=
      functor.congr_obj (congr_arg‚Çì opens.map (colimit.Œπ_desc ((PresheafedSpace.forget C).mapCocone s) (unop j)))
        (unop U)
    simp only [opens.map_comp_obj_unop] at w
    replace w := congr_arg‚Çì op w
    have w' := nat_trans.congr (F.map f.unop).c w
    rw [w']
    dsimp'
    simp
    dsimp'
    simp
    

theorem desc_c_naturality (F : J ‚•§ PresheafedSpace C) (s : Cocone F) {U V : (Opens ‚Ü•s.x.Carrier)·µí·µñ} (i : U ‚ü∂ V) :
    s.x.Presheaf.map i ‚â´ descCApp F s V =
      descCApp F s U ‚â´ (colimit.desc (F ‚ãô forget C) ((forget C).mapCocone s) _* (colimitCocone F).x.Presheaf).map i :=
  by
  dsimp' [desc_c_app]
  ext
  simp only [limit.lift_œÄ, nat_trans.naturality, limit.lift_œÄ_assoc, eq_to_hom_map, assoc, pushforward_obj_map,
    nat_trans.naturality_assoc, op_map, limit_obj_iso_limit_comp_evaluation_inv_œÄ_app_assoc,
    limit_obj_iso_limit_comp_evaluation_inv_œÄ_app]
  dsimp'
  have w :=
    functor.congr_hom (congr_arg‚Çì opens.map (colimit.Œπ_desc ((PresheafedSpace.forget C).mapCocone s) (unop j))) i.unop
  simp only [opens.map_comp_map] at w
  replace w := congr_arg‚Çì Quiver.Hom.op w
  rw [w]
  dsimp'
  simp

/-- Auxiliary definition for `PresheafedSpace.colimit_cocone_is_colimit`.
-/
def desc (F : J ‚•§ PresheafedSpace C) (s : Cocone F) : colimit F ‚ü∂ s.x where
  base := colimit.desc (F ‚ãô PresheafedSpace.forget C) ((PresheafedSpace.forget C).mapCocone s)
  c := { app := fun U => descCApp F s U, naturality' := fun U V i => desc_c_naturality F s i }

theorem desc_fac (F : J ‚•§ PresheafedSpace C) (s : Cocone F) (j : J) :
    (colimitCocone F).Œπ.app j ‚â´ desc F s = s.Œπ.app j := by
  fapply PresheafedSpace.ext
  ¬∑ simp [desc]
    
  ¬∑ ext
    dsimp' [desc, desc_c_app]
    simpa
    

end ColimitCoconeIsColimit

open ColimitCoconeIsColimit

/-- Auxiliary definition for `PresheafedSpace.has_colimits`.
-/
def colimitCoconeIsColimit (F : J ‚•§ PresheafedSpace C) : IsColimit (colimitCocone F) where
  desc := fun s => desc F s
  fac' := fun s => desc_fac F s
  uniq' := fun s m w => by
    -- We need to use the identity on the continuous maps twice, so we prepare that first:
    have t : m.base = colimit.desc (F ‚ãô PresheafedSpace.forget C) ((PresheafedSpace.forget C).mapCocone s) := by
      apply CategoryTheory.Limits.colimit.hom_ext
      intro j
      apply ContinuousMap.ext
      intro x
      dsimp'
      simp only [colimit.Œπ_desc_apply, map_cocone_Œπ_app]
      rw [‚Üê w j]
      simp
    fapply PresheafedSpace.ext
    -- could `ext` please not reorder goals?
    ¬∑ exact t
      
    ¬∑ ext U j
      dsimp' [desc, desc_c_app]
      simp only [limit.lift_œÄ, eq_to_hom_op, eq_to_hom_map, assoc, limit_obj_iso_limit_comp_evaluation_inv_œÄ_app]
      rw [PresheafedSpace.congr_app (w (unop j)).symm U]
      dsimp'
      have w := congr_arg‚Çì op (functor.congr_obj (congr_arg‚Çì opens.map t) (unop U))
      rw [nat_trans.congr (limit.œÄ (pushforward_diagram_to_colimit F).leftOp j) w]
      simp
      

/-- When `C` has limits, the category of presheaved spaces with values in `C` itself has colimits.
-/
instance : HasColimits (PresheafedSpace C) where
  HasColimitsOfShape := fun J ùí• =>
    { HasColimit := fun F => has_colimit.mk { Cocone := colimit_cocone F, IsColimit := colimit_cocone_is_colimit F } }

/-- The underlying topological space of a colimit of presheaved spaces is
the colimit of the underlying topological spaces.
-/
instance forgetPreservesColimits : PreservesColimits (PresheafedSpace.forget C) where
  PreservesColimitsOfShape := fun J ùí• =>
    { PreservesColimit := fun F =>
        preserves_colimit_of_preserves_colimit_cocone (colimit_cocone_is_colimit F)
          (by
            apply is_colimit.of_iso_colimit (colimit.is_colimit _)
            fapply cocones.ext
            ¬∑ rfl
              
            ¬∑ intro j
              dsimp'
              simp
              ) }

/-- Given a diagram of `PresheafedSpace C`s, its colimit is computed by pushing the sheaves onto
the colimit of the underlying spaces, and taking componentwise limit.
This is the componentwise diagram for an open set `U` of the colimit of the underlying spaces.
-/
@[simps]
def componentwiseDiagram (F : J ‚•§ PresheafedSpace C) (U : Opens (Limits.colimit F).Carrier) : J·µí·µñ ‚•§ C where
  obj := fun j => (F.obj (unop j)).Presheaf.obj (op ((Opens.map (colimit.Œπ F (unop j)).base).obj U))
  map := fun j k f =>
    (F.map f.unop).c.app _ ‚â´
      (F.obj (unop k)).Presheaf.map
        (eqToHom
          (by
            rw [‚Üê colimit.w F f.unop, comp_base]
            rfl))
  map_comp' := fun i j k f g => by
    cases U
    dsimp'
    simp_rw [map_comp_c_app, category.assoc]
    congr 1
    rw [Top.Presheaf.Pushforward.comp_inv_app, Top.Presheaf.pushforward_eq_hom_app,
      CategoryTheory.NatTrans.naturality_assoc, Top.Presheaf.pushforward_map_app]
    congr 1
    rw [category.id_comp, ‚Üê (F.obj (unop k)).Presheaf.map_comp]
    erw [‚Üê (F.obj (unop k)).Presheaf.map_comp]
    congr

/-- The components of the colimit of a diagram of `PresheafedSpace C` is obtained
via taking componentwise limits.
-/
def colimitPresheafObjIsoComponentwiseLimit (F : J ‚•§ PresheafedSpace C) (U : Opens (Limits.colimit F).Carrier) :
    (Limits.colimit F).Presheaf.obj (op U) ‚âÖ limit (componentwiseDiagram F U) := by
  refine' ((sheaf_iso_of_iso (colimit.iso_colimit_cocone ‚ü®_, colimit_cocone_is_colimit F‚ü©).symm).app (op U)).trans _
  refine' (limit_obj_iso_limit_comp_evaluation _ _).trans (limits.lim.map_iso _)
  fapply nat_iso.of_components
  ¬∑ intro X
    refine' (F.obj (unop X)).Presheaf.mapIso (eq_to_iso _)
    dsimp' only [functor.op, unop_op, opens.map]
    congr 2
    rw [Set.preimage_preimage]
    simp_rw [‚Üê comp_app]
    congr 2
    exact Œπ_preserves_colimits_iso_inv (forget C) F (unop X)
    
  ¬∑ intro X Y f
    change ((F.map f.unop).c.app _ ‚â´ _ ‚â´ _) ‚â´ (F.obj (unop Y)).Presheaf.map _ = _ ‚â´ _
    rw [Top.Presheaf.Pushforward.comp_inv_app]
    erw [category.id_comp]
    rw [category.assoc]
    erw [‚Üê (F.obj (unop Y)).Presheaf.map_comp, (F.map f.unop).c.naturality_assoc, ‚Üê (F.obj (unop Y)).Presheaf.map_comp]
    congr
    

@[simp]
theorem colimit_presheaf_obj_iso_componentwise_limit_inv_Œπ_app (F : J ‚•§ PresheafedSpace C)
    (U : Opens (Limits.colimit F).Carrier) (j : J) :
    (colimitPresheafObjIsoComponentwiseLimit F U).inv ‚â´ (colimit.Œπ F j).c.app (op U) = limit.œÄ _ (op j) := by
  delta' colimit_presheaf_obj_iso_componentwise_limit
  rw [iso.trans_inv, iso.trans_inv, iso.app_inv, sheaf_iso_of_iso_inv, pushforward_to_of_iso_app,
    congr_app (iso.symm_inv _)]
  simp_rw [category.assoc]
  rw [‚Üê functor.map_comp_assoc, nat_trans.naturality]
  erw [‚Üê comp_c_app_assoc]
  rw [congr_app (colimit.iso_colimit_cocone_Œπ_hom _ _)]
  simp_rw [category.assoc]
  erw [limit_obj_iso_limit_comp_evaluation_inv_œÄ_app_assoc, lim_map_œÄ_assoc]
  convert category.comp_id _
  erw [‚Üê (F.obj j).Presheaf.map_id]
  iterate 2 
    erw [‚Üê (F.obj j).Presheaf.map_comp]
  congr

@[simp]
theorem colimit_presheaf_obj_iso_componentwise_limit_hom_œÄ (F : J ‚•§ PresheafedSpace C)
    (U : Opens (Limits.colimit F).Carrier) (j : J) :
    (colimitPresheafObjIsoComponentwiseLimit F U).Hom ‚â´ limit.œÄ _ (op j) = (colimit.Œπ F j).c.app (op U) := by
  rw [‚Üê iso.eq_inv_comp, colimit_presheaf_obj_iso_componentwise_limit_inv_Œπ_app]

end PresheafedSpace

end AlgebraicGeometry

