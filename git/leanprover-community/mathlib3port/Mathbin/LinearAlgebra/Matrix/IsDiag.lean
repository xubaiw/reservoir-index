/-
Copyright (c) 2021 Lu-Ming Zhang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Lu-Ming Zhang
-/
import Mathbin.LinearAlgebra.Matrix.Symmetric
import Mathbin.LinearAlgebra.Matrix.Orthogonal
import Mathbin.Data.Matrix.Kronecker

/-!
# Diagonal matrices

This file contains the definition and basic results about diagonal matrices.

## Main results

- `matrix.is_diag`: a proposition that states a given square matrix `A` is diagonal.

## Tags

diag, diagonal, matrix
-/


namespace Matrix

variable {α β R n m : Type _}

open Function

open_locale Matrix Kronecker

/-- `A.is_diag` means square matrix `A` is a diagonal matrix. -/
def IsDiag [Zero α] (A : Matrix n n α) : Prop :=
  ∀ ⦃i j⦄, i ≠ j → A i j = 0

@[simp]
theorem is_diag_diagonal [Zero α] [DecidableEq n] (d : n → α) : (diagonalₓ d).IsDiag := fun i j =>
  Matrix.diagonal_apply_ne

/-- Diagonal matrices are generated by `matrix.diagonal`. -/
theorem IsDiag.exists_diagonal [Zero α] [DecidableEq n] {A : Matrix n n α} (h : A.IsDiag) : ∃ d, diagonalₓ d = A := by
  refine' ⟨fun i => A i i, ext fun i j => _⟩
  obtain rfl | hij := Decidable.eq_or_ne i j
  · rw [diagonal_apply_eq]
    
  · rw [diagonal_apply_ne hij, h hij]
    

/-- `matrix.is_diag.exists_diagonal` as an iff. -/
theorem is_diag_iff_exists_diagonal [Zero α] [DecidableEq n] (A : Matrix n n α) : A.IsDiag ↔ ∃ d, diagonalₓ d = A :=
  ⟨IsDiag.exists_diagonal, fun ⟨d, hd⟩ => hd ▸ is_diag_diagonal d⟩

/-- Every matrix indexed by a subsingleton is diagonal. -/
theorem is_diag_of_subsingleton [Zero α] [Subsingleton n] (A : Matrix n n α) : A.IsDiag := fun i j h =>
  (h <| Subsingleton.elimₓ i j).elim

/-- Every zero matrix is diagonal. -/
@[simp]
theorem is_diag_zero [Zero α] : (0 : Matrix n n α).IsDiag := fun i j h => rfl

/-- Every identity matrix is diagonal. -/
@[simp]
theorem is_diag_one [DecidableEq n] [Zero α] [One α] : (1 : Matrix n n α).IsDiag := fun i j => one_apply_ne

theorem IsDiag.map [Zero α] [Zero β] {A : Matrix n n α} (ha : A.IsDiag) {f : α → β} (hf : f 0 = 0) : (A.map f).IsDiag :=
  by
  intro i j h
  simp [ha h, hf]

theorem IsDiag.neg [AddGroupₓ α] {A : Matrix n n α} (ha : A.IsDiag) : (-A).IsDiag := by
  intro i j h
  simp [ha h]

@[simp]
theorem is_diag_neg_iff [AddGroupₓ α] {A : Matrix n n α} : (-A).IsDiag ↔ A.IsDiag :=
  ⟨fun ha i j h => neg_eq_zero.1 (ha h), IsDiag.neg⟩

theorem IsDiag.add [AddZeroClass α] {A B : Matrix n n α} (ha : A.IsDiag) (hb : B.IsDiag) : (A + B).IsDiag := by
  intro i j h
  simp [ha h, hb h]

theorem IsDiag.sub [AddGroupₓ α] {A B : Matrix n n α} (ha : A.IsDiag) (hb : B.IsDiag) : (A - B).IsDiag := by
  intro i j h
  simp [ha h, hb h]

theorem IsDiag.smul [Monoidₓ R] [AddMonoidₓ α] [DistribMulAction R α] (k : R) {A : Matrix n n α} (ha : A.IsDiag) :
    (k • A).IsDiag := by
  intro i j h
  simp [ha h]

@[simp]
theorem is_diag_smul_one n [Semiringₓ α] [DecidableEq n] (k : α) : (k • (1 : Matrix n n α)).IsDiag :=
  is_diag_one.smul k

theorem IsDiag.transpose [Zero α] {A : Matrix n n α} (ha : A.IsDiag) : Aᵀ.IsDiag := fun i j h => ha h.symm

@[simp]
theorem is_diag_transpose_iff [Zero α] {A : Matrix n n α} : Aᵀ.IsDiag ↔ A.IsDiag :=
  ⟨IsDiag.transpose, IsDiag.transpose⟩

theorem IsDiag.conj_transpose [Semiringₓ α] [StarRing α] {A : Matrix n n α} (ha : A.IsDiag) : Aᴴ.IsDiag :=
  ha.transpose.map (star_zero _)

@[simp]
theorem is_diag_conj_transpose_iff [Semiringₓ α] [StarRing α] {A : Matrix n n α} : Aᴴ.IsDiag ↔ A.IsDiag :=
  ⟨fun ha => by
    convert ha.conj_transpose
    simp , IsDiag.conj_transpose⟩

theorem IsDiag.minor [Zero α] {A : Matrix n n α} (ha : A.IsDiag) {f : m → n} (hf : Injective f) :
    (A.minor f f).IsDiag := fun i j h => ha (hf.Ne h)

/-- `(A ⊗ B).is_diag` if both `A` and `B` are diagonal. -/
theorem IsDiag.kronecker [MulZeroClassₓ α] {A : Matrix m m α} {B : Matrix n n α} (hA : A.IsDiag) (hB : B.IsDiag) :
    (A ⊗ₖ B).IsDiag := by
  rintro ⟨a, b⟩ ⟨c, d⟩ h
  simp only [Prod.mk.inj_iffₓ, Ne.def, not_and_distrib] at h
  cases' h with hac hbd
  · simp [hA hac]
    
  · simp [hB hbd]
    

theorem IsDiag.is_symm [Zero α] {A : Matrix n n α} (h : A.IsDiag) : A.IsSymm := by
  ext i j
  by_cases' g : i = j
  · rw [g]
    
  simp [h g, h (Ne.symm g)]

/-- The block matrix `A.from_blocks 0 0 D` is diagonal if `A` and `D` are diagonal. -/
theorem IsDiag.from_blocks [Zero α] {A : Matrix m m α} {D : Matrix n n α} (ha : A.IsDiag) (hd : D.IsDiag) :
    (A.fromBlocks 0 0 D).IsDiag := by
  rintro (i | i) (j | j) hij
  · exact ha (ne_of_apply_ne _ hij)
    
  · rfl
    
  · rfl
    
  · exact hd (ne_of_apply_ne _ hij)
    

/-- This is the `iff` version of `matrix.is_diag.from_blocks`. -/
theorem is_diag_from_blocks_iff [Zero α] {A : Matrix m m α} {B : Matrix m n α} {C : Matrix n m α} {D : Matrix n n α} :
    (A.fromBlocks B C D).IsDiag ↔ A.IsDiag ∧ B = 0 ∧ C = 0 ∧ D.IsDiag := by
  constructor
  · intro h
    refine' ⟨fun i j hij => _, ext fun i j => _, ext fun i j => _, fun i j hij => _⟩
    · exact h (sum.inl_injective.ne hij)
      
    · exact h Sum.inl_ne_inr
      
    · exact h Sum.inr_ne_inl
      
    · exact h (sum.inr_injective.ne hij)
      
    
  · rintro ⟨ha, hb, hc, hd⟩
    convert is_diag.from_blocks ha hd
    

/-- A symmetric block matrix `A.from_blocks B C D` is diagonal
    if  `A` and `D` are diagonal and `B` is `0`. -/
theorem IsDiag.from_blocks_of_is_symm [Zero α] {A : Matrix m m α} {C : Matrix n m α} {D : Matrix n n α}
    (h : (A.fromBlocks 0 C D).IsSymm) (ha : A.IsDiag) (hd : D.IsDiag) : (A.fromBlocks 0 C D).IsDiag := by
  rw [← (is_symm_from_blocks_iff.1 h).2.1]
  exact ha.from_blocks hd

theorem mul_transpose_self_is_diag_iff_has_orthogonal_rows [Fintype n] [Mul α] [AddCommMonoidₓ α] {A : Matrix m n α} :
    (A ⬝ Aᵀ).IsDiag ↔ A.HasOrthogonalRows :=
  Iff.rfl

theorem transpose_mul_self_is_diag_iff_has_orthogonal_cols [Fintype m] [Mul α] [AddCommMonoidₓ α] {A : Matrix m n α} :
    (Aᵀ ⬝ A).IsDiag ↔ A.HasOrthogonalCols :=
  Iff.rfl

end Matrix

