/-
Copyright (c) 2020 Johan Commelin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johan Commelin
-/
import Mathbin.Data.Polynomial.RingDivision
import Mathbin.Tactic.Zify
import Mathbin.FieldTheory.Separable
import Mathbin.Data.Zmod.Basic
import Mathbin.RingTheory.IntegralDomain
import Mathbin.NumberTheory.Divisors
import Mathbin.FieldTheory.Finite.Basic
import Mathbin.GroupTheory.SpecificGroups.Cyclic
import Mathbin.Algebra.CharP.Two

/-!
# Roots of unity and primitive roots of unity

We define roots of unity in the context of an arbitrary commutative monoid,
as a subgroup of the group of units. We also define a predicate `is_primitive_root` on commutative
monoids, expressing that an element is a primitive root of unity.

## Main definitions

* `roots_of_unity n M`, for `n : ℕ+` is the subgroup of the units of a commutative monoid `M`
  consisting of elements `x` that satisfy `x ^ n = 1`.
* `is_primitive_root ζ k`: an element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
  and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`.
* `primitive_roots k R`: the finset of primitive `k`-th roots of unity in an integral domain `R`.
* `is_primitive_root.aut_to_pow`: the monoid hom that takes an automorphism of a ring to the power
  it sends that specific primitive root, as a member of `(zmod n)ˣ`.

## Main results

* `roots_of_unity.is_cyclic`: the roots of unity in an integral domain form a cyclic group.
* `is_primitive_root.zmod_equiv_zpowers`: `zmod k` is equivalent to
  the subgroup generated by a primitive `k`-th root of unity.
* `is_primitive_root.zpowers_eq`: in an integral domain, the subgroup generated by
  a primitive `k`-th root of unity is equal to the `k`-th roots of unity.
* `is_primitive_root.card_primitive_roots`: if an integral domain
   has a primitive `k`-th root of unity, then it has `φ k` of them.

## Implementation details

It is desirable that `roots_of_unity` is a subgroup,
and it will mainly be applied to rings (e.g. the ring of integers in a number field) and fields.
We therefore implement it as a subgroup of the units of a commutative monoid.

We have chosen to define `roots_of_unity n` for `n : ℕ+`, instead of `n : ℕ`,
because almost all lemmas need the positivity assumption,
and in particular the type class instances for `fintype` and `is_cyclic`.

On the other hand, for primitive roots of unity, it is desirable to have a predicate
not just on units, but directly on elements of the ring/field.
For example, we want to say that `exp (2 * pi * I / n)` is a primitive `n`-th root of unity
in the complex numbers, without having to turn that number into a unit first.

This creates a little bit of friction, but lemmas like `is_primitive_root.is_unit` and
`is_primitive_root.coe_units_iff` should provide the necessary glue.

-/


open Classical BigOperators Polynomial

noncomputable section

open Polynomial

open Finset

variable {M N G G₀ R S F : Type _}

variable [CommMonoidₓ M] [CommMonoidₓ N] [CommGroupₓ G] [CommGroupWithZero G₀]

section rootsOfUnity

variable {k l : ℕ+}

/-- `roots_of_unity k M` is the subgroup of elements `m : Mˣ` that satisfy `m ^ k = 1` -/
def rootsOfUnity (k : ℕ+) (M : Type _) [CommMonoidₓ M] : Subgroup Mˣ where
  Carrier := { ζ | ζ ^ (k : ℕ) = 1 }
  one_mem' := one_pow _
  mul_mem' := fun ζ ξ hζ hξ => by
    simp_all only [Set.mem_set_of_eq, mul_powₓ, one_mulₓ]
  inv_mem' := fun ζ hζ => by
    simp_all only [Set.mem_set_of_eq, inv_pow, one_inv]

@[simp]
theorem mem_roots_of_unity (k : ℕ+) (ζ : Mˣ) : ζ ∈ rootsOfUnity k M ↔ ζ ^ (k : ℕ) = 1 :=
  Iff.rfl

theorem rootsOfUnity.coe_injective {n : ℕ+} : Function.Injective (coe : rootsOfUnity n M → M) :=
  Units.ext.comp fun x y => Subtype.ext

/-- Make an element of `roots_of_unity` from a member of the base ring, and a proof that it has
a positive power equal to one. -/
@[simps coe_coe]
def rootsOfUnity.mkOfPowEq (ζ : M) {n : ℕ+} (h : ζ ^ (n : ℕ) = 1) : rootsOfUnity n M :=
  ⟨Units.mkOfMulEqOne ζ (ζ ^ n.natPred) <| by
      rwa [← pow_oneₓ ζ, ← pow_mulₓ, ← pow_addₓ, one_mulₓ, Pnat.one_add_nat_pred],
    Units.ext <| by
      simpa⟩

@[simp]
theorem rootsOfUnity.coe_mk_of_pow_eq {ζ : M} {n : ℕ+} (h : ζ ^ (n : ℕ) = 1) : (rootsOfUnity.mkOfPowEq _ h : M) = ζ :=
  rfl

theorem roots_of_unity_le_of_dvd (h : k ∣ l) : rootsOfUnity k M ≤ rootsOfUnity l M := by
  obtain ⟨d, rfl⟩ := h
  intro ζ h
  simp_all only [mem_roots_of_unity, Pnat.mul_coe, pow_mulₓ, one_pow]

theorem map_roots_of_unity (f : Mˣ →* Nˣ) (k : ℕ+) : (rootsOfUnity k M).map f ≤ rootsOfUnity k N := by
  rintro _ ⟨ζ, h, rfl⟩
  simp_all only [← map_pow, mem_roots_of_unity, SetLike.mem_coe, MonoidHom.map_one]

@[norm_cast]
theorem rootsOfUnity.coe_pow [CommMonoidₓ R] (ζ : rootsOfUnity k R) (m : ℕ) : ↑(ζ ^ m) = (ζ ^ m : R) := by
  change ↑(↑(ζ ^ m) : Rˣ) = ↑(ζ : Rˣ) ^ m
  rw [Subgroup.coe_pow, Units.coe_pow]

section CommSemiringₓ

variable [CommSemiringₓ R] [CommSemiringₓ S]

/-- Restrict a ring homomorphism to the nth roots of unity -/
def restrictRootsOfUnity [RingHomClass F R S] (σ : F) (n : ℕ+) : rootsOfUnity n R →* rootsOfUnity n S :=
  let h : ∀ ξ : rootsOfUnity n R, σ ξ ^ (n : ℕ) = 1 := fun ξ => by
    change σ (ξ : Rˣ) ^ (n : ℕ) = 1
    rw [← map_pow, ← Units.coe_pow, show (ξ : Rˣ) ^ (n : ℕ) = 1 from ξ.2, Units.coe_one, map_one σ]
  { toFun := fun ξ =>
      ⟨@unitOfInvertible _ _ _ (invertibleOfPowEqOne _ _ (h ξ) n.2), by
        ext
        rw [Units.coe_pow]
        exact h ξ⟩,
    map_one' := by
      ext
      exact map_one σ,
    map_mul' := fun ξ₁ ξ₂ => by
      ext
      rw [Subgroup.coe_mul, Units.coe_mul]
      exact map_mul σ _ _ }

@[simp]
theorem restrict_roots_of_unity_coe_apply [RingHomClass F R S] (σ : F) (ζ : rootsOfUnity k R) :
    ↑(restrictRootsOfUnity σ k ζ) = σ ↑ζ :=
  rfl

/-- Restrict a ring isomorphism to the nth roots of unity -/
def RingEquiv.restrictRootsOfUnity (σ : R ≃+* S) (n : ℕ+) : rootsOfUnity n R ≃* rootsOfUnity n S where
  toFun := restrictRootsOfUnity σ.toRingHom n
  invFun := restrictRootsOfUnity σ.symm.toRingHom n
  left_inv := fun ξ => by
    ext
    exact σ.symm_apply_apply ξ
  right_inv := fun ξ => by
    ext
    exact σ.apply_symm_apply ξ
  map_mul' := (restrictRootsOfUnity _ n).map_mul

@[simp]
theorem RingEquiv.restrict_roots_of_unity_coe_apply (σ : R ≃+* S) (ζ : rootsOfUnity k R) :
    ↑(σ.restrictRootsOfUnity k ζ) = σ ↑ζ :=
  rfl

@[simp]
theorem RingEquiv.restrict_roots_of_unity_symm (σ : R ≃+* S) :
    (σ.restrictRootsOfUnity k).symm = σ.symm.restrictRootsOfUnity k :=
  rfl

end CommSemiringₓ

section IsDomain

variable [CommRingₓ R] [IsDomain R]

theorem mem_roots_of_unity_iff_mem_nth_roots {ζ : Rˣ} : ζ ∈ rootsOfUnity k R ↔ (ζ : R) ∈ nthRoots k (1 : R) := by
  simp only [mem_roots_of_unity, mem_nth_roots k.pos, Units.ext_iff, Units.coe_one, Units.coe_pow]

variable (k R)

/-- Equivalence between the `k`-th roots of unity in `R` and the `k`-th roots of `1`.

This is implemented as equivalence of subtypes,
because `roots_of_unity` is a subgroup of the group of units,
whereas `nth_roots` is a multiset. -/
def rootsOfUnityEquivNthRoots : rootsOfUnity k R ≃ { x // x ∈ nthRoots k (1 : R) } := by
  refine'
    { toFun := fun x => ⟨x, mem_roots_of_unity_iff_mem_nth_roots.mp x.2⟩,
      invFun := fun x => ⟨⟨x, x ^ (k - 1 : ℕ), _, _⟩, _⟩, left_inv := _, right_inv := _ }
  pick_goal 4
  · rintro ⟨x, hx⟩
    ext
    rfl
    
  pick_goal 4
  · rintro ⟨x, hx⟩
    ext
    rfl
    
  all_goals
    rcases x with ⟨x, hx⟩
    rw [mem_nth_roots k.pos] at hx
    simp only [Subtype.coe_mk, ← pow_succₓ, ← pow_succ'ₓ, hx, tsub_add_cancel_of_le (show 1 ≤ (k : ℕ) from k.one_le)]
  · show (_ : Rˣ) ^ (k : ℕ) = 1
    simp only [Units.ext_iff, hx, Units.coe_mk, Units.coe_one, Subtype.coe_mk, Units.coe_pow]
    

variable {k R}

@[simp]
theorem roots_of_unity_equiv_nth_roots_apply (x : rootsOfUnity k R) : (rootsOfUnityEquivNthRoots R k x : R) = x :=
  rfl

@[simp]
theorem roots_of_unity_equiv_nth_roots_symm_apply (x : { x // x ∈ nthRoots k (1 : R) }) :
    ((rootsOfUnityEquivNthRoots R k).symm x : R) = x :=
  rfl

variable (k R)

instance rootsOfUnity.fintype : Fintype (rootsOfUnity k R) :=
  Fintype.ofEquiv { x // x ∈ nthRoots k (1 : R) } <| (rootsOfUnityEquivNthRoots R k).symm

instance rootsOfUnity.is_cyclic : IsCyclic (rootsOfUnity k R) :=
  is_cyclic_of_subgroup_is_domain ((Units.coeHom R).comp (rootsOfUnity k R).Subtype)
    (Units.ext.comp Subtype.val_injective)

theorem card_roots_of_unity : Fintype.card (rootsOfUnity k R) ≤ k :=
  calc
    Fintype.card (rootsOfUnity k R) = Fintype.card { x // x ∈ nthRoots k (1 : R) } :=
      Fintype.card_congr (rootsOfUnityEquivNthRoots R k)
    _ ≤ (nthRoots k (1 : R)).attach.card := Multiset.card_le_of_le (Multiset.dedup_le _)
    _ = (nthRoots k (1 : R)).card := Multiset.card_attach
    _ ≤ k := card_nth_roots k 1
    

variable {k R}

theorem map_root_of_unity_eq_pow_self [RingHomClass F R R] (σ : F) (ζ : rootsOfUnity k R) : ∃ m : ℕ, σ ζ = ζ ^ m := by
  obtain ⟨m, hm⟩ := MonoidHom.map_cyclic (restrictRootsOfUnity σ k)
  rw [← restrict_roots_of_unity_coe_apply, hm, zpow_eq_mod_order_of, ←
    Int.to_nat_of_nonneg (m.mod_nonneg (int.coe_nat_ne_zero.mpr (pos_iff_ne_zero.mp (order_of_pos ζ)))), zpow_coe_nat,
    rootsOfUnity.coe_pow]
  exact ⟨(m % orderOf ζ).toNat, rfl⟩

end IsDomain

end rootsOfUnity

/-- An element `ζ` is a primitive `k`-th root of unity if `ζ ^ k = 1`,
and if `l` satisfies `ζ ^ l = 1` then `k ∣ l`. -/
structure IsPrimitiveRoot (ζ : M) (k : ℕ) : Prop where
  pow_eq_one : ζ ^ (k : ℕ) = 1
  dvd_of_pow_eq_one : ∀ l : ℕ, ζ ^ l = 1 → k ∣ l

/-- Turn a primitive root μ into a member of the `roots_of_unity` subgroup. -/
@[simps]
def IsPrimitiveRoot.toRootsOfUnity {μ : M} {n : ℕ+} (h : IsPrimitiveRoot μ n) : rootsOfUnity n M :=
  rootsOfUnity.mkOfPowEq μ h.pow_eq_one

section primitiveRoots

variable {k : ℕ}

/-- `primitive_roots k R` is the finset of primitive `k`-th roots of unity
in the integral domain `R`. -/
def primitiveRoots (k : ℕ) (R : Type _) [CommRingₓ R] [IsDomain R] : Finset R :=
  (nthRoots k (1 : R)).toFinset.filter fun ζ => IsPrimitiveRoot ζ k

variable [CommRingₓ R] [IsDomain R]

@[simp]
theorem mem_primitive_roots {ζ : R} (h0 : 0 < k) : ζ ∈ primitiveRoots k R ↔ IsPrimitiveRoot ζ k := by
  rw [primitiveRoots, mem_filter, Multiset.mem_to_finset, mem_nth_roots h0, and_iff_right_iff_imp]
  exact IsPrimitiveRoot.pow_eq_one

end primitiveRoots

namespace IsPrimitiveRoot

variable {k l : ℕ}

theorem iff_def (ζ : M) (k : ℕ) : IsPrimitiveRoot ζ k ↔ ζ ^ k = 1 ∧ ∀ l : ℕ, ζ ^ l = 1 → k ∣ l :=
  ⟨fun ⟨h1, h2⟩ => ⟨h1, h2⟩, fun ⟨h1, h2⟩ => ⟨h1, h2⟩⟩

theorem mk_of_lt (ζ : M) (hk : 0 < k) (h1 : ζ ^ k = 1) (h : ∀ l : ℕ, 0 < l → l < k → ζ ^ l ≠ 1) : IsPrimitiveRoot ζ k :=
  by
  refine' ⟨h1, _⟩
  intro l hl
  apply dvd_trans _ (k.gcd_dvd_right l)
  suffices k.gcd l = k by
    rw [this]
  rw [eq_iff_le_not_lt]
  refine' ⟨Nat.le_of_dvdₓ hk (k.gcd_dvd_left l), _⟩
  intro h'
  apply h _ (Nat.gcd_pos_of_pos_leftₓ _ hk) h'
  exact pow_gcd_eq_one _ h1 hl

section CommMonoidₓ

variable {ζ : M} (h : IsPrimitiveRoot ζ k)

@[nontriviality]
theorem of_subsingleton [Subsingleton M] (x : M) : IsPrimitiveRoot x 1 :=
  ⟨Subsingleton.elimₓ _ _, fun _ _ => one_dvd _⟩

theorem pow_eq_one_iff_dvd (l : ℕ) : ζ ^ l = 1 ↔ k ∣ l :=
  ⟨h.dvd_of_pow_eq_one l, by
    rintro ⟨i, rfl⟩
    simp only [pow_mulₓ, h.pow_eq_one, one_pow, Pnat.mul_coe]⟩

theorem is_unit (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) : IsUnit ζ := by
  apply is_unit_of_mul_eq_one ζ (ζ ^ (k - 1))
  rw [← pow_succₓ, tsub_add_cancel_of_le h0.nat_succ_le, h.pow_eq_one]

theorem pow_ne_one_of_pos_of_lt (h0 : 0 < l) (hl : l < k) : ζ ^ l ≠ 1 :=
  mt (Nat.le_of_dvdₓ h0 ∘ h.dvd_of_pow_eq_one _) <| not_le_of_lt hl

theorem pow_inj (h : IsPrimitiveRoot ζ k) ⦃i j : ℕ⦄ (hi : i < k) (hj : j < k) (H : ζ ^ i = ζ ^ j) : i = j := by
  wlog hij : i ≤ j
  apply le_antisymmₓ hij
  rw [← tsub_eq_zero_iff_le]
  apply Nat.eq_zero_of_dvd_of_lt _ (lt_of_le_of_ltₓ tsub_le_self hj)
  apply h.dvd_of_pow_eq_one
  rw [← ((h.is_unit (lt_of_le_of_ltₓ (Nat.zero_leₓ _) hi)).pow i).mul_left_inj, ← pow_addₓ, tsub_add_cancel_of_le hij,
    H, one_mulₓ]

theorem one : IsPrimitiveRoot (1 : M) 1 :=
  { pow_eq_one := pow_oneₓ _, dvd_of_pow_eq_one := fun l hl => one_dvd _ }

@[simp]
theorem one_right_iff : IsPrimitiveRoot ζ 1 ↔ ζ = 1 := by
  constructor
  · intro h
    rw [← pow_oneₓ ζ, h.pow_eq_one]
    
  · rintro rfl
    exact one
    

@[simp]
theorem coe_submonoid_class_iff {M B : Type _} [CommMonoidₓ M] [SetLike B M] [SubmonoidClass B M] {N : B} {ζ : N} :
    IsPrimitiveRoot (ζ : M) k ↔ IsPrimitiveRoot ζ k := by
  simp [iff_def, ← SubmonoidClass.coe_pow]

@[simp]
theorem coe_units_iff {ζ : Mˣ} : IsPrimitiveRoot (ζ : M) k ↔ IsPrimitiveRoot ζ k := by
  simp only [iff_def, Units.ext_iff, Units.coe_pow, Units.coe_one]

theorem pow_of_coprime (h : IsPrimitiveRoot ζ k) (i : ℕ) (hi : i.Coprime k) : IsPrimitiveRoot (ζ ^ i) k := by
  by_cases' h0 : k = 0
  · subst k
    simp_all only [pow_oneₓ, Nat.coprime_zero_rightₓ]
    
  rcases h.is_unit (Nat.pos_of_ne_zeroₓ h0) with ⟨ζ, rfl⟩
  rw [← Units.coe_pow]
  rw [coe_units_iff] at h⊢
  refine'
    { pow_eq_one := by
        rw [← pow_mul', pow_mulₓ, h.pow_eq_one, one_pow],
      dvd_of_pow_eq_one := _ }
  intro l hl
  apply h.dvd_of_pow_eq_one
  rw [← pow_oneₓ ζ, ← zpow_coe_nat ζ, ← hi.gcd_eq_one, Nat.gcd_eq_gcd_ab, zpow_add, mul_powₓ, ← zpow_coe_nat, ←
    zpow_mul, mul_right_commₓ]
  simp only [zpow_mul, hl, h.pow_eq_one, one_zpow, one_pow, one_mulₓ, zpow_coe_nat]

theorem pow_of_prime (h : IsPrimitiveRoot ζ k) {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ k) :
    IsPrimitiveRoot (ζ ^ p) k :=
  h.pow_of_coprime p (hprime.coprime_iff_not_dvd.2 hdiv)

-- ././Mathport/Syntax/Translate/Tactic/Lean3.lean:95:4: warning: unsupported: rw with cfg: { occs := occurrences.pos «expr[ ,]»([1]) }
theorem pow_iff_coprime (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) (i : ℕ) : IsPrimitiveRoot (ζ ^ i) k ↔ i.Coprime k := by
  refine' ⟨_, h.pow_of_coprime i⟩
  intro hi
  obtain ⟨a, ha⟩ := i.gcd_dvd_left k
  obtain ⟨b, hb⟩ := i.gcd_dvd_right k
  suffices b = k by
    rwa [this, ← one_mulₓ k, Nat.mul_left_inj h0, eq_comm] at hb
  rw [ha] at hi
  rw [mul_comm] at hb
  apply Nat.dvd_antisymm ⟨i.gcd k, hb⟩ (hi.dvd_of_pow_eq_one b _)
  rw [← pow_mul', ← mul_assoc, ← hb, pow_mulₓ, h.pow_eq_one, one_pow]

protected theorem order_of (ζ : M) : IsPrimitiveRoot ζ (orderOf ζ) :=
  ⟨pow_order_of_eq_one ζ, fun l => order_of_dvd_of_pow_eq_one⟩

theorem unique {ζ : M} (hk : IsPrimitiveRoot ζ k) (hl : IsPrimitiveRoot ζ l) : k = l := by
  wlog hkl : k ≤ l
  rcases hkl.eq_or_lt with (rfl | hkl)
  · rfl
    
  rcases k.eq_zero_or_pos with (rfl | hk')
  · exact (zero_dvd_iff.mp <| hk.dvd_of_pow_eq_one l hl.pow_eq_one).symm
    
  exact absurd hk.pow_eq_one (hl.pow_ne_one_of_pos_of_lt hk' hkl)

theorem eq_order_of : k = orderOf ζ :=
  h.unique (IsPrimitiveRoot.order_of ζ)

protected theorem iff (hk : 0 < k) : IsPrimitiveRoot ζ k ↔ ζ ^ k = 1 ∧ ∀ l : ℕ, 0 < l → l < k → ζ ^ l ≠ 1 := by
  refine' ⟨fun h => ⟨h.pow_eq_one, fun l hl' hl => _⟩, fun ⟨hζ, hl⟩ => IsPrimitiveRoot.mk_of_lt ζ hk hζ hl⟩
  rw [h.eq_order_of] at hl
  exact pow_ne_one_of_lt_order_of' hl'.ne' hl

protected theorem not_iff : ¬IsPrimitiveRoot ζ k ↔ orderOf ζ ≠ k :=
  ⟨fun h hk => h <| hk ▸ IsPrimitiveRoot.order_of ζ, fun h hk => h.symm <| hk.unique <| IsPrimitiveRoot.order_of ζ⟩

theorem pow_of_dvd (h : IsPrimitiveRoot ζ k) {p : ℕ} (hp : p ≠ 0) (hdiv : p ∣ k) : IsPrimitiveRoot (ζ ^ p) (k / p) := by
  suffices orderOf (ζ ^ p) = k / p by
    exact this ▸ IsPrimitiveRoot.order_of (ζ ^ p)
  rw [order_of_pow' _ hp, ← eq_order_of h, Nat.gcd_eq_rightₓ hdiv]

protected theorem mem_roots_of_unity {ζ : Mˣ} {n : ℕ+} (h : IsPrimitiveRoot ζ n) : ζ ∈ rootsOfUnity n M :=
  h.pow_eq_one

/-- If there is a `n`-th primitive root of unity in `R` and `b` divides `n`,
then there is a `b`-th primitive root of unity in `R`. -/
theorem pow {n : ℕ} {a b : ℕ} (hn : 0 < n) (h : IsPrimitiveRoot ζ n) (hprod : n = a * b) : IsPrimitiveRoot (ζ ^ a) b :=
  by
  subst n
  simp only [iff_def, ← pow_mulₓ, h.pow_eq_one, eq_self_iff_true, true_andₓ]
  intro l hl
  have ha0 : a ≠ 0 := by
    rintro rfl
    simpa only [Nat.not_lt_zeroₓ, zero_mul] using hn
  rwa [← mul_dvd_mul_iff_left ha0]
  exact h.dvd_of_pow_eq_one _ hl

end CommMonoidₓ

section CommMonoidWithZero

variable {M₀ : Type _} [CommMonoidWithZero M₀]

theorem zero [Nontrivial M₀] : IsPrimitiveRoot (0 : M₀) 0 :=
  ⟨pow_zeroₓ 0, fun l hl => by
    simpa [zero_pow_eq, show ∀ p, ¬p → False ↔ p from @not_not] using hl⟩

protected theorem ne_zero [Nontrivial M₀] {ζ : M₀} (h : IsPrimitiveRoot ζ k) : k ≠ 0 → ζ ≠ 0 :=
  mt fun hn => h.unique (hn.symm ▸ IsPrimitiveRoot.zero)

end CommMonoidWithZero

section CommGroupₓ

variable {ζ : G}

theorem zpow_eq_one (h : IsPrimitiveRoot ζ k) : ζ ^ (k : ℤ) = 1 := by
  rw [zpow_coe_nat]
  exact h.pow_eq_one

theorem zpow_eq_one_iff_dvd (h : IsPrimitiveRoot ζ k) (l : ℤ) : ζ ^ l = 1 ↔ (k : ℤ) ∣ l := by
  by_cases' h0 : 0 ≤ l
  · lift l to ℕ using h0
    rw [zpow_coe_nat]
    norm_cast
    exact h.pow_eq_one_iff_dvd l
    
  · have : 0 ≤ -l := by
      simp only [not_leₓ, neg_nonneg] at h0⊢
      exact le_of_ltₓ h0
    lift -l to ℕ using this with l' hl'
    rw [← dvd_neg, ← hl']
    norm_cast
    rw [← h.pow_eq_one_iff_dvd, ← inv_inj, ← zpow_neg, ← hl', zpow_coe_nat, one_inv]
    

theorem inv (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot ζ⁻¹ k :=
  { pow_eq_one := by
      simp only [h.pow_eq_one, one_inv, eq_self_iff_true, inv_pow],
    dvd_of_pow_eq_one := by
      intro l hl
      apply h.dvd_of_pow_eq_one l
      rw [← inv_inj, ← inv_pow, hl, one_inv] }

@[simp]
theorem inv_iff : IsPrimitiveRoot ζ⁻¹ k ↔ IsPrimitiveRoot ζ k := by
  refine' ⟨_, fun h => inv h⟩
  intro h
  rw [← inv_invₓ ζ]
  exact inv h

theorem zpow_of_gcd_eq_one (h : IsPrimitiveRoot ζ k) (i : ℤ) (hi : i.gcd k = 1) : IsPrimitiveRoot (ζ ^ i) k := by
  by_cases' h0 : 0 ≤ i
  · lift i to ℕ using h0
    rw [zpow_coe_nat]
    exact h.pow_of_coprime i hi
    
  have : 0 ≤ -i := by
    simp only [not_leₓ, neg_nonneg] at h0⊢
    exact le_of_ltₓ h0
  lift -i to ℕ using this with i' hi'
  rw [← inv_iff, ← zpow_neg, ← hi', zpow_coe_nat]
  apply h.pow_of_coprime
  rw [Int.gcdₓ, ← Int.nat_abs_neg, ← hi'] at hi
  exact hi

end CommGroupₓ

section CommGroupWithZero

variable {ζ : G₀}

theorem zpow_eq_one₀ (h : IsPrimitiveRoot ζ k) : ζ ^ (k : ℤ) = 1 := by
  rw [zpow_coe_nat]
  exact h.pow_eq_one

theorem zpow_eq_one_iff_dvd₀ (h : IsPrimitiveRoot ζ k) (l : ℤ) : ζ ^ l = 1 ↔ (k : ℤ) ∣ l := by
  by_cases' h0 : 0 ≤ l
  · lift l to ℕ using h0
    rw [zpow_coe_nat]
    norm_cast
    exact h.pow_eq_one_iff_dvd l
    
  · have : 0 ≤ -l := by
      simp only [not_leₓ, neg_nonneg] at h0⊢
      exact le_of_ltₓ h0
    lift -l to ℕ using this with l' hl'
    rw [← dvd_neg, ← hl']
    norm_cast
    rw [← h.pow_eq_one_iff_dvd, ← inv_inj, ← zpow_neg₀, ← hl', zpow_coe_nat, inv_one]
    

theorem inv' (h : IsPrimitiveRoot ζ k) : IsPrimitiveRoot ζ⁻¹ k :=
  { pow_eq_one := by
      simp only [h.pow_eq_one, inv_one, eq_self_iff_true, inv_pow₀],
    dvd_of_pow_eq_one := by
      intro l hl
      apply h.dvd_of_pow_eq_one l
      rw [← inv_inj, ← inv_pow₀, hl, inv_one] }

@[simp]
theorem inv_iff' : IsPrimitiveRoot ζ⁻¹ k ↔ IsPrimitiveRoot ζ k := by
  refine' ⟨_, fun h => inv' h⟩
  intro h
  rw [← inv_invₓ ζ]
  exact inv' h

theorem zpow_of_gcd_eq_one₀ (h : IsPrimitiveRoot ζ k) (i : ℤ) (hi : i.gcd k = 1) : IsPrimitiveRoot (ζ ^ i) k := by
  by_cases' h0 : 0 ≤ i
  · lift i to ℕ using h0
    rw [zpow_coe_nat]
    exact h.pow_of_coprime i hi
    
  have : 0 ≤ -i := by
    simp only [not_leₓ, neg_nonneg] at h0⊢
    exact le_of_ltₓ h0
  lift -i to ℕ using this with i' hi'
  rw [← inv_iff', ← zpow_neg₀, ← hi', zpow_coe_nat]
  apply h.pow_of_coprime
  rw [Int.gcdₓ, ← Int.nat_abs_neg, ← hi'] at hi
  exact hi

end CommGroupWithZero

section CommSemiringₓ

variable [CommSemiringₓ R] [CommSemiringₓ S] {f : F} {ζ : R}

open Function

theorem map_of_injective [MonoidHomClass F R S] (h : IsPrimitiveRoot ζ k) (hf : Injective f) :
    IsPrimitiveRoot (f ζ) k :=
  { pow_eq_one := by
      rw [← map_pow, h.pow_eq_one, _root_.map_one],
    dvd_of_pow_eq_one := by
      rw [h.eq_order_of]
      intro l hl
      rw [← map_pow, ← map_one f] at hl
      exact order_of_dvd_of_pow_eq_one (hf hl) }

theorem of_map_of_injective [MonoidHomClass F R S] (h : IsPrimitiveRoot (f ζ) k) (hf : Injective f) :
    IsPrimitiveRoot ζ k :=
  { pow_eq_one := by
      apply_fun f
      rw [map_pow, _root_.map_one, h.pow_eq_one],
    dvd_of_pow_eq_one := by
      rw [h.eq_order_of]
      intro l hl
      apply_fun f  at hl
      rw [map_pow, _root_.map_one] at hl
      exact order_of_dvd_of_pow_eq_one hl }

theorem map_iff_of_injective [MonoidHomClass F R S] (hf : Injective f) :
    IsPrimitiveRoot (f ζ) k ↔ IsPrimitiveRoot ζ k :=
  ⟨fun h => h.of_map_of_injective hf, fun h => h.map_of_injective hf⟩

end CommSemiringₓ

section IsDomain

variable {ζ : R}

variable [CommRingₓ R] [IsDomain R]

@[simp]
theorem primitive_roots_zero : primitiveRoots 0 R = ∅ := by
  rw [← Finset.val_eq_zero, ← Multiset.subset_zero, ← nth_roots_zero (1 : R), primitiveRoots]
  simp only [Finset.not_mem_empty, forall_const, forall_prop_of_false, Multiset.to_finset_zero,
    Finset.filter_true_of_mem, Finset.empty_val, not_false_iff, Multiset.zero_subset, nth_roots_zero]

@[simp]
theorem primitive_roots_one : primitiveRoots 1 R = {(1 : R)} := by
  apply Finset.eq_singleton_iff_unique_mem.2
  constructor
  · simp only [IsPrimitiveRoot.one_right_iff, mem_primitive_roots zero_lt_one]
    
  · intro x hx
    rw [mem_primitive_roots zero_lt_one, IsPrimitiveRoot.one_right_iff] at hx
    exact hx
    

end IsDomain

section IsDomain

variable [CommRingₓ R]

variable {ζ : Rˣ} (h : IsPrimitiveRoot ζ k)

theorem eq_neg_one_of_two_right [NoZeroDivisors R] {ζ : R} (h : IsPrimitiveRoot ζ 2) : ζ = -1 := by
  apply (eq_or_eq_neg_of_sq_eq_sq ζ 1 _).resolve_left
  · rw [← pow_oneₓ ζ]
    apply h.pow_ne_one_of_pos_of_lt <;> decide
    
  · simp only [h.pow_eq_one, one_pow]
    

theorem neg_one (p : ℕ) [Nontrivial R] [h : CharP R p] (hp : p ≠ 2) : IsPrimitiveRoot (-1 : R) 2 := by
  convert IsPrimitiveRoot.order_of (-1 : R)
  rw [order_of_neg_one, if_neg]
  rwa [ring_char.eq_iff.mpr h]

/-- The (additive) monoid equivalence between `zmod k`
and the powers of a primitive root of unity `ζ`. -/
def zmodEquivZpowers (h : IsPrimitiveRoot ζ k) : Zmod k ≃+ Additive (Subgroup.zpowers ζ) :=
  AddEquiv.ofBijective
    (AddMonoidHom.liftOfRightInverse (Int.castAddHom <| Zmod k) _ Zmod.int_cast_right_inverse
      ⟨{ toFun := fun i => Additive.ofMul (⟨_, i, rfl⟩ : Subgroup.zpowers ζ),
          map_zero' := by
            simp only [zpow_zero]
            rfl,
          map_add' := by
            intro i j
            simp only [zpow_add]
            rfl },
        fun i hi => by
        simp only [AddMonoidHom.mem_ker, CharP.int_cast_eq_zero_iff (Zmod k) k, AddMonoidHom.coe_mk,
          Int.coe_cast_add_hom] at hi⊢
        obtain ⟨i, rfl⟩ := hi
        simp only [zpow_mul, h.pow_eq_one, one_zpow, zpow_coe_nat]
        rfl⟩)
    (by
      constructor
      · rw [injective_iff_map_eq_zero]
        intro i hi
        rw [Subtype.ext_iff] at hi
        have := (h.zpow_eq_one_iff_dvd _).mp hi
        rw [← (CharP.int_cast_eq_zero_iff (Zmod k) k _).mpr this, eq_comm]
        exact Zmod.int_cast_right_inverse i
        
      · rintro ⟨ξ, i, rfl⟩
        refine' ⟨Int.castAddHom _ i, _⟩
        rw [AddMonoidHom.lift_of_right_inverse_comp_apply]
        rfl
        )

@[simp]
theorem zmod_equiv_zpowers_apply_coe_int (i : ℤ) :
    h.zmodEquivZpowers i = Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ) :=
  AddMonoidHom.lift_of_right_inverse_comp_apply _ _ Zmod.int_cast_right_inverse _ _

@[simp]
theorem zmod_equiv_zpowers_apply_coe_nat (i : ℕ) :
    h.zmodEquivZpowers i = Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ) := by
  have : (i : Zmod k) = (i : ℤ) := by
    norm_cast
  simp only [this, zmod_equiv_zpowers_apply_coe_int, zpow_coe_nat]
  rfl

@[simp]
theorem zmod_equiv_zpowers_symm_apply_zpow (i : ℤ) :
    h.zmodEquivZpowers.symm (Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ)) = i := by
  rw [← h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_int]

@[simp]
theorem zmod_equiv_zpowers_symm_apply_zpow' (i : ℤ) : h.zmodEquivZpowers.symm ⟨ζ ^ i, i, rfl⟩ = i :=
  h.zmod_equiv_zpowers_symm_apply_zpow i

@[simp]
theorem zmod_equiv_zpowers_symm_apply_pow (i : ℕ) :
    h.zmodEquivZpowers.symm (Additive.ofMul (⟨ζ ^ i, i, rfl⟩ : Subgroup.zpowers ζ)) = i := by
  rw [← h.zmod_equiv_zpowers.symm_apply_apply i, zmod_equiv_zpowers_apply_coe_nat]

@[simp]
theorem zmod_equiv_zpowers_symm_apply_pow' (i : ℕ) : h.zmodEquivZpowers.symm ⟨ζ ^ i, i, rfl⟩ = i :=
  h.zmod_equiv_zpowers_symm_apply_pow i

variable [IsDomain R]

theorem zpowers_eq {k : ℕ+} {ζ : Rˣ} (h : IsPrimitiveRoot ζ k) : Subgroup.zpowers ζ = rootsOfUnity k R := by
  apply SetLike.coe_injective
  have : Fact (0 < (k : ℕ)) := ⟨k.pos⟩
  have F : Fintype (Subgroup.zpowers ζ) := Fintype.ofEquiv _ h.zmod_equiv_zpowers.toEquiv
  refine'
    @Set.eq_of_subset_of_card_le Rˣ (Subgroup.zpowers ζ) (rootsOfUnity k R) F (rootsOfUnity.fintype R k)
      (Subgroup.zpowers_subset <| show ζ ∈ rootsOfUnity k R from h.pow_eq_one) _
  calc Fintype.card (rootsOfUnity k R) ≤ k := card_roots_of_unity R k _ = Fintype.card (Zmod k) :=
      (Zmod.card k).symm _ = Fintype.card (Subgroup.zpowers ζ) := Fintype.card_congr h.zmod_equiv_zpowers.toEquiv

theorem eq_pow_of_mem_roots_of_unity {k : ℕ+} {ζ ξ : Rˣ} (h : IsPrimitiveRoot ζ k) (hξ : ξ ∈ rootsOfUnity k R) :
    ∃ (i : ℕ)(hi : i < k), ζ ^ i = ξ := by
  obtain ⟨n, rfl⟩ : ∃ n : ℤ, ζ ^ n = ξ := by
    rwa [← h.zpowers_eq] at hξ
  have hk0 : (0 : ℤ) < k := by
    exact_mod_cast k.pos
  let i := n % k
  have hi0 : 0 ≤ i := Int.mod_nonneg _ (ne_of_gtₓ hk0)
  lift i to ℕ using hi0 with i₀ hi₀
  refine' ⟨i₀, _, _⟩
  · zify
    rw [hi₀]
    exact Int.mod_lt_of_pos _ hk0
    
  · have aux := h.zpow_eq_one
    rw [← coe_coe] at aux
    rw [← zpow_coe_nat, hi₀, ← Int.mod_add_div n k, zpow_add, zpow_mul, aux, one_zpow, mul_oneₓ]
    

theorem eq_pow_of_pow_eq_one {k : ℕ} {ζ ξ : R} (h : IsPrimitiveRoot ζ k) (hξ : ξ ^ k = 1) (h0 : 0 < k) :
    ∃ i < k, ζ ^ i = ξ := by
  obtain ⟨ζ, rfl⟩ := h.is_unit h0
  obtain ⟨ξ, rfl⟩ := is_unit_of_pow_eq_one ξ k hξ h0
  obtain ⟨k, rfl⟩ : ∃ k' : ℕ+, k = k' := ⟨⟨k, h0⟩, rfl⟩
  simp only [← Units.coe_pow, ← Units.ext_iff]
  rw [coe_units_iff] at h
  apply h.eq_pow_of_mem_roots_of_unity
  rw [mem_roots_of_unity, Units.ext_iff, Units.coe_pow, hξ, Units.coe_one]

theorem is_primitive_root_iff' {k : ℕ+} {ζ ξ : Rˣ} (h : IsPrimitiveRoot ζ k) :
    IsPrimitiveRoot ξ k ↔ ∃ i < (k : ℕ), ∃ hi : i.Coprime k, ζ ^ i = ξ := by
  constructor
  · intro hξ
    obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_mem_roots_of_unity hξ.pow_eq_one
    rw [h.pow_iff_coprime k.pos] at hξ
    exact ⟨i, hik, hξ, rfl⟩
    
  · rintro ⟨i, -, hi, rfl⟩
    exact h.pow_of_coprime i hi
    

theorem is_primitive_root_iff {k : ℕ} {ζ ξ : R} (h : IsPrimitiveRoot ζ k) (h0 : 0 < k) :
    IsPrimitiveRoot ξ k ↔ ∃ i < k, ∃ hi : i.Coprime k, ζ ^ i = ξ := by
  constructor
  · intro hξ
    obtain ⟨i, hik, rfl⟩ := h.eq_pow_of_pow_eq_one hξ.pow_eq_one h0
    rw [h.pow_iff_coprime h0] at hξ
    exact ⟨i, hik, hξ, rfl⟩
    
  · rintro ⟨i, -, hi, rfl⟩
    exact h.pow_of_coprime i hi
    

theorem card_roots_of_unity' {n : ℕ+} (h : IsPrimitiveRoot ζ n) : Fintype.card (rootsOfUnity n R) = n := by
  have : Fact (0 < ↑n) := ⟨n.pos⟩
  let e := h.zmod_equiv_zpowers
  have F : Fintype (Subgroup.zpowers ζ) := Fintype.ofEquiv _ e.to_equiv
  calc Fintype.card (rootsOfUnity n R) = Fintype.card (Subgroup.zpowers ζ) :=
      Fintype.card_congr <| by
        rw [h.zpowers_eq]_ = Fintype.card (Zmod n) :=
      Fintype.card_congr e.to_equiv.symm _ = n := Zmod.card n

theorem card_roots_of_unity {ζ : R} {n : ℕ+} (h : IsPrimitiveRoot ζ n) : Fintype.card (rootsOfUnity n R) = n := by
  obtain ⟨ζ, hζ⟩ := h.is_unit n.pos
  rw [← hζ, IsPrimitiveRoot.coe_units_iff] at h
  exact h.card_roots_of_unity'

/-- The cardinality of the multiset `nth_roots ↑n (1 : R)` is `n`
if there is a primitive root of unity in `R`. -/
theorem card_nth_roots {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) : (nthRoots n (1 : R)).card = n := by
  cases' Nat.eq_zero_or_posₓ n with hzero hpos
  · simp only [hzero, Multiset.card_zero, nth_roots_zero]
    
  rw [eq_iff_le_not_lt]
  use card_nth_roots n 1
  · rw [not_ltₓ]
    have hcard : Fintype.card { x // x ∈ nth_roots n (1 : R) } ≤ (nth_roots n (1 : R)).attach.card :=
      Multiset.card_le_of_le (Multiset.dedup_le _)
    rw [Multiset.card_attach] at hcard
    rw [← Pnat.to_pnat'_coe hpos] at hcard h⊢
    set m := Nat.toPnat' n
    rw [← Fintype.card_congr (rootsOfUnityEquivNthRoots R m), card_roots_of_unity h] at hcard
    exact hcard
    

/-- The multiset `nth_roots ↑n (1 : R)` has no repeated elements
if there is a primitive root of unity in `R`. -/
theorem nth_roots_nodup {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) : (nthRoots n (1 : R)).Nodup := by
  cases' Nat.eq_zero_or_posₓ n with hzero hpos
  · simp only [hzero, Multiset.nodup_zero, nth_roots_zero]
    
  apply (@Multiset.dedup_eq_self R _ _).1
  rw [eq_iff_le_not_lt]
  constructor
  · exact Multiset.dedup_le (nth_roots n (1 : R))
    
  · by_contra ha
    replace ha := Multiset.card_lt_of_lt ha
    rw [card_nth_roots h] at ha
    have hrw : (nth_roots n (1 : R)).dedup.card = Fintype.card { x // x ∈ nth_roots n (1 : R) } := by
      set fs := (⟨(nth_roots n (1 : R)).dedup, Multiset.nodup_dedup _⟩ : Finset R)
      rw [← Finset.card_mk, ← Fintype.card_of_subtype fs _]
      intro x
      simp only [Multiset.mem_dedup, Finset.mem_mk]
    rw [← Pnat.to_pnat'_coe hpos] at h hrw ha
    set m := Nat.toPnat' n
    rw [hrw, ← Fintype.card_congr (rootsOfUnityEquivNthRoots R m), card_roots_of_unity h] at ha
    exact Nat.lt_asymmₓ ha ha
    

@[simp]
theorem card_nth_roots_finset {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) : (nthRootsFinset n R).card = n := by
  rw [nth_roots_finset, ← Multiset.to_finset_eq (nth_roots_nodup h), card_mk, h.card_nth_roots]

open Nat

/-- If an integral domain has a primitive `k`-th root of unity, then it has `φ k` of them. -/
theorem card_primitive_roots {ζ : R} {k : ℕ} (h : IsPrimitiveRoot ζ k) : (primitiveRoots k R).card = φ k := by
  by_cases' h0 : k = 0
  · simp [h0]
    
  symm
  refine' Finset.card_congr (fun i _ => ζ ^ i) _ _ _
  · simp only [true_andₓ, and_imp, mem_filter, mem_range, mem_univ]
    rintro i - hi
    rw [mem_primitive_roots (Nat.pos_of_ne_zeroₓ h0)]
    exact h.pow_of_coprime i hi.symm
    
  · simp only [true_andₓ, and_imp, mem_filter, mem_range, mem_univ]
    rintro i j hi - hj - H
    exact h.pow_inj hi hj H
    
  · simp only [exists_prop, true_andₓ, mem_filter, mem_range, mem_univ]
    intro ξ hξ
    rw [mem_primitive_roots (Nat.pos_of_ne_zeroₓ h0), h.is_primitive_root_iff (Nat.pos_of_ne_zeroₓ h0)] at hξ
    rcases hξ with ⟨i, hin, hi, H⟩
    exact ⟨i, ⟨hin, hi.symm⟩, H⟩
    

-- ././Mathport/Syntax/Translate/Tactic/Basic.lean:53:9: parse error
/-- The sets `primitive_roots k R` are pairwise disjoint. -/
theorem disjoint {k l : ℕ} (h : k ≠ l) : Disjoint (primitiveRoots k R) (primitiveRoots l R) := by
  by_cases' hk : k = 0
  · simp [hk]
    
  by_cases' hl : l = 0
  · simp [hl]
    
  intro z
  simp only [Finset.inf_eq_inter, Finset.mem_inter, mem_primitive_roots, Nat.pos_of_ne_zeroₓ hk, Nat.pos_of_ne_zeroₓ hl,
    iff_def]
  rintro ⟨⟨hzk, Hzk⟩, ⟨hzl, Hzl⟩⟩
  apply_rules [h, Nat.dvd_antisymm, Hzk, Hzl, hzk, hzl]

-- ././Mathport/Syntax/Translate/Tactic/Lean3.lean:95:4: warning: unsupported: rw with cfg: { occs := occurrences.pos «expr[ ,]»([1]) }
/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`.
This holds for any `nat`, not just `pnat`, see `nth_roots_one_eq_bUnion_primitive_roots`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots' {ζ : R} {n : ℕ+} (h : IsPrimitiveRoot ζ n) :
    nthRootsFinset n R = (Nat.divisors ↑n).bUnion fun i => primitiveRoots i R := by
  symm
  apply Finset.eq_of_subset_of_card_le
  · intro x
    simp only [nth_roots_finset, ← Multiset.to_finset_eq (nth_roots_nodup h), exists_prop, Finset.mem_bUnion,
      Finset.mem_filter, Finset.mem_range, mem_nth_roots, Finset.mem_mk, Nat.mem_divisors, and_trueₓ, Ne.def,
      Pnat.ne_zero, Pnat.pos, not_false_iff]
    rintro ⟨a, ⟨d, hd⟩, ha⟩
    have hazero : 0 < a := by
      contrapose! hd with ha0
      simp_all only [nonpos_iff_eq_zero, zero_mul]
      exact n.ne_zero
    rw [mem_primitive_roots hazero] at ha
    rw [hd, pow_mulₓ, ha.pow_eq_one, one_pow]
    
  · apply le_of_eqₓ
    rw [h.card_nth_roots_finset, Finset.card_bUnion]
    · rw [← Nat.sum_totient n, Nat.filter_dvd_eq_divisors (Pnat.ne_zero n), sum_congr rfl]
      simp only [Finset.mem_filter, Finset.mem_range, Nat.mem_divisors]
      rintro k ⟨H, hk⟩
      have hdvd := H
      rcases H with ⟨d, hd⟩
      rw [mul_comm] at hd
      rw [(h.pow n.pos hd).card_primitive_roots]
      
    · intro i hi j hj hdiff
      exact Disjoint hdiff
      
    

/-- `nth_roots n` as a `finset` is equal to the union of `primitive_roots i R` for `i ∣ n`
if there is a primitive root of unity in `R`. -/
theorem nth_roots_one_eq_bUnion_primitive_roots {ζ : R} {n : ℕ} (h : IsPrimitiveRoot ζ n) :
    nthRootsFinset n R = (Nat.divisors n).bUnion fun i => primitiveRoots i R := by
  by_cases' hn : n = 0
  · simp [hn]
    
  exact @nth_roots_one_eq_bUnion_primitive_roots' _ _ _ _ ⟨n, Nat.pos_of_ne_zeroₓ hn⟩ h

end IsDomain

section minpoly

open minpoly

section CommRingₓ

variable {n : ℕ} {K : Type _} [CommRingₓ K] {μ : K} (h : IsPrimitiveRoot μ n) (hpos : 0 < n)

include n μ h hpos

/-- `μ` is integral over `ℤ`. -/
theorem is_integral : IsIntegral ℤ μ := by
  use X ^ n - 1
  constructor
  · exact monic_X_pow_sub_C 1 (ne_of_ltₓ hpos).symm
    
  · simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, eval₂_one, eval₂_X_pow, eval₂_sub, sub_self]
    

end CommRingₓ

variable {n : ℕ} {K : Type _} [Field K] {μ : K} (h : IsPrimitiveRoot μ n) (hpos : 0 < n)

include n μ h hpos

variable [CharZero K]

omit hpos

/-- The minimal polynomial of a root of unity `μ` divides `X ^ n - 1`. -/
theorem minpoly_dvd_X_pow_sub_one : minpoly ℤ μ ∣ X ^ n - 1 := by
  by_cases' hpos : n = 0
  · simp [hpos]
    
  apply
    minpoly.gcd_domain_dvd ℚ (IsIntegral h (Nat.pos_of_ne_zeroₓ hpos))
      (Polynomial.Monic.is_primitive (monic_X_pow_sub_C 1 (ne_of_ltₓ (Nat.pos_of_ne_zeroₓ hpos)).symm))
  simp only [((IsPrimitiveRoot.iff_def μ n).mp h).left, aeval_X_pow, RingHom.eq_int_cast, Int.cast_oneₓ, aeval_one,
    AlgHom.map_sub, sub_self]

/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is separable. -/
theorem separable_minpoly_mod {p : ℕ} [Fact p.Prime] (hdiv : ¬p ∣ n) :
    Separable (map (Int.castRingHom (Zmod p)) (minpoly ℤ μ)) := by
  have hdvd : map (Int.castRingHom (Zmod p)) (minpoly ℤ μ) ∣ X ^ n - 1 := by
    simpa [Polynomial.map_pow, map_X, Polynomial.map_one, Polynomial.map_sub] using
      RingHom.map_dvd (map_ring_hom (Int.castRingHom (Zmod p))) (minpoly_dvd_X_pow_sub_one h)
  refine' separable.of_dvd (separable_X_pow_sub_C 1 _ one_ne_zero) hdvd
  by_contra hzero
  exact hdiv ((Zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 hzero)

/-- The reduction modulo `p` of the minimal polynomial of a root of unity `μ` is squarefree. -/
theorem squarefree_minpoly_mod {p : ℕ} [Fact p.Prime] (hdiv : ¬p ∣ n) :
    Squarefree (map (Int.castRingHom (Zmod p)) (minpoly ℤ μ)) :=
  (separable_minpoly_mod h hdiv).Squarefree

/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of
`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `expand ℤ p Q`. -/
theorem minpoly_dvd_expand {p : ℕ} (hprime : Nat.Prime p) (hdiv : ¬p ∣ n) :
    minpoly ℤ μ ∣ expand ℤ p (minpoly ℤ (μ ^ p)) := by
  by_cases' hn : n = 0
  · simp_all
    
  have hpos := Nat.pos_of_ne_zeroₓ hn
  apply minpoly.gcd_domain_dvd ℚ (h.is_integral hpos)
  · apply monic.is_primitive
    rw [Polynomial.Monic, leading_coeff, nat_degree_expand, mul_comm, coeff_expand_mul' (Nat.Prime.pos hprime), ←
      leading_coeff, ← Polynomial.Monic]
    exact minpoly.monic (IsIntegral (pow_of_prime h hprime hdiv) hpos)
    
  · rw [aeval_def, coe_expand, ← comp, eval₂_eq_eval_map, map_comp, Polynomial.map_pow, map_X, eval_comp, eval_pow,
      eval_X, ← eval₂_eq_eval_map, ← aeval_def]
    exact minpoly.aeval _ _
    

/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of
`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q ^ p` modulo `p`. -/
theorem minpoly_dvd_pow_mod {p : ℕ} [hprime : Fact p.Prime] (hdiv : ¬p ∣ n) :
    map (Int.castRingHom (Zmod p)) (minpoly ℤ μ) ∣ map (Int.castRingHom (Zmod p)) (minpoly ℤ (μ ^ p)) ^ p := by
  set Q := minpoly ℤ (μ ^ p)
  have hfrob : map (Int.castRingHom (Zmod p)) Q ^ p = map (Int.castRingHom (Zmod p)) (expand ℤ p Q) := by
    rw [← Zmod.expand_card, map_expand]
  rw [hfrob]
  apply RingHom.map_dvd (map_ring_hom (Int.castRingHom (Zmod p)))
  exact minpoly_dvd_expand h hprime.1 hdiv

/- Let `P` be the minimal polynomial of a root of unity `μ` and `Q` be the minimal polynomial of
`μ ^ p`, where `p` is a prime that does not divide `n`. Then `P` divides `Q` modulo `p`. -/
theorem minpoly_dvd_mod_p {p : ℕ} [hprime : Fact p.Prime] (hdiv : ¬p ∣ n) :
    map (Int.castRingHom (Zmod p)) (minpoly ℤ μ) ∣ map (Int.castRingHom (Zmod p)) (minpoly ℤ (μ ^ p)) :=
  (UniqueFactorizationMonoid.dvd_pow_iff_dvd_of_squarefree (squarefree_minpoly_mod h hdiv) hprime.1.ne_zero).1
    (minpoly_dvd_pow_mod h hdiv)

/-- If `p` is a prime that does not divide `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ p` are the same. -/
theorem minpoly_eq_pow {p : ℕ} [hprime : Fact p.Prime] (hdiv : ¬p ∣ n) : minpoly ℤ μ = minpoly ℤ (μ ^ p) := by
  by_cases' hn : n = 0
  · simp_all
    
  have hpos := Nat.pos_of_ne_zeroₓ hn
  by_contra hdiff
  set P := minpoly ℤ μ
  set Q := minpoly ℤ (μ ^ p)
  have Pmonic : P.monic := minpoly.monic (h.is_integral hpos)
  have Qmonic : Q.monic := minpoly.monic ((h.pow_of_prime hprime.1 hdiv).IsIntegral hpos)
  have Pirr : Irreducible P := minpoly.irreducible (h.is_integral hpos)
  have Qirr : Irreducible Q := minpoly.irreducible ((h.pow_of_prime hprime.1 hdiv).IsIntegral hpos)
  have PQprim : is_primitive (P * Q) := Pmonic.is_primitive.mul Qmonic.is_primitive
  have prod : P * Q ∣ X ^ n - 1 := by
    rw
      [is_primitive.int.dvd_iff_map_cast_dvd_map_cast (P * Q) (X ^ n - 1) PQprim
        (monic_X_pow_sub_C (1 : ℤ) (ne_of_gtₓ hpos)).IsPrimitive,
      Polynomial.map_mul]
    refine' IsCoprime.mul_dvd _ _ _
    · have aux := is_primitive.int.irreducible_iff_irreducible_map_cast Pmonic.is_primitive
      refine' (dvd_or_coprime _ _ (aux.1 Pirr)).resolve_left _
      rw [map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Pmonic]
      intro hdiv
      refine' hdiff (eq_of_monic_of_associated Pmonic Qmonic _)
      exact associated_of_dvd_dvd hdiv (Pirr.dvd_symm Qirr hdiv)
      
    · apply (map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Pmonic).2
      exact minpoly_dvd_X_pow_sub_one h
      
    · apply (map_dvd_map (Int.castRingHom ℚ) Int.cast_injective Qmonic).2
      exact minpoly_dvd_X_pow_sub_one (pow_of_prime h hprime.1 hdiv)
      
  replace prod := RingHom.map_dvd (map_ring_hom (Int.castRingHom (Zmod p))) Prod
  rw [coe_map_ring_hom, Polynomial.map_mul, Polynomial.map_sub, Polynomial.map_one, Polynomial.map_pow, map_X] at prod
  obtain ⟨R, hR⟩ := minpoly_dvd_mod_p h hdiv
  rw [hR, ← mul_assoc, ← Polynomial.map_mul, ← sq, Polynomial.map_pow] at prod
  have habs : map (Int.castRingHom (Zmod p)) P ^ 2 ∣ map (Int.castRingHom (Zmod p)) P ^ 2 * R := by
    use R
  replace habs :=
    lt_of_lt_of_leₓ (Enat.coe_lt_coe.2 one_lt_two) (multiplicity.le_multiplicity_of_pow_dvd (dvd_trans habs Prod))
  have hfree : Squarefree (X ^ n - 1 : (Zmod p)[X]) :=
    (separable_X_pow_sub_C 1 (fun h => hdiv <| (Zmod.nat_coe_zmod_eq_zero_iff_dvd n p).1 h) one_ne_zero).Squarefree
  cases' (multiplicity.squarefree_iff_multiplicity_le_one (X ^ n - 1)).1 hfree (map (Int.castRingHom (Zmod p)) P) with
    hle hunit
  · rw [Nat.cast_oneₓ] at habs
    exact hle.not_lt habs
    
  · replace hunit := degree_eq_zero_of_is_unit hunit
    rw [degree_map_eq_of_leading_coeff_ne_zero (Int.castRingHom (Zmod p)) _] at hunit
    · exact (minpoly.degree_pos (IsIntegral h hpos)).ne' hunit
      
    simp only [Pmonic, RingHom.eq_int_cast, monic.leading_coeff, Int.cast_oneₓ, Ne.def, not_false_iff, one_ne_zero]
    

/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomials of a primitive `n`-th root of unity `μ`
and of `μ ^ m` are the same. -/
theorem minpoly_eq_pow_coprime {m : ℕ} (hcop : Nat.Coprime m n) : minpoly ℤ μ = minpoly ℤ (μ ^ m) := by
  revert n hcop
  refine' UniqueFactorizationMonoid.induction_on_prime m _ _ _
  · intro n hn h
    congr
    simpa [(Nat.coprime_zero_leftₓ n).mp hn] using h
    
  · intro u hunit n hcop h
    congr
    simp [nat.is_unit_iff.mp hunit]
    
  · intro a p ha hprime hind n hcop h
    rw [hind (Nat.Coprime.coprime_mul_left hcop) h]
    clear hind
    replace hprime := Nat.prime_iff.2 hprime
    have hdiv := (Nat.Prime.coprime_iff_not_dvd hprime).1 (Nat.Coprime.coprime_mul_right hcop)
    have := Fact.mk hprime
    rw [minpoly_eq_pow (h.pow_of_coprime a (Nat.Coprime.coprime_mul_left hcop)) hdiv]
    congr 1
    ring_exp
    

/-- If `m : ℕ` is coprime with `n`,
then the minimal polynomial of a primitive `n`-th root of unity `μ`
has `μ ^ m` as root. -/
theorem pow_is_root_minpoly {m : ℕ} (hcop : Nat.Coprime m n) : IsRoot (map (Int.castRingHom K) (minpoly ℤ μ)) (μ ^ m) :=
  by
  simpa [minpoly_eq_pow_coprime h hcop, eval_map, aeval_def (μ ^ m) _] using minpoly.aeval ℤ (μ ^ m)

/-- `primitive_roots n K` is a subset of the roots of the minimal polynomial of a primitive
`n`-th root of unity `μ`. -/
theorem is_roots_of_minpoly : primitiveRoots n K ⊆ (map (Int.castRingHom K) (minpoly ℤ μ)).roots.toFinset := by
  by_cases' hn : n = 0
  · simp_all
    
  have hpos := Nat.pos_of_ne_zeroₓ hn
  intro x hx
  obtain ⟨m, hle, hcop, rfl⟩ := (is_primitive_root_iff h hpos).1 ((mem_primitive_roots hpos).1 hx)
  simpa [Multiset.mem_to_finset, mem_roots (map_monic_ne_zero <| minpoly.monic <| IsIntegral h hpos)] using
    pow_is_root_minpoly h hcop

/-- The degree of the minimal polynomial of `μ` is at least `totient n`. -/
theorem totient_le_degree_minpoly : Nat.totient n ≤ (minpoly ℤ μ).natDegree :=
  let P : ℤ[X] := minpoly ℤ μ
  let
    P_K :-- minimal polynomial of `μ`
      K[X] :=
    map (Int.castRingHom K) P
  -- minimal polynomial of `μ` sent to `K[X]`
  calc
    n.totient = (primitiveRoots n K).card := h.card_primitive_roots.symm
    _ ≤ P_K.roots.toFinset.card := Finset.card_le_of_subset (is_roots_of_minpoly h)
    _ ≤ P_K.roots.card := Multiset.to_finset_card_le _
    _ ≤ P_K.natDegree := card_roots' _
    _ ≤ P.natDegree := nat_degree_map_le _ _
    

end minpoly

section Automorphisms

variable {S} [CommRingₓ S] [IsDomain S] {μ : S} {n : ℕ+} (hμ : IsPrimitiveRoot μ n) (R) [CommRingₓ R] [Algebra R S]

-- ././Mathport/Syntax/Translate/Tactic/Lean3.lean:95:4: warning: unsupported: rw with cfg: { occs := occurrences.pos «expr[ ,]»([1]) }
/-- The `monoid_hom` that takes an automorphism to the power of μ that μ gets mapped to under it. -/
@[simps (config := { attrs := [] })]
noncomputable def autToPow : (S ≃ₐ[R] S) →* (Zmod n)ˣ :=
  let μ' := hμ.toRootsOfUnity
  have ho : orderOf μ' = n := by
    rw [hμ.eq_order_of, ← hμ.coe_to_roots_of_unity_coe, order_of_units, order_of_subgroup]
  MonoidHom.toHomUnits
    { toFun := fun σ => (map_root_of_unity_eq_pow_self σ.toAlgHom μ').some,
      map_one' := by
        generalize_proofs h1
        have h := h1.some_spec
        dsimp only [AlgEquiv.one_apply, AlgEquiv.to_ring_equiv_eq_coe, RingEquiv.to_ring_hom_eq_coe,
          RingEquiv.coe_to_ring_hom, AlgEquiv.coe_ring_equiv]  at *
        replace h : μ' = μ' ^ h1.some :=
          rootsOfUnity.coe_injective
            (by
              simpa only [rootsOfUnity.coe_pow] using h)
        rw [← pow_oneₓ μ'] at h
        rw [← @Nat.cast_oneₓ <| Zmod n, Zmod.nat_coe_eq_nat_coe_iff, ← ho, ← pow_eq_pow_iff_modeq μ', h],
      map_mul' := by
        generalize_proofs hxy' hx' hy'
        have hxy := hxy'.some_spec
        have hx := hx'.some_spec
        have hy := hy'.some_spec
        dsimp only [AlgEquiv.to_ring_equiv_eq_coe, RingEquiv.to_ring_hom_eq_coe, RingEquiv.coe_to_ring_hom,
          AlgEquiv.coe_ring_equiv, AlgEquiv.mul_apply]  at *
        replace hxy : x (↑μ' ^ hy'.some) = ↑μ' ^ hxy'.some := hy ▸ hxy
        rw [x.map_pow] at hxy
        replace hxy : ((μ' : S) ^ hx'.some) ^ hy'.some = μ' ^ hxy'.some := hx ▸ hxy
        rw [← pow_mulₓ] at hxy
        replace hxy : μ' ^ (hx'.some * hy'.some) = μ' ^ hxy'.some :=
          rootsOfUnity.coe_injective
            (by
              simpa only [rootsOfUnity.coe_pow] using hxy)
        rw [← Nat.cast_mulₓ, Zmod.nat_coe_eq_nat_coe_iff, ← ho, ← pow_eq_pow_iff_modeq μ', hxy] }

@[simp]
theorem aut_to_pow_spec (f : S ≃ₐ[R] S) : μ ^ (hμ.autToPow R f : Zmod n).val = f μ := by
  rw [IsPrimitiveRoot.coe_aut_to_pow_apply]
  generalize_proofs h
  have := h.some_spec
  dsimp only [AlgEquiv.to_alg_hom_eq_coe, AlgEquiv.coe_alg_hom]  at this
  refine' (_ : ↑hμ.to_roots_of_unity ^ _ = _).trans this.symm
  rw [← rootsOfUnity.coe_pow, ← rootsOfUnity.coe_pow]
  congr 1
  rw [pow_eq_pow_iff_modeq, ← order_of_subgroup, ← order_of_units, hμ.coe_to_roots_of_unity_coe, ← hμ.eq_order_of,
    Zmod.val_nat_cast]
  exact Nat.mod_modeq _ _

end Automorphisms

end IsPrimitiveRoot

