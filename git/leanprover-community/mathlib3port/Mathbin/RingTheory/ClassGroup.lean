/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import Mathbin.GroupTheory.QuotientGroup
import Mathbin.RingTheory.DedekindDomain.Ideal

/-!
# The ideal class group

This file defines the ideal class group `class_group R K` of fractional ideals of `R`
inside `A`'s field of fractions `K`.

## Main definitions
 - `to_principal_ideal` sends an invertible `x : K` to an invertible fractional ideal
 - `class_group` is the quotient of invertible fractional ideals modulo `to_principal_ideal.range`
 - `class_group.mk0` sends a nonzero integral ideal in a Dedekind domain to its class

## Main results
 - `class_group.mk0_eq_mk0_iff` shows the equivalence with the "classical" definition,
   where `I ~ J` iff `x I = y J` for `x y ≠ (0 : R)`
-/


variable {R K L : Type _} [CommRingₓ R]

variable [Field K] [Field L] [DecidableEq L]

variable [Algebra R K] [IsFractionRing R K]

variable [Algebra K L] [FiniteDimensional K L]

variable [Algebra R L] [IsScalarTower R K L]

open nonZeroDivisors

open IsLocalization IsFractionRing FractionalIdeal Units

section

variable (R K)

/-- `to_principal_ideal R K x` sends `x ≠ 0 : K` to the fractional `R`-ideal generated by `x` -/
irreducible_def toPrincipalIdeal : Kˣ →* (FractionalIdeal R⁰ K)ˣ :=
  { toFun := fun x =>
      ⟨spanSingleton _ x, spanSingleton _ x⁻¹, by
        simp only [span_singleton_one, Units.mul_inv', span_singleton_mul_span_singleton], by
        simp only [span_singleton_one, Units.inv_mul', span_singleton_mul_span_singleton]⟩,
    map_mul' := fun x y =>
      ext
        (by
          simp only [Units.coe_mk, Units.coe_mul, span_singleton_mul_span_singleton]),
    map_one' :=
      ext
        (by
          simp only [span_singleton_one, Units.coe_mk, Units.coe_one]) }

attribute [local semireducible] toPrincipalIdeal

variable {R K}

@[simp]
theorem coe_to_principal_ideal (x : Kˣ) : (toPrincipalIdeal R K x : FractionalIdeal R⁰ K) = spanSingleton _ x :=
  rfl

@[simp]
theorem to_principal_ideal_eq_iff {I : (FractionalIdeal R⁰ K)ˣ} {x : Kˣ} :
    toPrincipalIdeal R K x = I ↔ spanSingleton R⁰ (x : K) = I :=
  Units.ext_iff

end

instance PrincipalIdeals.normal : (toPrincipalIdeal R K).range.Normal :=
  Subgroup.normal_of_comm _

section

variable (R K)

/-- The ideal class group of `R` in a field of fractions `K`
is the group of invertible fractional ideals modulo the principal ideals. -/
def ClassGroup :=
  (FractionalIdeal R⁰ K)ˣ ⧸ (toPrincipalIdeal R K).range deriving CommGroupₓ

instance : Inhabited (ClassGroup R K) :=
  ⟨1⟩

variable {R} [IsDomain R]

/-- Send a nonzero integral ideal to an invertible fractional ideal. -/
@[simps]
noncomputable def FractionalIdeal.mk0 [IsDedekindDomain R] : (Ideal R)⁰ →* (FractionalIdeal R⁰ K)ˣ where
  toFun := fun I =>
    Units.mk0 I
      ((FractionalIdeal.coe_to_fractional_ideal_ne_zero (le_reflₓ R⁰)).mpr (mem_non_zero_divisors_iff_ne_zero.mp I.2))
  map_one' := by
    simp
  map_mul' := fun x y => by
    simp

/-- Send a nonzero ideal to the corresponding class in the class group. -/
@[simps]
noncomputable def ClassGroup.mk0 [IsDedekindDomain R] : (Ideal R)⁰ →* ClassGroup R K :=
  (QuotientGroup.mk' _).comp (FractionalIdeal.mk0 K)

variable {K}

-- ./././Mathport/Syntax/Translate/Basic.lean:556:2: warning: expanding binder collection (x «expr ≠ » (0 : K))
theorem ClassGroup.mk0_eq_mk0_iff_exists_fraction_ring [IsDedekindDomain R] {I J : (Ideal R)⁰} :
    ClassGroup.mk0 K I = ClassGroup.mk0 K J ↔ ∃ (x : _)(_ : x ≠ (0 : K)), spanSingleton R⁰ x * I = J := by
  simp only [ClassGroup.mk0, MonoidHom.comp_apply, QuotientGroup.mk'_eq_mk']
  constructor
  · rintro ⟨_, ⟨x, rfl⟩, hx⟩
    refine' ⟨x, x.ne_zero, _⟩
    simpa only [mul_comm, coe_mk0, MonoidHom.to_fun_eq_coe, coe_to_principal_ideal, Units.coe_mul] using
      congr_arg (coe : _ → FractionalIdeal R⁰ K) hx
    
  · rintro ⟨x, hx, eq_J⟩
    refine' ⟨_, ⟨Units.mk0 x hx, rfl⟩, Units.ext _⟩
    simpa only [FractionalIdeal.mk0_apply, Units.coe_mk0, mul_comm, coe_to_principal_ideal, coe_coe,
      Units.coe_mul] using eq_J
    

theorem ClassGroup.mk0_eq_mk0_iff [IsDedekindDomain R] {I J : (Ideal R)⁰} :
    ClassGroup.mk0 K I = ClassGroup.mk0 K J ↔
      ∃ (x y : R)(hx : x ≠ 0)(hy : y ≠ 0), Ideal.span {x} * (I : Ideal R) = Ideal.span {y} * J :=
  by
  refine' class_group.mk0_eq_mk0_iff_exists_fraction_ring.trans ⟨_, _⟩
  · rintro ⟨z, hz, h⟩
    obtain ⟨x, ⟨y, hy⟩, rfl⟩ := IsLocalization.mk'_surjective R⁰ z
    refine' ⟨x, y, _, mem_non_zero_divisors_iff_ne_zero.mp hy, _⟩
    · rintro hx
      apply hz
      rw [hx, IsFractionRing.mk'_eq_div, (algebraMap R K).map_zero, zero_div]
      
    · exact (FractionalIdeal.mk'_mul_coe_ideal_eq_coe_ideal K hy).mp h
      
    
  · rintro ⟨x, y, hx, hy, h⟩
    have hy' : y ∈ R⁰ := mem_non_zero_divisors_iff_ne_zero.mpr hy
    refine' ⟨IsLocalization.mk' K x ⟨y, hy'⟩, _, _⟩
    · contrapose! hx
      rwa [IsLocalization.mk'_eq_iff_eq_mul, zero_mul, ← (algebraMap R K).map_zero,
        (IsFractionRing.injective R K).eq_iff] at hx
      
    · exact (FractionalIdeal.mk'_mul_coe_ideal_eq_coe_ideal K hy').mpr h
      
    

theorem ClassGroup.mk0_surjective [IsDedekindDomain R] :
    Function.Surjective (ClassGroup.mk0 K : (Ideal R)⁰ → ClassGroup R K) := by
  rintro ⟨I⟩
  obtain ⟨a, a_ne_zero', ha⟩ := I.1.2
  have a_ne_zero := mem_non_zero_divisors_iff_ne_zero.mp a_ne_zero'
  have fa_ne_zero : (algebraMap R K) a ≠ 0 := IsFractionRing.to_map_ne_zero_of_mem_non_zero_divisors a_ne_zero'
  refine' ⟨⟨{ Carrier := { x | (algebraMap R K a)⁻¹ * algebraMap R K x ∈ I.1 }.. }, _⟩, _⟩
  · simp only [RingHom.map_add, Set.mem_set_of_eq, mul_zero, RingHom.map_mul, mul_addₓ]
    exact fun _ _ ha hb => Submodule.add_mem I ha hb
    
  · simp only [RingHom.map_zero, Set.mem_set_of_eq, mul_zero, RingHom.map_mul]
    exact Submodule.zero_mem I
    
  · intro c _ hb
    simp only [smul_eq_mul, Set.mem_set_of_eq, mul_zero, RingHom.map_mul, mul_addₓ,
      mul_left_commₓ ((algebraMap R K) a)⁻¹]
    rw [← Algebra.smul_def c]
    exact Submodule.smul_mem I c hb
    
  · rw [mem_non_zero_divisors_iff_ne_zero, Submodule.zero_eq_bot, Submodule.ne_bot_iff]
    obtain ⟨x, x_ne, x_mem⟩ := exists_ne_zero_mem_is_integer I.ne_zero
    refine' ⟨a * x, _, mul_ne_zero a_ne_zero x_ne⟩
    change ((algebraMap R K) a)⁻¹ * (algebraMap R K) (a * x) ∈ I.1
    rwa [RingHom.map_mul, ← mul_assoc, inv_mul_cancel fa_ne_zero, one_mulₓ]
    
  · symm
    apply Quotientₓ.sound
    change Setoidₓ.R _ _
    rw [QuotientGroup.left_rel_apply]
    refine' ⟨Units.mk0 (algebraMap R K a) fa_ne_zero, _⟩
    apply @mul_left_cancelₓ _ _ I
    rw [← mul_assoc, mul_right_invₓ, one_mulₓ, eq_comm, mul_comm I]
    apply Units.ext
    simp only [MonoidHom.coe_mk, Subtype.coe_mk, RingHom.map_mul, coe_coe, Units.coe_mul, coe_to_principal_ideal,
      coe_mk0, FractionalIdeal.eq_span_singleton_mul]
    constructor
    · intro zJ' hzJ'
      obtain ⟨zJ, hzJ : (algebraMap R K a)⁻¹ * algebraMap R K zJ ∈ ↑I, rfl⟩ := (mem_coe_ideal R⁰).mp hzJ'
      refine' ⟨_, hzJ, _⟩
      rw [← mul_assoc, mul_inv_cancel fa_ne_zero, one_mulₓ]
      
    · intro zI' hzI'
      obtain ⟨y, hy⟩ := ha zI' hzI'
      rw [← Algebra.smul_def, FractionalIdeal.mk0_apply, coe_mk0, coe_coe, mem_coe_ideal]
      refine' ⟨y, _, hy⟩
      show (algebraMap R K a)⁻¹ * algebraMap R K y ∈ (I : FractionalIdeal R⁰ K)
      rwa [hy, Algebra.smul_def, ← mul_assoc, inv_mul_cancel fa_ne_zero, one_mulₓ]
      
    

end

theorem ClassGroup.mk_eq_one_iff {I : (FractionalIdeal R⁰ K)ˣ} :
    QuotientGroup.mk' (toPrincipalIdeal R K).range I = 1 ↔ (I : Submodule R K).IsPrincipal := by
  rw [← (QuotientGroup.mk' _).map_one, eq_comm, QuotientGroup.mk'_eq_mk']
  simp only [exists_prop, one_mulₓ, exists_eq_right, to_principal_ideal_eq_iff, MonoidHom.mem_range, coe_coe]
  refine'
    ⟨fun ⟨x, hx⟩ =>
      ⟨⟨x, by
          rw [← hx, coe_span_singleton]⟩⟩,
      _⟩
  intro hI
  obtain ⟨x, hx⟩ := @Submodule.IsPrincipal.principal _ _ _ _ _ _ hI
  have hx' : (I : FractionalIdeal R⁰ K) = span_singleton R⁰ x := by
    apply Subtype.coe_injective
    rw [hx, coe_span_singleton]
  refine' ⟨Units.mk0 x _, _⟩
  · intro x_eq
    apply Units.ne_zero I
    simp [hx', x_eq]
    
  simp [hx']

variable [IsDomain R]

theorem ClassGroup.mk0_eq_one_iff [IsDedekindDomain R] {I : Ideal R} (hI : I ∈ (Ideal R)⁰) :
    ClassGroup.mk0 K ⟨I, hI⟩ = 1 ↔ I.IsPrincipal :=
  ClassGroup.mk_eq_one_iff.trans (coe_submodule_is_principal R K)

/-- The class group of principal ideal domain is finite (in fact a singleton).
TODO: generalize to Dedekind domains -/
instance [IsPrincipalIdealRing R] : Fintype (ClassGroup R K) where
  elems := {1}
  complete := by
    rintro ⟨I⟩
    rw [Finset.mem_singleton]
    exact class_group.mk_eq_one_iff.mpr (I : FractionalIdeal R⁰ K).IsPrincipal

/-- The class number of a principal ideal domain is `1`. -/
theorem card_class_group_eq_one [IsPrincipalIdealRing R] : Fintype.card (ClassGroup R K) = 1 := by
  rw [Fintype.card_eq_one_iff]
  use 1
  rintro ⟨I⟩
  exact class_group.mk_eq_one_iff.mpr (I : FractionalIdeal R⁰ K).IsPrincipal

/-- The class number is `1` iff the ring of integers is a principal ideal domain. -/
theorem card_class_group_eq_one_iff [IsDedekindDomain R] [Fintype (ClassGroup R K)] :
    Fintype.card (ClassGroup R K) = 1 ↔ IsPrincipalIdealRing R := by
  constructor
  swap
  · intros
    convert card_class_group_eq_one
    assumption
    assumption
    
  rw [Fintype.card_eq_one_iff]
  rintro ⟨I, hI⟩
  have eq_one : ∀ J : ClassGroup R K, J = 1 := fun J => trans (hI J) (hI 1).symm
  refine' ⟨fun I => _⟩
  by_cases' hI : I = ⊥
  · rw [hI]
    exact bot_is_principal
    
  exact (ClassGroup.mk0_eq_one_iff (mem_non_zero_divisors_iff_ne_zero.mpr hI)).mp (eq_one _)

