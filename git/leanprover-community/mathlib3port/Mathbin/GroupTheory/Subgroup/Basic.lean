/-
Copyright (c) 2020 Kexing Ying. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kexing Ying
-/
import Mathbin.GroupTheory.Submonoid.Pointwise
import Mathbin.GroupTheory.Submonoid.Membership
import Mathbin.GroupTheory.Submonoid.Centralizer
import Mathbin.Algebra.Group.Conj
import Mathbin.Algebra.Module.Basic
import Mathbin.Order.Atoms
import Mathbin.Order.SupIndep

/-!
# Subgroups

This file defines multiplicative and additive subgroups as an extension of submonoids, in a bundled
form (unbundled subgroups are in `deprecated/subgroups.lean`).

We prove subgroups of a group form a complete lattice, and results about images and preimages of
subgroups under group homomorphisms. The bundled subgroups use bundled monoid homomorphisms.

There are also theorems about the subgroups generated by an element or a subset of a group,
defined both inductively and as the infimum of the set of subgroups containing a given
element/subset.

Special thanks goes to Amelia Livingston and Yury Kudryashov for their help and inspiration.

## Main definitions

Notation used here:

- `G N` are `group`s

- `A` is an `add_group`

- `H K` are `subgroup`s of `G` or `add_subgroup`s of `A`

- `x` is an element of type `G` or type `A`

- `f g : N →* G` are group homomorphisms

- `s k` are sets of elements of type `G`

Definitions in the file:

* `subgroup G` : the type of subgroups of a group `G`

* `add_subgroup A` : the type of subgroups of an additive group `A`

* `complete_lattice (subgroup G)` : the subgroups of `G` form a complete lattice

* `subgroup.closure k` : the minimal subgroup that includes the set `k`

* `subgroup.subtype` : the natural group homomorphism from a subgroup of group `G` to `G`

* `subgroup.gi` : `closure` forms a Galois insertion with the coercion to set

* `subgroup.comap H f` : the preimage of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `subgroup.map f H` : the image of a subgroup `H` along the group homomorphism `f` is also a
  subgroup

* `subgroup.prod H K` : the product of subgroups `H`, `K` of groups `G`, `N` respectively, `H × K`
  is a subgroup of `G × N`

* `monoid_hom.range f` : the range of the group homomorphism `f` is a subgroup

* `monoid_hom.ker f` : the kernel of a group homomorphism `f` is the subgroup of elements `x : G`
  such that `f x = 1`

* `monoid_hom.eq_locus f g` : given group homomorphisms `f`, `g`, the elements of `G` such that
  `f x = g x` form a subgroup of `G`

* `is_simple_group G` : a class indicating that a group has exactly two normal subgroups

## Implementation notes

Subgroup inclusion is denoted `≤` rather than `⊆`, although `∈` is defined as
membership of a subgroup's underlying set.

## Tags
subgroup, subgroups
-/


open BigOperators Pointwise

variable {G : Type _} [Groupₓ G]

variable {A : Type _} [AddGroupₓ A]

section SubgroupClass

/-- `inv_mem_class S G` states `S` is a type of subsets `s ⊆ G` closed under inverses. -/
class InvMemClass (S G : Type _) [Inv G] [SetLike S G] where
  inv_mem : ∀ {s : S} {x}, x ∈ s → x⁻¹ ∈ s

export InvMemClass (inv_mem)

/-- `neg_mem_class S G` states `S` is a type of subsets `s ⊆ G` closed under negation. -/
class NegMemClass (S G : Type _) [Neg G] [SetLike S G] where
  neg_mem : ∀ {s : S} {x}, x ∈ s → -x ∈ s

export NegMemClass (neg_mem)

/-- `subgroup_class S G` states `S` is a type of subsets `s ⊆ G` that are subgroups of `G`. -/
class SubgroupClass (S G : Type _) [DivInvMonoidₓ G] [SetLike S G] extends SubmonoidClass S G where
  inv_mem : ∀ {s : S} {x}, x ∈ s → x⁻¹ ∈ s

/-- `add_subgroup_class S G` states `S` is a type of subsets `s ⊆ G` that are
additive subgroups of `G`. -/
class AddSubgroupClass (S G : Type _) [SubNegMonoidₓ G] [SetLike S G] extends AddSubmonoidClass S G where
  neg_mem : ∀ {s : S} {x}, x ∈ s → -x ∈ s

attribute [to_additive] InvMemClass SubgroupClass

variable (M S : Type _) [DivInvMonoidₓ M] [SetLike S M] [hSM : SubgroupClass S M]

include hSM

-- See note [lower instance priority]
@[to_additive]
instance (priority := 100) SubgroupClass.toInvMemClass : InvMemClass S M :=
  { hSM with }

variable {S M} {H K : S}

/-- A subgroup is closed under division. -/
@[to_additive "An additive subgroup is closed under subtraction."]
theorem div_mem {x y : M} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H := by
  rw [div_eq_mul_inv] <;> exact mul_mem hx (inv_mem hy)

@[to_additive]
theorem zpow_mem {x : M} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K
  | (n : ℕ) => by
    rw [zpow_coe_nat]
    exact pow_mem hx n
  | -[1+ n] => by
    rw [zpow_neg_succ_of_nat]
    exact inv_mem (pow_mem hx n.succ)

omit hSM

variable [SetLike S G] [hSG : SubgroupClass S G]

include hSG

@[simp, to_additive]
theorem inv_mem_iff {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=
  ⟨fun h => inv_invₓ x ▸ inv_mem h, inv_mem⟩

@[to_additive]
theorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H := by
  rw [← inv_mem_iff, div_eq_mul_inv, div_eq_mul_inv, mul_inv_rev, inv_invₓ]

@[simp, to_additive]
theorem inv_coe_set : (H : Set G)⁻¹ = H := by
  ext
  simp

@[simp, to_additive]
theorem exists_inv_mem_iff_exists_mem {P : G → Prop} : (∃ x : G, x ∈ H ∧ P x⁻¹) ↔ ∃ x ∈ H, P x := by
  constructor <;>
    · rintro ⟨x, x_in, hx⟩
      exact
        ⟨x⁻¹, inv_mem x_in, by
          simp [hx]⟩
      

@[to_additive]
theorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=
  ⟨fun hba => by
    simpa using mul_mem hba (inv_mem h), fun hb => mul_mem hb h⟩

@[to_additive]
theorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=
  ⟨fun hab => by
    simpa using mul_mem (inv_mem h) hab, mul_mem h⟩

namespace SubgroupClass

omit hSG

include hSM

/-- A subgroup of a group inherits an inverse. -/
@[to_additive "An additive subgroup of a `add_group` inherits an inverse."]
instance hasInv : Inv H :=
  ⟨fun a => ⟨a⁻¹, inv_mem a.2⟩⟩

/-- A subgroup of a group inherits a division -/
@[to_additive "An additive subgroup of an `add_group` inherits a subtraction."]
instance hasDiv : Div H :=
  ⟨fun a b => ⟨a / b, div_mem a.2 b.2⟩⟩

omit hSM

/-- An additive subgroup of an `add_group` inherits an integer scaling. -/
instance _root_.add_subgroup_class.has_zsmul {M S} [SubNegMonoidₓ M] [SetLike S M] [AddSubgroupClass S M] {H : S} :
    HasSmul ℤ H :=
  ⟨fun n a => ⟨n • a, zsmul_mem a.2 n⟩⟩

include hSM

/-- A subgroup of a group inherits an integer power. -/
@[to_additive]
instance hasZpow : Pow H ℤ :=
  ⟨fun a n => ⟨a ^ n, zpow_mem a.2 n⟩⟩

@[simp, norm_cast, to_additive]
theorem coe_inv (x : H) : ↑(x⁻¹ : H) = (x⁻¹ : M) :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_div (x y : H) : (↑(x / y) : M) = ↑x / ↑y :=
  rfl

omit hSM

variable (H)

include hSG

-- Prefer subclasses of `group` over subclasses of `subgroup_class`.
/-- A subgroup of a group inherits a group structure. -/
@[to_additive "An additive subgroup of an `add_group` inherits an `add_group` structure."]
instance (priority := 75) toGroup : Groupₓ H :=
  Subtype.coe_injective.Group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl

omit hSG

-- Prefer subclasses of `comm_group` over subclasses of `subgroup_class`.
/-- A subgroup of a `comm_group` is a `comm_group`. -/
@[to_additive "An additive subgroup of an `add_comm_group` is an `add_comm_group`."]
instance (priority := 75) toCommGroup {G : Type _} [CommGroupₓ G] [SetLike S G] [SubgroupClass S G] : CommGroupₓ H :=
  Subtype.coe_injective.CommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl

-- Prefer subclasses of `group` over subclasses of `subgroup_class`.
/-- A subgroup of an `ordered_comm_group` is an `ordered_comm_group`. -/
@[to_additive "An additive subgroup of an `add_ordered_comm_group` is an `add_ordered_comm_group`."]
instance (priority := 75) toOrderedCommGroup {G : Type _} [OrderedCommGroup G] [SetLike S G] [SubgroupClass S G] :
    OrderedCommGroup H :=
  Subtype.coe_injective.OrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)
    fun _ _ => rfl

-- Prefer subclasses of `group` over subclasses of `subgroup_class`.
/-- A subgroup of a `linear_ordered_comm_group` is a `linear_ordered_comm_group`. -/
@[to_additive "An additive subgroup of a `linear_ordered_add_comm_group` is a\n  `linear_ordered_add_comm_group`."]
instance (priority := 75) toLinearOrderedCommGroup {G : Type _} [LinearOrderedCommGroup G] [SetLike S G]
    [SubgroupClass S G] : LinearOrderedCommGroup H :=
  Subtype.coe_injective.LinearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl

include hSG

/-- The natural group hom from a subgroup of group `G` to `G`. -/
@[to_additive "The natural group hom from an additive subgroup of `add_group` `G` to `G`."]
def subtype : H →* G :=
  ⟨coe, rfl, fun _ _ => rfl⟩

@[simp, to_additive]
theorem coe_subtype : (subtype H : H → G) = coe :=
  rfl

variable {H}

@[simp, norm_cast, to_additive coe_smul]
theorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = x ^ n :=
  (subtype H : H →* G).map_pow _ _

@[simp, norm_cast, to_additive]
theorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = x ^ n :=
  (subtype H : H →* G).map_zpow _ _

/-- The inclusion homomorphism from a subgroup `H` contained in `K` to `K`. -/
@[to_additive "The inclusion homomorphism from a additive subgroup `H` contained in `K` to `K`."]
def inclusion {H K : S} (h : H ≤ K) : H →* K :=
  MonoidHom.mk' (fun x => ⟨x, h x.Prop⟩) fun ⟨a, ha⟩ ⟨b, hb⟩ => rfl

@[simp, to_additive]
theorem inclusion_self (x : H) : inclusion le_rflₓ x = x := by
  cases x
  rfl

@[simp, to_additive]
theorem inclusion_mk {h : H ≤ K} (x : G) (hx : x ∈ H) : inclusion h ⟨x, hx⟩ = ⟨x, h hx⟩ :=
  rfl

@[to_additive]
theorem inclusion_right (h : H ≤ K) (x : K) (hx : (x : G) ∈ H) : inclusion h ⟨x, hx⟩ = x := by
  cases x
  rfl

@[simp]
theorem inclusion_inclusion {L : S} (hHK : H ≤ K) (hKL : K ≤ L) (x : H) :
    inclusion hKL (inclusion hHK x) = inclusion (hHK.trans hKL) x := by
  cases x
  rfl

@[simp, to_additive]
theorem coe_inclusion {H K : S} {h : H ≤ K} (a : H) : (inclusion h a : G) = a := by
  cases a
  simp only [inclusion, SetLike.coe_mk, MonoidHom.mk'_apply]

@[simp, to_additive]
theorem subtype_comp_inclusion {H K : S} (hH : H ≤ K) : (subtype K).comp (inclusion hH) = subtype H := by
  ext
  simp only [MonoidHom.comp_apply, coeSubtype, coe_inclusion]

end SubgroupClass

end SubgroupClass

/-- A subgroup of a group `G` is a subset containing 1, closed under multiplication
and closed under multiplicative inverse. -/
structure Subgroup (G : Type _) [Groupₓ G] extends Submonoid G where
  inv_mem' {x} : x ∈ carrier → x⁻¹ ∈ carrier

/-- An additive subgroup of an additive group `G` is a subset containing 0, closed
under addition and additive inverse. -/
structure AddSubgroup (G : Type _) [AddGroupₓ G] extends AddSubmonoid G where
  neg_mem' {x} : x ∈ carrier → -x ∈ carrier

attribute [to_additive] Subgroup

attribute [to_additive AddSubgroup.toAddSubmonoid] Subgroup.toSubmonoid

-- ./././Mathport/Syntax/Translate/Tactic/Basic.lean:51:50: missing argument
-- ./././Mathport/Syntax/Translate/Command.lean:665:43: in add_decl_doc #[[ident subgroup.to_submonoid]]: ./././Mathport/Syntax/Translate/Tactic/Basic.lean:54:35: expecting parse arg
-- ./././Mathport/Syntax/Translate/Tactic/Basic.lean:51:50: missing argument
-- ./././Mathport/Syntax/Translate/Command.lean:665:43: in add_decl_doc #[[ident add_subgroup.to_add_submonoid]]: ./././Mathport/Syntax/Translate/Tactic/Basic.lean:54:35: expecting parse arg
namespace Subgroup

@[to_additive]
instance : SetLike (Subgroup G) G where
  coe := Subgroup.Carrier
  coe_injective' := fun p q h => by
    cases p <;> cases q <;> congr

@[to_additive]
instance : SubgroupClass (Subgroup G) G where
  mul_mem := Subgroup.mul_mem'
  one_mem := Subgroup.one_mem'
  inv_mem := Subgroup.inv_mem'

@[simp, to_additive]
theorem mem_carrier {s : Subgroup G} {x : G} : x ∈ s.Carrier ↔ x ∈ s :=
  Iff.rfl

@[simp, to_additive]
theorem mem_mk {s : Set G} {x : G} (h_one) (h_mul) (h_inv) : x ∈ mk s h_one h_mul h_inv ↔ x ∈ s :=
  Iff.rfl

@[simp, to_additive]
theorem coe_set_mk {s : Set G} (h_one) (h_mul) (h_inv) : (mk s h_one h_mul h_inv : Set G) = s :=
  rfl

@[simp, to_additive]
theorem mk_le_mk {s t : Set G} (h_one) (h_mul) (h_inv) (h_one') (h_mul') (h_inv') :
    mk s h_one h_mul h_inv ≤ mk t h_one' h_mul' h_inv' ↔ s ⊆ t :=
  Iff.rfl

/-- See Note [custom simps projection] -/
@[to_additive "See Note [custom simps projection]"]
def Simps.Coe (S : Subgroup G) : Set G :=
  S

initialize_simps_projections Subgroup (Carrier → coe)

initialize_simps_projections AddSubgroup (Carrier → coe)

@[simp, to_additive]
theorem coe_to_submonoid (K : Subgroup G) : (K.toSubmonoid : Set G) = K :=
  rfl

@[simp, to_additive]
theorem mem_to_submonoid (K : Subgroup G) (x : G) : x ∈ K.toSubmonoid ↔ x ∈ K :=
  Iff.rfl

@[to_additive]
instance (K : Subgroup G) [d : DecidablePred (· ∈ K)] [Fintype G] : Fintype K :=
  show Fintype { g : G // g ∈ K } from inferInstance

@[to_additive]
theorem to_submonoid_injective : Function.Injective (toSubmonoid : Subgroup G → Submonoid G) := fun p q h =>
  SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)

@[simp, to_additive]
theorem to_submonoid_eq {p q : Subgroup G} : p.toSubmonoid = q.toSubmonoid ↔ p = q :=
  to_submonoid_injective.eq_iff

@[to_additive, mono]
theorem to_submonoid_strict_mono : StrictMono (toSubmonoid : Subgroup G → Submonoid G) := fun _ _ => id

attribute [mono] AddSubgroup.to_add_submonoid_strict_mono

@[to_additive, mono]
theorem to_submonoid_mono : Monotone (toSubmonoid : Subgroup G → Submonoid G) :=
  to_submonoid_strict_mono.Monotone

attribute [mono] AddSubgroup.to_add_submonoid_mono

@[simp, to_additive]
theorem to_submonoid_le {p q : Subgroup G} : p.toSubmonoid ≤ q.toSubmonoid ↔ p ≤ q :=
  Iff.rfl

end Subgroup

/-!
### Conversion to/from `additive`/`multiplicative`
-/


section mul_addₓ

/-- Supgroups of a group `G` are isomorphic to additive subgroups of `additive G`. -/
@[simps]
def Subgroup.toAddSubgroup : Subgroup G ≃o AddSubgroup (Additive G) where
  toFun := fun S => { S.toSubmonoid.toAddSubmonoid with neg_mem' := S.inv_mem' }
  invFun := fun S => { S.toAddSubmonoid.toSubmonoid' with inv_mem' := S.neg_mem' }
  left_inv := fun x => by
    cases x <;> rfl
  right_inv := fun x => by
    cases x <;> rfl
  map_rel_iff' := fun a b => Iff.rfl

/-- Additive subgroup of an additive group `additive G` are isomorphic to subgroup of `G`. -/
abbrev AddSubgroup.toSubgroup' : AddSubgroup (Additive G) ≃o Subgroup G :=
  Subgroup.toAddSubgroup.symm

/-- Additive supgroups of an additive group `A` are isomorphic to subgroups of `multiplicative A`.
-/
@[simps]
def AddSubgroup.toSubgroup : AddSubgroup A ≃o Subgroup (Multiplicative A) where
  toFun := fun S => { S.toAddSubmonoid.toSubmonoid with inv_mem' := S.neg_mem' }
  invFun := fun S => { S.toSubmonoid.toAddSubmonoid' with neg_mem' := S.inv_mem' }
  left_inv := fun x => by
    cases x <;> rfl
  right_inv := fun x => by
    cases x <;> rfl
  map_rel_iff' := fun a b => Iff.rfl

/-- Subgroups of an additive group `multiplicative A` are isomorphic to additive subgroups of `A`.
-/
abbrev Subgroup.toAddSubgroup' : Subgroup (Multiplicative A) ≃o AddSubgroup A :=
  AddSubgroup.toSubgroup.symm

end mul_addₓ

namespace Subgroup

variable (H K : Subgroup G)

/-- Copy of a subgroup with a new `carrier` equal to the old one. Useful to fix definitional
equalities.-/
@[to_additive
      "Copy of an additive subgroup with a new `carrier` equal to the old one.\nUseful to fix definitional equalities"]
protected def copy (K : Subgroup G) (s : Set G) (hs : s = K) : Subgroup G where
  Carrier := s
  one_mem' := hs.symm ▸ K.one_mem'
  mul_mem' := hs.symm ▸ K.mul_mem'
  inv_mem' := hs.symm ▸ K.inv_mem'

@[simp, to_additive]
theorem coe_copy (K : Subgroup G) (s : Set G) (hs : s = ↑K) : (K.copy s hs : Set G) = s :=
  rfl

@[to_additive]
theorem copy_eq (K : Subgroup G) (s : Set G) (hs : s = ↑K) : K.copy s hs = K :=
  SetLike.coe_injective hs

/-- Two subgroups are equal if they have the same elements. -/
@[ext, to_additive "Two `add_subgroup`s are equal if they have the same elements."]
theorem ext {H K : Subgroup G} (h : ∀ x, x ∈ H ↔ x ∈ K) : H = K :=
  SetLike.ext h

/-- A subgroup contains the group's 1. -/
@[to_additive "An `add_subgroup` contains the group's 0."]
protected theorem one_mem : (1 : G) ∈ H :=
  one_mem _

/-- A subgroup is closed under multiplication. -/
@[to_additive "An `add_subgroup` is closed under addition."]
protected theorem mul_mem {x y : G} : x ∈ H → y ∈ H → x * y ∈ H :=
  mul_mem

/-- A subgroup is closed under inverse. -/
@[to_additive "An `add_subgroup` is closed under inverse."]
protected theorem inv_mem {x : G} : x ∈ H → x⁻¹ ∈ H :=
  inv_mem

/-- A subgroup is closed under division. -/
@[to_additive "An `add_subgroup` is closed under subtraction."]
protected theorem div_mem {x y : G} (hx : x ∈ H) (hy : y ∈ H) : x / y ∈ H :=
  div_mem hx hy

@[to_additive]
protected theorem inv_mem_iff {x : G} : x⁻¹ ∈ H ↔ x ∈ H :=
  inv_mem_iff

@[to_additive]
protected theorem div_mem_comm_iff {a b : G} : a / b ∈ H ↔ b / a ∈ H :=
  div_mem_comm_iff

@[to_additive]
protected theorem inv_coe_set : (H : Set G)⁻¹ = H := by
  ext
  simp

@[to_additive]
protected theorem exists_inv_mem_iff_exists_mem (K : Subgroup G) {P : G → Prop} :
    (∃ x : G, x ∈ K ∧ P x⁻¹) ↔ ∃ x ∈ K, P x :=
  exists_inv_mem_iff_exists_mem

@[to_additive]
protected theorem mul_mem_cancel_right {x y : G} (h : x ∈ H) : y * x ∈ H ↔ y ∈ H :=
  mul_mem_cancel_right h

@[to_additive]
protected theorem mul_mem_cancel_left {x y : G} (h : x ∈ H) : x * y ∈ H ↔ y ∈ H :=
  mul_mem_cancel_left h

/-- Product of a list of elements in a subgroup is in the subgroup. -/
@[to_additive "Sum of a list of elements in an `add_subgroup` is in the `add_subgroup`."]
protected theorem list_prod_mem {l : List G} : (∀ x ∈ l, x ∈ K) → l.Prod ∈ K :=
  list_prod_mem

/-- Product of a multiset of elements in a subgroup of a `comm_group` is in the subgroup. -/
@[to_additive "Sum of a multiset of elements in an `add_subgroup` of an `add_comm_group`\nis in the `add_subgroup`."]
protected theorem multiset_prod_mem {G} [CommGroupₓ G] (K : Subgroup G) (g : Multiset G) :
    (∀ a ∈ g, a ∈ K) → g.Prod ∈ K :=
  multiset_prod_mem g

@[to_additive]
theorem multiset_noncomm_prod_mem (K : Subgroup G) (g : Multiset G) (comm : ∀ x ∈ g, ∀ y ∈ g, Commute x y) :
    (∀ a ∈ g, a ∈ K) → g.noncommProd comm ∈ K :=
  K.toSubmonoid.multiset_noncomm_prod_mem g comm

/-- Product of elements of a subgroup of a `comm_group` indexed by a `finset` is in the
    subgroup. -/
@[to_additive
      "Sum of elements in an `add_subgroup` of an `add_comm_group` indexed by a `finset`\nis in the `add_subgroup`."]
protected theorem prod_mem {G : Type _} [CommGroupₓ G] (K : Subgroup G) {ι : Type _} {t : Finset ι} {f : ι → G}
    (h : ∀ c ∈ t, f c ∈ K) : (∏ c in t, f c) ∈ K :=
  prod_mem h

@[to_additive]
theorem noncomm_prod_mem (K : Subgroup G) {ι : Type _} {t : Finset ι} {f : ι → G}
    (comm : ∀ x ∈ t, ∀ y ∈ t, Commute (f x) (f y)) : (∀ c ∈ t, f c ∈ K) → t.noncommProd f comm ∈ K :=
  K.toSubmonoid.noncomm_prod_mem t f comm

@[to_additive AddSubgroup.nsmul_mem]
protected theorem pow_mem {x : G} (hx : x ∈ K) : ∀ n : ℕ, x ^ n ∈ K :=
  pow_mem hx

@[to_additive]
protected theorem zpow_mem {x : G} (hx : x ∈ K) : ∀ n : ℤ, x ^ n ∈ K :=
  zpow_mem hx

-- ./././Mathport/Syntax/Translate/Basic.lean:556:2: warning: expanding binder collection (x y «expr ∈ » s)
/-- Construct a subgroup from a nonempty set that is closed under division. -/
@[to_additive "Construct a subgroup from a nonempty set that is closed under subtraction"]
def ofDiv (s : Set G) (hsn : s.Nonempty) (hs : ∀ (x y) (_ : x ∈ s) (_ : y ∈ s), x * y⁻¹ ∈ s) : Subgroup G :=
  have one_mem : (1 : G) ∈ s := by
    let ⟨x, hx⟩ := hsn
    simpa using hs x hx x hx
  have inv_mem : ∀ x, x ∈ s → x⁻¹ ∈ s := fun x hx => by
    simpa using hs 1 one_mem x hx
  { Carrier := s, one_mem' := one_mem, inv_mem' := inv_mem,
    mul_mem' := fun x y hx hy => by
      simpa using hs x hx y⁻¹ (inv_mem y hy) }

/-- A subgroup of a group inherits a multiplication. -/
@[to_additive "An `add_subgroup` of an `add_group` inherits an addition."]
instance hasMul : Mul H :=
  H.toSubmonoid.HasMul

/-- A subgroup of a group inherits a 1. -/
@[to_additive "An `add_subgroup` of an `add_group` inherits a zero."]
instance hasOne : One H :=
  H.toSubmonoid.HasOne

/-- A subgroup of a group inherits an inverse. -/
@[to_additive "A `add_subgroup` of a `add_group` inherits an inverse."]
instance hasInv : Inv H :=
  ⟨fun a => ⟨a⁻¹, H.inv_mem a.2⟩⟩

/-- A subgroup of a group inherits a division -/
@[to_additive "An `add_subgroup` of an `add_group` inherits a subtraction."]
instance hasDiv : Div H :=
  ⟨fun a b => ⟨a / b, H.div_mem a.2 b.2⟩⟩

/-- An `add_subgroup` of an `add_group` inherits a natural scaling. -/
instance _root_.add_subgroup.has_nsmul {G} [AddGroupₓ G] {H : AddSubgroup G} : HasSmul ℕ H :=
  ⟨fun n a => ⟨n • a, H.nsmul_mem a.2 n⟩⟩

/-- A subgroup of a group inherits a natural power -/
@[to_additive]
instance hasNpow : Pow H ℕ :=
  ⟨fun a n => ⟨a ^ n, H.pow_mem a.2 n⟩⟩

/-- An `add_subgroup` of an `add_group` inherits an integer scaling. -/
instance _root_.add_subgroup.has_zsmul {G} [AddGroupₓ G] {H : AddSubgroup G} : HasSmul ℤ H :=
  ⟨fun n a => ⟨n • a, H.zsmul_mem a.2 n⟩⟩

/-- A subgroup of a group inherits an integer power -/
@[to_additive]
instance hasZpow : Pow H ℤ :=
  ⟨fun a n => ⟨a ^ n, H.zpow_mem a.2 n⟩⟩

@[simp, norm_cast, to_additive]
theorem coe_mul (x y : H) : (↑(x * y) : G) = ↑x * ↑y :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_one : ((1 : H) : G) = 1 :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_inv (x : H) : ↑(x⁻¹ : H) = (x⁻¹ : G) :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_div (x y : H) : (↑(x / y) : G) = ↑x / ↑y :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_mk (x : G) (hx : x ∈ H) : ((⟨x, hx⟩ : H) : G) = x :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_pow (x : H) (n : ℕ) : ((x ^ n : H) : G) = x ^ n :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_zpow (x : H) (n : ℤ) : ((x ^ n : H) : G) = x ^ n :=
  rfl

/-- A subgroup of a group inherits a group structure. -/
@[to_additive "An `add_subgroup` of an `add_group` inherits an `add_group` structure."]
instance toGroup {G : Type _} [Groupₓ G] (H : Subgroup G) : Groupₓ H :=
  Subtype.coe_injective.Group _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl

/-- A subgroup of a `comm_group` is a `comm_group`. -/
@[to_additive "An `add_subgroup` of an `add_comm_group` is an `add_comm_group`."]
instance toCommGroup {G : Type _} [CommGroupₓ G] (H : Subgroup G) : CommGroupₓ H :=
  Subtype.coe_injective.CommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl

/-- A subgroup of an `ordered_comm_group` is an `ordered_comm_group`. -/
@[to_additive "An `add_subgroup` of an `add_ordered_comm_group` is an `add_ordered_comm_group`."]
instance toOrderedCommGroup {G : Type _} [OrderedCommGroup G] (H : Subgroup G) : OrderedCommGroup H :=
  Subtype.coe_injective.OrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)
    fun _ _ => rfl

/-- A subgroup of a `linear_ordered_comm_group` is a `linear_ordered_comm_group`. -/
@[to_additive "An `add_subgroup` of a `linear_ordered_add_comm_group` is a\n  `linear_ordered_add_comm_group`."]
instance toLinearOrderedCommGroup {G : Type _} [LinearOrderedCommGroup G] (H : Subgroup G) : LinearOrderedCommGroup H :=
  Subtype.coe_injective.LinearOrderedCommGroup _ rfl (fun _ _ => rfl) (fun _ => rfl) (fun _ _ => rfl) (fun _ _ => rfl)
    (fun _ _ => rfl) (fun _ _ => rfl) fun _ _ => rfl

/-- The natural group hom from a subgroup of group `G` to `G`. -/
@[to_additive "The natural group hom from an `add_subgroup` of `add_group` `G` to `G`."]
def subtype : H →* G :=
  ⟨coe, rfl, fun _ _ => rfl⟩

@[simp, to_additive]
theorem coe_subtype : ⇑H.Subtype = coe :=
  rfl

@[simp, norm_cast, to_additive]
theorem coe_list_prod (l : List H) : (l.Prod : G) = (l.map coe).Prod :=
  SubmonoidClass.coe_list_prod l

@[simp, norm_cast, to_additive]
theorem coe_multiset_prod {G} [CommGroupₓ G] (H : Subgroup G) (m : Multiset H) : (m.Prod : G) = (m.map coe).Prod :=
  SubmonoidClass.coe_multiset_prod m

@[simp, norm_cast, to_additive]
theorem coe_finset_prod {ι G} [CommGroupₓ G] (H : Subgroup G) (f : ι → H) (s : Finset ι) :
    ↑(∏ i in s, f i) = (∏ i in s, f i : G) :=
  SubmonoidClass.coe_finset_prod f s

/-- The inclusion homomorphism from a subgroup `H` contained in `K` to `K`. -/
@[to_additive "The inclusion homomorphism from a additive subgroup `H` contained in `K` to `K`."]
def inclusion {H K : Subgroup G} (h : H ≤ K) : H →* K :=
  MonoidHom.mk' (fun x => ⟨x, h x.Prop⟩) fun ⟨a, ha⟩ ⟨b, hb⟩ => rfl

@[simp, to_additive]
theorem coe_inclusion {H K : Subgroup G} {h : H ≤ K} (a : H) : (inclusion h a : G) = a := by
  cases a
  simp only [inclusion, coe_mk, MonoidHom.mk'_apply]

@[to_additive]
theorem inclusion_injective {H K : Subgroup G} (h : H ≤ K) : Function.Injective <| inclusion h :=
  Set.inclusion_injective h

@[simp, to_additive]
theorem subtype_comp_inclusion {H K : Subgroup G} (hH : H ≤ K) : K.Subtype.comp (inclusion hH) = H.Subtype := by
  ext
  simp

/-- The subgroup `G` of the group `G`. -/
@[to_additive "The `add_subgroup G` of the `add_group G`."]
instance : HasTop (Subgroup G) :=
  ⟨{ (⊤ : Submonoid G) with inv_mem' := fun _ _ => Set.mem_univ _ }⟩

/-- The top subgroup is isomorphic to the group.

This is the group version of `submonoid.top_equiv`. -/
@[to_additive
      "The top additive subgroup is isomorphic to the additive group.\n\nThis is the additive group version of `add_submonoid.top_equiv`.",
  simps]
def topEquiv : (⊤ : Subgroup G) ≃* G :=
  Submonoid.topEquiv

/-- The trivial subgroup `{1}` of an group `G`. -/
@[to_additive "The trivial `add_subgroup` `{0}` of an `add_group` `G`."]
instance : HasBot (Subgroup G) :=
  ⟨{ (⊥ : Submonoid G) with
      inv_mem' := fun _ => by
        simp [*] }⟩

@[to_additive]
instance : Inhabited (Subgroup G) :=
  ⟨⊥⟩

@[simp, to_additive]
theorem mem_bot {x : G} : x ∈ (⊥ : Subgroup G) ↔ x = 1 :=
  Iff.rfl

@[simp, to_additive]
theorem mem_top (x : G) : x ∈ (⊤ : Subgroup G) :=
  Set.mem_univ x

@[simp, to_additive]
theorem coe_top : ((⊤ : Subgroup G) : Set G) = Set.Univ :=
  rfl

@[simp, to_additive]
theorem coe_bot : ((⊥ : Subgroup G) : Set G) = {1} :=
  rfl

@[to_additive]
instance : Unique (⊥ : Subgroup G) :=
  ⟨⟨1⟩, fun g => Subtype.ext g.2⟩

@[to_additive]
theorem eq_bot_iff_forall : H = ⊥ ↔ ∀ x ∈ H, x = (1 : G) := by
  rw [SetLike.ext'_iff]
  simp only [coe_bot, Set.eq_singleton_iff_unique_mem, SetLike.mem_coe, H.one_mem, true_andₓ]

@[to_additive]
theorem eq_bot_of_subsingleton [Subsingleton H] : H = ⊥ := by
  rw [Subgroup.eq_bot_iff_forall]
  intro y hy
  rw [← Subgroup.coe_mk H y hy, Subsingleton.elimₓ (⟨y, hy⟩ : H) 1, Subgroup.coe_one]

@[to_additive]
theorem coe_eq_univ {H : Subgroup G} : (H : Set G) = Set.Univ ↔ H = ⊤ :=
  (SetLike.ext'_iff.trans
      (by
        rfl)).symm

@[to_additive]
theorem coe_eq_singleton {H : Subgroup G} : (∃ g : G, (H : Set G) = {g}) ↔ H = ⊥ :=
  ⟨fun ⟨g, hg⟩ => by
    haveI : Subsingleton (H : Set G) := by
      rw [hg]
      infer_instance
    exact H.eq_bot_of_subsingleton, fun h => ⟨1, SetLike.ext'_iff.mp h⟩⟩

@[to_additive]
instance fintypeBot : Fintype (⊥ : Subgroup G) :=
  ⟨{1}, by
    rintro ⟨x, ⟨hx⟩⟩
    exact Finset.mem_singleton_self _⟩

/- curly brackets `{}` are used here instead of instance brackets `[]` because
  the instance in a goal is often not the same as the one inferred by type class inference.  -/
@[simp, to_additive]
theorem card_bot {_ : Fintype ↥(⊥ : Subgroup G)} : Fintype.card (⊥ : Subgroup G) = 1 :=
  Fintype.card_eq_one_iff.2 ⟨⟨(1 : G), Set.mem_singleton 1⟩, fun ⟨y, hy⟩ => Subtype.eq <| Subgroup.mem_bot.1 hy⟩

@[to_additive]
theorem eq_top_of_card_eq [Fintype H] [Fintype G] (h : Fintype.card H = Fintype.card G) : H = ⊤ := by
  haveI : Fintype (H : Set G) := ‹Fintype H›
  rw [SetLike.ext'_iff, coe_top, ← Finset.coe_univ, ← (H : Set G).coe_to_finset, Finset.coe_inj, ←
    Finset.card_eq_iff_eq_univ, ← h, Set.to_finset_card]
  congr

@[to_additive]
theorem eq_top_of_le_card [Fintype H] [Fintype G] (h : Fintype.card G ≤ Fintype.card H) : H = ⊤ :=
  eq_top_of_card_eq H (le_antisymmₓ (Fintype.card_le_of_injective coe Subtype.coe_injective) h)

@[to_additive]
theorem eq_bot_of_card_le [Fintype H] (h : Fintype.card H ≤ 1) : H = ⊥ :=
  let _ := Fintype.card_le_one_iff_subsingleton.mp h
  eq_bot_of_subsingleton H

@[to_additive]
theorem eq_bot_of_card_eq [Fintype H] (h : Fintype.card H = 1) : H = ⊥ :=
  H.eq_bot_of_card_le (le_of_eqₓ h)

@[to_additive]
theorem nontrivial_iff_exists_ne_one (H : Subgroup G) : Nontrivial H ↔ ∃ x ∈ H, x ≠ (1 : G) :=
  Subtype.nontrivial_iff_exists_ne (fun x => x ∈ H) (1 : H)

/-- A subgroup is either the trivial subgroup or nontrivial. -/
@[to_additive "A subgroup is either the trivial subgroup or nontrivial."]
theorem bot_or_nontrivial (H : Subgroup G) : H = ⊥ ∨ Nontrivial H := by
  classical
  by_cases' h : ∀ x ∈ H, x = (1 : G)
  · left
    exact H.eq_bot_iff_forall.mpr h
    
  · right
    simp only [not_forall] at h
    simpa only [nontrivial_iff_exists_ne_one]
    

/-- A subgroup is either the trivial subgroup or contains a non-identity element. -/
@[to_additive "A subgroup is either the trivial subgroup or contains a nonzero element."]
theorem bot_or_exists_ne_one (H : Subgroup G) : H = ⊥ ∨ ∃ x ∈ H, x ≠ (1 : G) := by
  convert H.bot_or_nontrivial
  rw [nontrivial_iff_exists_ne_one]

@[to_additive]
theorem card_le_one_iff_eq_bot [Fintype H] : Fintype.card H ≤ 1 ↔ H = ⊥ :=
  ⟨fun h =>
    (eq_bot_iff_forall _).2 fun x hx => by
      simpa [Subtype.ext_iff] using Fintype.card_le_one_iff.1 h ⟨x, hx⟩ 1,
    fun h => by
    simp [h]⟩

@[to_additive]
theorem one_lt_card_iff_ne_bot [Fintype H] : 1 < Fintype.card H ↔ H ≠ ⊥ :=
  lt_iff_not_le.trans H.card_le_one_iff_eq_bot.Not

/-- The inf of two subgroups is their intersection. -/
@[to_additive "The inf of two `add_subgroups`s is their intersection."]
instance : HasInf (Subgroup G) :=
  ⟨fun H₁ H₂ => { H₁.toSubmonoid⊓H₂.toSubmonoid with inv_mem' := fun _ ⟨hx, hx'⟩ => ⟨H₁.inv_mem hx, H₂.inv_mem hx'⟩ }⟩

@[simp, to_additive]
theorem coe_inf (p p' : Subgroup G) : ((p⊓p' : Subgroup G) : Set G) = p ∩ p' :=
  rfl

@[simp, to_additive]
theorem mem_inf {p p' : Subgroup G} {x : G} : x ∈ p⊓p' ↔ x ∈ p ∧ x ∈ p' :=
  Iff.rfl

@[to_additive]
instance : HasInfₓ (Subgroup G) :=
  ⟨fun s =>
    { (⨅ S ∈ s, Subgroup.toSubmonoid S).copy (⋂ S ∈ s, ↑S)
        (by
          simp ) with
      inv_mem' := fun x hx =>
        Set.mem_bInter fun i h =>
          i.inv_mem
            (by
              apply Set.mem_Inter₂.1 hx i h) }⟩

@[simp, norm_cast, to_additive]
theorem coe_Inf (H : Set (Subgroup G)) : ((inf H : Subgroup G) : Set G) = ⋂ s ∈ H, ↑s :=
  rfl

@[simp, to_additive]
theorem mem_Inf {S : Set (Subgroup G)} {x : G} : x ∈ inf S ↔ ∀ p ∈ S, x ∈ p :=
  Set.mem_Inter₂

@[to_additive]
theorem mem_infi {ι : Sort _} {S : ι → Subgroup G} {x : G} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by
  simp only [infi, mem_Inf, Set.forall_range_iff]

@[simp, norm_cast, to_additive]
theorem coe_infi {ι : Sort _} {S : ι → Subgroup G} : (↑(⨅ i, S i) : Set G) = ⋂ i, S i := by
  simp only [infi, coe_Inf, Set.bInter_range]

/-- Subgroups of a group form a complete lattice. -/
@[to_additive "The `add_subgroup`s of an `add_group` form a complete lattice."]
instance : CompleteLattice (Subgroup G) :=
  { (completeLatticeOfInf (Subgroup G)) fun s =>
      IsGlb.of_image (fun H K => show (H : Set G) ≤ K ↔ H ≤ K from SetLike.coe_subset_coe) is_glb_binfi with
    bot := ⊥, bot_le := fun S x hx => (mem_bot.1 hx).symm ▸ S.one_mem, top := ⊤, le_top := fun S x hx => mem_top x,
    inf := (·⊓·), le_inf := fun a b c ha hb x hx => ⟨ha hx, hb hx⟩, inf_le_left := fun a b x => And.left,
    inf_le_right := fun a b x => And.right }

@[to_additive]
theorem mem_sup_left {S T : Subgroup G} : ∀ {x : G}, x ∈ S → x ∈ S⊔T :=
  show S ≤ S⊔T from le_sup_left

@[to_additive]
theorem mem_sup_right {S T : Subgroup G} : ∀ {x : G}, x ∈ T → x ∈ S⊔T :=
  show T ≤ S⊔T from le_sup_right

@[to_additive]
theorem mul_mem_sup {S T : Subgroup G} {x y : G} (hx : x ∈ S) (hy : y ∈ T) : x * y ∈ S⊔T :=
  (S⊔T).mul_mem (mem_sup_left hx) (mem_sup_right hy)

@[to_additive]
theorem mem_supr_of_mem {ι : Sort _} {S : ι → Subgroup G} (i : ι) : ∀ {x : G}, x ∈ S i → x ∈ supr S :=
  show S i ≤ supr S from le_supr _ _

@[to_additive]
theorem mem_Sup_of_mem {S : Set (Subgroup G)} {s : Subgroup G} (hs : s ∈ S) : ∀ {x : G}, x ∈ s → x ∈ sup S :=
  show s ≤ sup S from le_Sup hs

@[simp, to_additive]
theorem subsingleton_iff : Subsingleton (Subgroup G) ↔ Subsingleton G :=
  ⟨fun h =>
    ⟨fun x y =>
      have : ∀ i : G, i = 1 := fun i => mem_bot.mp <| Subsingleton.elimₓ (⊤ : Subgroup G) ⊥ ▸ mem_top i
      (this x).trans (this y).symm⟩,
    fun h =>
    ⟨fun x y =>
      Subgroup.ext fun i =>
        Subsingleton.elimₓ 1 i ▸ by
          simp [Subgroup.one_mem]⟩⟩

@[simp, to_additive]
theorem nontrivial_iff : Nontrivial (Subgroup G) ↔ Nontrivial G :=
  not_iff_not.mp ((not_nontrivial_iff_subsingleton.trans subsingleton_iff).trans not_nontrivial_iff_subsingleton.symm)

@[to_additive]
instance [Subsingleton G] : Unique (Subgroup G) :=
  ⟨⟨⊥⟩, fun a => @Subsingleton.elimₓ _ (subsingleton_iff.mpr ‹_›) a _⟩

@[to_additive]
instance [Nontrivial G] : Nontrivial (Subgroup G) :=
  nontrivial_iff.mpr ‹_›

@[to_additive]
theorem eq_top_iff' : H = ⊤ ↔ ∀ x : G, x ∈ H :=
  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩

/-- The `subgroup` generated by a set. -/
@[to_additive "The `add_subgroup` generated by a set"]
def closure (k : Set G) : Subgroup G :=
  inf { K | k ⊆ K }

variable {k : Set G}

@[to_additive]
theorem mem_closure {x : G} : x ∈ closure k ↔ ∀ K : Subgroup G, k ⊆ K → x ∈ K :=
  mem_Inf

/-- The subgroup generated by a set includes the set. -/
@[simp, to_additive "The `add_subgroup` generated by a set includes the set."]
theorem subset_closure : k ⊆ closure k := fun x hx => mem_closure.2 fun K hK => hK hx

@[to_additive]
theorem not_mem_of_not_mem_closure {P : G} (hP : P ∉ closure k) : P ∉ k := fun h => hP (subset_closure h)

open Set

/-- A subgroup `K` includes `closure k` if and only if it includes `k`. -/
@[simp, to_additive "An additive subgroup `K` includes `closure k` if and only if it includes `k`"]
theorem closure_le : closure k ≤ K ↔ k ⊆ K :=
  ⟨Subset.trans subset_closure, fun h => Inf_le h⟩

@[to_additive]
theorem closure_eq_of_le (h₁ : k ⊆ K) (h₂ : K ≤ closure k) : closure k = K :=
  le_antisymmₓ ((closure_le <| K).2 h₁) h₂

/-- An induction principle for closure membership. If `p` holds for `1` and all elements of `k`, and
is preserved under multiplication and inverse, then `p` holds for all elements of the closure
of `k`. -/
@[elabAsElim,
  to_additive
      "An induction principle for additive closure membership. If `p`\nholds for `0` and all elements of `k`, and is preserved under addition and inverses, then `p` holds\nfor all elements of the additive closure of `k`."]
theorem closure_induction {p : G → Prop} {x} (h : x ∈ closure k) (Hk : ∀ x ∈ k, p x) (H1 : p 1)
    (Hmul : ∀ x y, p x → p y → p (x * y)) (Hinv : ∀ x, p x → p x⁻¹) : p x :=
  (@closure_le _ _ ⟨p, Hmul, H1, Hinv⟩ _).2 Hk h

/-- A dependent version of `subgroup.closure_induction`.  -/
@[elabAsElim, to_additive "A dependent version of `add_subgroup.closure_induction`. "]
theorem closure_induction' {p : ∀ x, x ∈ closure k → Prop} (Hs : ∀ (x) (h : x ∈ k), p x (subset_closure h))
    (H1 : p 1 (one_mem _)) (Hmul : ∀ x hx y hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))
    (Hinv : ∀ x hx, p x hx → p x⁻¹ (inv_mem hx)) {x} (hx : x ∈ closure k) : p x hx := by
  refine' Exists.elim _ fun (hx : x ∈ closure k) (hc : p x hx) => hc
  exact
    closure_induction hx (fun x hx => ⟨_, Hs x hx⟩) ⟨_, H1⟩ (fun x y ⟨hx', hx⟩ ⟨hy', hy⟩ => ⟨_, Hmul _ _ _ _ hx hy⟩)
      fun x ⟨hx', hx⟩ => ⟨_, Hinv _ _ hx⟩

/-- An induction principle for closure membership for predicates with two arguments. -/
@[elabAsElim, to_additive "An induction principle for additive closure membership, for\npredicates with two arguments."]
theorem closure_induction₂ {p : G → G → Prop} {x} {y : G} (hx : x ∈ closure k) (hy : y ∈ closure k)
    (Hk : ∀ x ∈ k, ∀ y ∈ k, p x y) (H1_left : ∀ x, p 1 x) (H1_right : ∀ x, p x 1)
    (Hmul_left : ∀ x₁ x₂ y, p x₁ y → p x₂ y → p (x₁ * x₂) y) (Hmul_right : ∀ x y₁ y₂, p x y₁ → p x y₂ → p x (y₁ * y₂))
    (Hinv_left : ∀ x y, p x y → p x⁻¹ y) (Hinv_right : ∀ x y, p x y → p x y⁻¹) : p x y :=
  closure_induction hx (fun x xk => closure_induction hy (Hk x xk) (H1_right x) (Hmul_right x) (Hinv_right x))
    (H1_left y) (fun z z' => Hmul_left z z' y) fun z => Hinv_left z y

@[simp, to_additive]
theorem closure_closure_coe_preimage {k : Set G} : closure ((coe : closure k → G) ⁻¹' k) = ⊤ :=
  eq_top_iff.2 fun x =>
    (Subtype.recOn x) fun x hx _ => by
      refine' closure_induction' (fun g hg => _) _ (fun g₁ g₂ hg₁ hg₂ => _) (fun g hg => _) hx
      · exact subset_closure hg
        
      · exact one_mem _
        
      · exact mul_mem
        
      · exact inv_mem
        

/-- If all the elements of a set `s` commute, then `closure s` is a commutative group. -/
@[to_additive "If all the elements of a set `s` commute, then `closure s` is an additive\ncommutative group."]
def closureCommGroupOfComm {k : Set G} (hcomm : ∀ x ∈ k, ∀ y ∈ k, x * y = y * x) : CommGroupₓ (closure k) :=
  { (closure k).toGroup with
    mul_comm := fun x y => by
      ext
      simp only [Subgroup.coe_mul]
      refine'
        closure_induction₂ x.prop y.prop hcomm
          (fun x => by
            simp only [mul_oneₓ, one_mulₓ])
          (fun x => by
            simp only [mul_oneₓ, one_mulₓ])
          (fun x y z h₁ h₂ => by
            rw [mul_assoc, h₂, ← mul_assoc, h₁, mul_assoc])
          (fun x y z h₁ h₂ => by
            rw [← mul_assoc, h₁, mul_assoc, h₂, ← mul_assoc])
          (fun x y h => by
            rw [inv_mul_eq_iff_eq_mul, ← mul_assoc, h, mul_assoc, mul_inv_selfₓ, mul_oneₓ])
          fun x y h => by
          rw [mul_inv_eq_iff_eq_mul, mul_assoc, h, ← mul_assoc, inv_mul_selfₓ, one_mulₓ] }

variable (G)

/-- `closure` forms a Galois insertion with the coercion to set. -/
@[to_additive "`closure` forms a Galois insertion with the coercion to set."]
protected def gi : GaloisInsertion (@closure G _) coe where
  choice := fun s _ => closure s
  gc := fun s t => @closure_le _ _ t s
  le_l_u := fun s => subset_closure
  choice_eq := fun s h => rfl

variable {G}

/-- Subgroup closure of a set is monotone in its argument: if `h ⊆ k`,
then `closure h ≤ closure k`. -/
@[to_additive
      "Additive subgroup closure of a set is monotone in its argument: if `h ⊆ k`,\nthen `closure h ≤ closure k`"]
theorem closure_mono ⦃h k : Set G⦄ (h' : h ⊆ k) : closure h ≤ closure k :=
  (Subgroup.gi G).gc.monotone_l h'

/-- Closure of a subgroup `K` equals `K`. -/
@[simp, to_additive "Additive closure of an additive subgroup `K` equals `K`"]
theorem closure_eq : closure (K : Set G) = K :=
  (Subgroup.gi G).l_u_eq K

@[simp, to_additive]
theorem closure_empty : closure (∅ : Set G) = ⊥ :=
  (Subgroup.gi G).gc.l_bot

@[simp, to_additive]
theorem closure_univ : closure (Univ : Set G) = ⊤ :=
  @coe_top G _ ▸ closure_eq ⊤

@[to_additive]
theorem closure_union (s t : Set G) : closure (s ∪ t) = closure s⊔closure t :=
  (Subgroup.gi G).gc.l_sup

@[to_additive]
theorem closure_Union {ι} (s : ι → Set G) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=
  (Subgroup.gi G).gc.l_supr

@[to_additive]
theorem closure_eq_bot_iff (G : Type _) [Groupₓ G] (S : Set G) : closure S = ⊥ ↔ S ⊆ {1} := by
  rw [← le_bot_iff]
  exact closure_le _

@[to_additive]
theorem supr_eq_closure {ι : Sort _} (p : ι → Subgroup G) : (⨆ i, p i) = closure (⋃ i, (p i : Set G)) := by
  simp_rw [closure_Union, closure_eq]

/-- The subgroup generated by an element of a group equals the set of integer number powers of
    the element. -/
@[to_additive
      "The `add_subgroup` generated by an element of an `add_group` equals the set of\nnatural number multiples of the element."]
theorem mem_closure_singleton {x y : G} : y ∈ closure ({x} : Set G) ↔ ∃ n : ℤ, x ^ n = y := by
  refine' ⟨fun hy => closure_induction hy _ _ _ _, fun ⟨n, hn⟩ => hn ▸ zpow_mem (subset_closure <| mem_singleton x) n⟩
  · intro y hy
    rw [eq_of_mem_singleton hy]
    exact ⟨1, zpow_one x⟩
    
  · exact ⟨0, zpow_zero x⟩
    
  · rintro _ _ ⟨n, rfl⟩ ⟨m, rfl⟩
    exact ⟨n + m, zpow_add x n m⟩
    
  rintro _ ⟨n, rfl⟩
  exact ⟨-n, zpow_neg x n⟩

@[to_additive]
theorem closure_singleton_one : closure ({1} : Set G) = ⊥ := by
  simp [eq_bot_iff_forall, mem_closure_singleton]

@[simp, to_additive]
theorem inv_subset_closure (S : Set G) : S⁻¹ ⊆ closure S := by
  intro s hs
  rw [SetLike.mem_coe, ← Subgroup.inv_mem_iff]
  exact subset_closure (mem_inv.mp hs)

@[simp, to_additive]
theorem closure_inv (S : Set G) : closure S⁻¹ = closure S := by
  refine' le_antisymmₓ ((Subgroup.closure_le _).2 _) ((Subgroup.closure_le _).2 _)
  · exact inv_subset_closure S
    
  · simpa only [inv_invₓ] using inv_subset_closure S⁻¹
    

@[to_additive]
theorem closure_to_submonoid (S : Set G) : (closure S).toSubmonoid = Submonoid.closure (S ∪ S⁻¹) := by
  refine' le_antisymmₓ _ (Submonoid.closure_le.2 _)
  · intro x hx
    refine'
      closure_induction hx (fun x hx => Submonoid.closure_mono (subset_union_left S S⁻¹) (Submonoid.subset_closure hx))
        (Submonoid.one_mem _) (fun x y hx hy => Submonoid.mul_mem _ hx hy) fun x hx => _
    rwa [← Submonoid.mem_closure_inv, Set.union_inv, inv_invₓ, Set.union_comm]
    
  · simp only [true_andₓ, coe_to_submonoid, union_subset_iff, subset_closure, inv_subset_closure]
    

@[to_additive]
theorem closure_induction_left {p : G → Prop} {x : G} (h : x ∈ closure k) (H1 : p 1)
    (Hmul : ∀ x ∈ k, ∀ (y), p y → p (x * y)) (Hinv : ∀ x ∈ k, ∀ (y), p y → p (x⁻¹ * y)) : p x :=
  let key := le_of_eqₓ (closure_to_submonoid k)
  Submonoid.closure_induction_left (key h) H1 fun x hx =>
    hx.elim (Hmul x) fun hx y hy => (congr_arg _ (inv_invₓ x)).mp (Hinv x⁻¹ hx y hy)

@[to_additive]
theorem closure_induction_right {p : G → Prop} {x : G} (h : x ∈ closure k) (H1 : p 1)
    (Hmul : ∀ (x), ∀ y ∈ k, p x → p (x * y)) (Hinv : ∀ (x), ∀ y ∈ k, p x → p (x * y⁻¹)) : p x :=
  let key := le_of_eqₓ (closure_to_submonoid k)
  Submonoid.closure_induction_right (key h) H1 fun x y hy =>
    hy.elim (Hmul x y) fun hy hx => (congr_arg _ (inv_invₓ y)).mp (Hinv x y⁻¹ hy hx)

/-- An induction principle for closure membership. If `p` holds for `1` and all elements of
`k` and their inverse, and is preserved under multiplication, then `p` holds for all elements of
the closure of `k`. -/
@[to_additive
      "An induction principle for additive closure membership. If `p` holds for `0` and all\nelements of `k` and their negation, and is preserved under addition, then `p` holds for all\nelements of the additive closure of `k`."]
theorem closure_induction'' {p : G → Prop} {x} (h : x ∈ closure k) (Hk : ∀ x ∈ k, p x) (Hk_inv : ∀ x ∈ k, p x⁻¹)
    (H1 : p 1) (Hmul : ∀ x y, p x → p y → p (x * y)) : p x :=
  closure_induction_left h H1 (fun x hx y hy => Hmul x y (Hk x hx) hy) fun x hx y hy => Hmul x⁻¹ y (Hk_inv x hx) hy

/-- An induction principle for elements of `⨆ i, S i`.
If `C` holds for `1` and all elements of `S i` for all `i`, and is preserved under multiplication,
then it holds for all elements of the supremum of `S`. -/
@[elabAsElim,
  to_additive
      " An induction principle for elements of `⨆ i, S i`.\nIf `C` holds for `0` and all elements of `S i` for all `i`, and is preserved under addition,\nthen it holds for all elements of the supremum of `S`. "]
theorem supr_induction {ι : Sort _} (S : ι → Subgroup G) {C : G → Prop} {x : G} (hx : x ∈ ⨆ i, S i)
    (hp : ∀ (i), ∀ x ∈ S i, C x) (h1 : C 1) (hmul : ∀ x y, C x → C y → C (x * y)) : C x := by
  rw [supr_eq_closure] at hx
  refine' closure_induction'' hx (fun x hx => _) (fun x hx => _) h1 hmul
  · obtain ⟨i, hi⟩ := set.mem_Union.mp hx
    exact hp _ _ hi
    
  · obtain ⟨i, hi⟩ := set.mem_Union.mp hx
    exact hp _ _ (inv_mem hi)
    

/-- A dependent version of `subgroup.supr_induction`. -/
@[elabAsElim, to_additive "A dependent version of `add_subgroup.supr_induction`. "]
theorem supr_induction' {ι : Sort _} (S : ι → Subgroup G) {C : ∀ x, (x ∈ ⨆ i, S i) → Prop}
    (hp : ∀ (i), ∀ x ∈ S i, C x (mem_supr_of_mem i ‹_›)) (h1 : C 1 (one_mem _))
    (hmul : ∀ x y hx hy, C x hx → C y hy → C (x * y) (mul_mem ‹_› ‹_›)) {x : G} (hx : x ∈ ⨆ i, S i) : C x hx := by
  refine' Exists.elim _ fun (hx : x ∈ ⨆ i, S i) (hc : C x hx) => hc
  refine' supr_induction S hx (fun i x hx => _) _ fun x y => _
  · exact ⟨_, hp _ _ hx⟩
    
  · exact ⟨_, h1⟩
    
  · rintro ⟨_, Cx⟩ ⟨_, Cy⟩
    refine' ⟨_, hmul _ _ _ _ Cx Cy⟩
    

@[to_additive]
theorem mem_supr_of_directed {ι} [hι : Nonempty ι] {K : ι → Subgroup G} (hK : Directed (· ≤ ·) K) {x : G} :
    x ∈ (supr K : Subgroup G) ↔ ∃ i, x ∈ K i := by
  refine' ⟨_, fun ⟨i, hi⟩ => (SetLike.le_def.1 <| le_supr K i) hi⟩
  suffices x ∈ closure (⋃ i, (K i : Set G)) → ∃ i, x ∈ K i by
    simpa only [closure_Union, closure_eq (K _)] using this
  refine' fun hx => closure_induction hx (fun _ => mem_Union.1) _ _ _
  · exact hι.elim fun i => ⟨i, (K i).one_mem⟩
    
  · rintro x y ⟨i, hi⟩ ⟨j, hj⟩
    rcases hK i j with ⟨k, hki, hkj⟩
    exact ⟨k, mul_mem (hki hi) (hkj hj)⟩
    
  rintro _ ⟨i, hi⟩
  exact ⟨i, inv_mem hi⟩

@[to_additive]
theorem coe_supr_of_directed {ι} [Nonempty ι] {S : ι → Subgroup G} (hS : Directed (· ≤ ·) S) :
    ((⨆ i, S i : Subgroup G) : Set G) = ⋃ i, ↑(S i) :=
  Set.ext fun x => by
    simp [mem_supr_of_directed hS]

@[to_additive]
theorem mem_Sup_of_directed_on {K : Set (Subgroup G)} (Kne : K.Nonempty) (hK : DirectedOn (· ≤ ·) K) {x : G} :
    x ∈ sup K ↔ ∃ s ∈ K, x ∈ s := by
  haveI : Nonempty K := Kne.to_subtype
  simp only [Sup_eq_supr', mem_supr_of_directed hK.directed_coe, SetCoe.exists, Subtype.coe_mk]

variable {N : Type _} [Groupₓ N] {P : Type _} [Groupₓ P]

/-- The preimage of a subgroup along a monoid homomorphism is a subgroup. -/
@[to_additive "The preimage of an `add_subgroup` along an `add_monoid` homomorphism\nis an `add_subgroup`."]
def comap {N : Type _} [Groupₓ N] (f : G →* N) (H : Subgroup N) : Subgroup G :=
  { H.toSubmonoid.comap f with Carrier := f ⁻¹' H,
    inv_mem' := fun a ha =>
      show f a⁻¹ ∈ H by
        rw [f.map_inv] <;> exact H.inv_mem ha }

@[simp, to_additive]
theorem coe_comap (K : Subgroup N) (f : G →* N) : (K.comap f : Set G) = f ⁻¹' K :=
  rfl

@[simp, to_additive]
theorem mem_comap {K : Subgroup N} {f : G →* N} {x : G} : x ∈ K.comap f ↔ f x ∈ K :=
  Iff.rfl

@[to_additive]
theorem comap_mono {f : G →* N} {K K' : Subgroup N} : K ≤ K' → comap f K ≤ comap f K' :=
  preimage_mono

@[to_additive]
theorem comap_comap (K : Subgroup P) (g : N →* P) (f : G →* N) : (K.comap g).comap f = K.comap (g.comp f) :=
  rfl

/-- The image of a subgroup along a monoid homomorphism is a subgroup. -/
@[to_additive "The image of an `add_subgroup` along an `add_monoid` homomorphism\nis an `add_subgroup`."]
def map (f : G →* N) (H : Subgroup G) : Subgroup N :=
  { H.toSubmonoid.map f with Carrier := f '' H,
    inv_mem' := by
      rintro _ ⟨x, hx, rfl⟩
      exact ⟨x⁻¹, H.inv_mem hx, f.map_inv x⟩ }

@[simp, to_additive]
theorem coe_map (f : G →* N) (K : Subgroup G) : (K.map f : Set N) = f '' K :=
  rfl

@[simp, to_additive]
theorem mem_map {f : G →* N} {K : Subgroup G} {y : N} : y ∈ K.map f ↔ ∃ x ∈ K, f x = y :=
  mem_image_iff_bex

@[to_additive]
theorem mem_map_of_mem (f : G →* N) {K : Subgroup G} {x : G} (hx : x ∈ K) : f x ∈ K.map f :=
  mem_image_of_mem f hx

@[to_additive]
theorem apply_coe_mem_map (f : G →* N) (K : Subgroup G) (x : K) : f x ∈ K.map f :=
  mem_map_of_mem f x.Prop

@[to_additive]
theorem map_mono {f : G →* N} {K K' : Subgroup G} : K ≤ K' → map f K ≤ map f K' :=
  image_subset _

@[simp, to_additive]
theorem map_id : K.map (MonoidHom.id G) = K :=
  SetLike.coe_injective <| image_id _

@[to_additive]
theorem map_map (g : N →* P) (f : G →* N) : (K.map f).map g = K.map (g.comp f) :=
  SetLike.coe_injective <| image_image _ _ _

@[simp, to_additive]
theorem map_one_eq_bot : K.map (1 : G →* N) = ⊥ :=
  eq_bot_iff.mpr <| by
    rintro x ⟨y, _, rfl⟩
    simp

@[to_additive]
theorem mem_map_equiv {f : G ≃* N} {K : Subgroup G} {x : N} : x ∈ K.map f.toMonoidHom ↔ f.symm x ∈ K :=
  @Set.mem_image_equiv _ _ (↑K) f.toEquiv x

@[to_additive]
theorem mem_map_iff_mem {f : G →* N} (hf : Function.Injective f) {K : Subgroup G} {x : G} : f x ∈ K.map f ↔ x ∈ K :=
  hf.mem_set_image

@[to_additive]
theorem map_equiv_eq_comap_symm (f : G ≃* N) (K : Subgroup G) : K.map f.toMonoidHom = K.comap f.symm.toMonoidHom :=
  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)

@[to_additive]
theorem comap_equiv_eq_map_symm (f : N ≃* G) (K : Subgroup G) : K.comap f.toMonoidHom = K.map f.symm.toMonoidHom :=
  (map_equiv_eq_comap_symm f.symm K).symm

@[to_additive]
theorem map_le_iff_le_comap {f : G →* N} {K : Subgroup G} {H : Subgroup N} : K.map f ≤ H ↔ K ≤ H.comap f :=
  image_subset_iff

@[to_additive]
theorem gc_map_comap (f : G →* N) : GaloisConnection (map f) (comap f) := fun _ _ => map_le_iff_le_comap

@[to_additive]
theorem map_sup (H K : Subgroup G) (f : G →* N) : (H⊔K).map f = H.map f⊔K.map f :=
  (gc_map_comap f).l_sup

@[to_additive]
theorem map_supr {ι : Sort _} (f : G →* N) (s : ι → Subgroup G) : (supr s).map f = ⨆ i, (s i).map f :=
  (gc_map_comap f).l_supr

@[to_additive]
theorem comap_sup_comap_le (H K : Subgroup N) (f : G →* N) : comap f H⊔comap f K ≤ comap f (H⊔K) :=
  Monotone.le_map_sup (fun _ _ => comap_mono) H K

@[to_additive]
theorem supr_comap_le {ι : Sort _} (f : G →* N) (s : ι → Subgroup N) : (⨆ i, (s i).comap f) ≤ (supr s).comap f :=
  Monotone.le_map_supr fun _ _ => comap_mono

@[to_additive]
theorem comap_inf (H K : Subgroup N) (f : G →* N) : (H⊓K).comap f = H.comap f⊓K.comap f :=
  (gc_map_comap f).u_inf

@[to_additive]
theorem comap_infi {ι : Sort _} (f : G →* N) (s : ι → Subgroup N) : (infi s).comap f = ⨅ i, (s i).comap f :=
  (gc_map_comap f).u_infi

@[to_additive]
theorem map_inf_le (H K : Subgroup G) (f : G →* N) : map f (H⊓K) ≤ map f H⊓map f K :=
  le_inf (map_mono inf_le_left) (map_mono inf_le_right)

@[to_additive]
theorem map_inf_eq (H K : Subgroup G) (f : G →* N) (hf : Function.Injective f) : map f (H⊓K) = map f H⊓map f K := by
  rw [← SetLike.coe_set_eq]
  simp [Set.image_inter hf]

@[simp, to_additive]
theorem map_bot (f : G →* N) : (⊥ : Subgroup G).map f = ⊥ :=
  (gc_map_comap f).l_bot

@[simp, to_additive]
theorem map_top_of_surjective (f : G →* N) (h : Function.Surjective f) : Subgroup.map f ⊤ = ⊤ := by
  rw [eq_top_iff]
  intro x hx
  obtain ⟨y, hy⟩ := h x
  exact ⟨y, trivialₓ, hy⟩

@[simp, to_additive]
theorem comap_top (f : G →* N) : (⊤ : Subgroup N).comap f = ⊤ :=
  (gc_map_comap f).u_top

@[simp, to_additive]
theorem comap_subtype_self_eq_top {G : Type _} [Groupₓ G] {H : Subgroup G} : comap H.Subtype H = ⊤ := by
  ext
  simp

@[simp, to_additive]
theorem comap_subtype_inf_left {H K : Subgroup G} : comap H.Subtype (H⊓K) = comap H.Subtype K :=
  ext fun x => and_iff_right_of_imp fun _ => x.Prop

@[simp, to_additive]
theorem comap_subtype_inf_right {H K : Subgroup G} : comap K.Subtype (H⊓K) = comap K.Subtype H :=
  ext fun x => and_iff_left_of_imp fun _ => x.Prop

/-- If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`. -/
@[to_additive "If `H ≤ K`, then `H` as a subgroup of `K` is isomorphic to `H`.", simps]
def comapSubtypeEquivOfLe {G : Type _} [Groupₓ G] {H K : Subgroup G} (h : H ≤ K) : H.comap K.Subtype ≃* H where
  toFun := fun g => ⟨g.1, g.2⟩
  invFun := fun g => ⟨⟨g.1, h g.2⟩, g.2⟩
  left_inv := fun g => Subtype.ext (Subtype.ext rfl)
  right_inv := fun g => Subtype.ext rfl
  map_mul' := fun g h => rfl

/-- For any subgroups `H` and `K`, view `H ⊓ K` as a subgroup of `K`. -/
@[to_additive "For any subgroups `H` and `K`, view `H ⊓ K` as a subgroup of `K`."]
def subgroupOf (H K : Subgroup G) : Subgroup K :=
  H.comap K.Subtype

@[to_additive]
theorem coe_subgroup_of (H K : Subgroup G) : (H.subgroupOf K : Set K) = K.Subtype ⁻¹' H :=
  rfl

@[to_additive]
theorem mem_subgroup_of {H K : Subgroup G} {h : K} : h ∈ H.subgroupOf K ↔ (h : G) ∈ H :=
  Iff.rfl

@[to_additive]
theorem subgroup_of_map_subtype (H K : Subgroup G) : (H.subgroupOf K).map K.Subtype = H⊓K :=
  SetLike.ext'
    (by
      convert Set.image_preimage_eq_inter_range
      simp only [Subtype.range_coe_subtype, coeSubtype, coe_inf]
      rfl)

@[simp, to_additive]
theorem bot_subgroup_of : (⊥ : Subgroup G).subgroupOf H = ⊥ :=
  Eq.symm (Subgroup.ext fun g => Subtype.ext_iff)

@[simp, to_additive]
theorem top_subgroup_of : (⊤ : Subgroup G).subgroupOf H = ⊤ :=
  rfl

@[to_additive]
theorem subgroup_of_bot_eq_bot : H.subgroupOf ⊥ = ⊥ :=
  Subsingleton.elimₓ _ _

@[to_additive]
theorem subgroup_of_bot_eq_top : H.subgroupOf ⊥ = ⊤ :=
  Subsingleton.elimₓ _ _

@[simp, to_additive]
theorem subgroup_of_self : H.subgroupOf H = ⊤ :=
  top_le_iff.mp fun g hg => g.2

/-- Given `subgroup`s `H`, `K` of groups `G`, `N` respectively, `H × K` as a subgroup of `G × N`. -/
@[to_additive Prod
      "Given `add_subgroup`s `H`, `K` of `add_group`s `A`, `B` respectively, `H × K`\nas an `add_subgroup` of `A × B`."]
def prod (H : Subgroup G) (K : Subgroup N) : Subgroup (G × N) :=
  { Submonoid.prod H.toSubmonoid K.toSubmonoid with inv_mem' := fun _ hx => ⟨H.inv_mem' hx.1, K.inv_mem' hx.2⟩ }

@[to_additive coe_prod]
theorem coe_prod (H : Subgroup G) (K : Subgroup N) : (H.Prod K : Set (G × N)) = H ×ˢ K :=
  rfl

@[to_additive mem_prod]
theorem mem_prod {H : Subgroup G} {K : Subgroup N} {p : G × N} : p ∈ H.Prod K ↔ p.1 ∈ H ∧ p.2 ∈ K :=
  Iff.rfl

@[to_additive prod_mono]
theorem prod_mono : ((· ≤ ·)⇒(· ≤ ·)⇒(· ≤ ·)) (@prod G _ N _) (@prod G _ N _) := fun s s' hs t t' ht =>
  Set.prod_mono hs ht

@[to_additive prod_mono_right]
theorem prod_mono_right (K : Subgroup G) : Monotone fun t : Subgroup N => K.Prod t :=
  prod_mono (le_reflₓ K)

@[to_additive prod_mono_left]
theorem prod_mono_left (H : Subgroup N) : Monotone fun K : Subgroup G => K.Prod H := fun s₁ s₂ hs =>
  prod_mono hs (le_reflₓ H)

@[to_additive prod_top]
theorem prod_top (K : Subgroup G) : K.Prod (⊤ : Subgroup N) = K.comap (MonoidHom.fst G N) :=
  ext fun x => by
    simp [mem_prod, MonoidHom.coe_fst]

@[to_additive top_prod]
theorem top_prod (H : Subgroup N) : (⊤ : Subgroup G).Prod H = H.comap (MonoidHom.snd G N) :=
  ext fun x => by
    simp [mem_prod, MonoidHom.coe_snd]

@[simp, to_additive top_prod_top]
theorem top_prod_top : (⊤ : Subgroup G).Prod (⊤ : Subgroup N) = ⊤ :=
  (top_prod _).trans <| comap_top _

@[to_additive]
theorem bot_prod_bot : (⊥ : Subgroup G).Prod (⊥ : Subgroup N) = ⊥ :=
  SetLike.coe_injective <| by
    simp [coe_prod, Prod.one_eq_mk]

@[to_additive le_prod_iff]
theorem le_prod_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :
    J ≤ H.Prod K ↔ map (MonoidHom.fst G N) J ≤ H ∧ map (MonoidHom.snd G N) J ≤ K := by
  simpa only [← Subgroup.to_submonoid_le] using Submonoid.le_prod_iff

@[to_additive prod_le_iff]
theorem prod_le_iff {H : Subgroup G} {K : Subgroup N} {J : Subgroup (G × N)} :
    H.Prod K ≤ J ↔ map (MonoidHom.inl G N) H ≤ J ∧ map (MonoidHom.inr G N) K ≤ J := by
  simpa only [← Subgroup.to_submonoid_le] using Submonoid.prod_le_iff

@[simp, to_additive prod_eq_bot_iff]
theorem prod_eq_bot_iff {H : Subgroup G} {K : Subgroup N} : H.Prod K = ⊥ ↔ H = ⊥ ∧ K = ⊥ := by
  simpa only [← Subgroup.to_submonoid_eq] using Submonoid.prod_eq_bot_iff

/-- Product of subgroups is isomorphic to their product as groups. -/
@[to_additive prod_equiv "Product of additive subgroups is isomorphic to their product\nas additive groups"]
def prodEquiv (H : Subgroup G) (K : Subgroup N) : H.Prod K ≃* H × K :=
  { Equivₓ.Set.prod ↑H ↑K with map_mul' := fun x y => rfl }

section Pi

variable {η : Type _} {f : η → Type _}

-- defined here and not in group_theory.submonoid.operations to have access to algebra.group.pi
/-- A version of `set.pi` for submonoids. Given an index set `I` and a family of submodules
`s : Π i, submonoid f i`, `pi I s` is the submonoid of dependent functions `f : Π i, f i` such that
`f i` belongs to `pi I s` whenever `i ∈ I`. -/
@[to_additive
      " A version of `set.pi` for `add_submonoid`s. Given an index set `I` and a family\nof submodules `s : Π i, add_submonoid f i`, `pi I s` is the `add_submonoid` of dependent functions\n`f : Π i, f i` such that `f i` belongs to `pi I s` whenever `i ∈ I`. -/ "]
def _root_.submonoid.pi [∀ i, MulOneClassₓ (f i)] (I : Set η) (s : ∀ i, Submonoid (f i)) : Submonoid (∀ i, f i) where
  Carrier := I.pi fun i => (s i).Carrier
  one_mem' := fun i _ => (s i).one_mem
  mul_mem' := fun p q hp hq i hI => (s i).mul_mem (hp i hI) (hq i hI)

variable [∀ i, Groupₓ (f i)]

/-- A version of `set.pi` for subgroups. Given an index set `I` and a family of submodules
`s : Π i, subgroup f i`, `pi I s` is the subgroup of dependent functions `f : Π i, f i` such that
`f i` belongs to `pi I s` whenever `i ∈ I`. -/
@[to_additive
      " A version of `set.pi` for `add_subgroup`s. Given an index set `I` and a family\nof submodules `s : Π i, add_subgroup f i`, `pi I s` is the `add_subgroup` of dependent functions\n`f : Π i, f i` such that `f i` belongs to `pi I s` whenever `i ∈ I`. -/ "]
def pi (I : Set η) (H : ∀ i, Subgroup (f i)) : Subgroup (∀ i, f i) :=
  { Submonoid.pi I fun i => (H i).toSubmonoid with inv_mem' := fun p hp i hI => (H i).inv_mem (hp i hI) }

@[to_additive]
theorem coe_pi (I : Set η) (H : ∀ i, Subgroup (f i)) :
    (pi I H : Set (∀ i, f i)) = Set.Pi I fun i => (H i : Set (f i)) :=
  rfl

@[to_additive]
theorem mem_pi (I : Set η) {H : ∀ i, Subgroup (f i)} {p : ∀ i, f i} : p ∈ pi I H ↔ ∀ i : η, i ∈ I → p i ∈ H i :=
  Iff.rfl

@[to_additive]
theorem pi_top (I : Set η) : (pi I fun i => (⊤ : Subgroup (f i))) = ⊤ :=
  ext fun x => by
    simp [mem_pi]

@[to_additive]
theorem pi_empty (H : ∀ i, Subgroup (f i)) : pi ∅ H = ⊤ :=
  ext fun x => by
    simp [mem_pi]

@[to_additive]
theorem pi_bot : (pi Set.Univ fun i => (⊥ : Subgroup (f i))) = ⊥ :=
  (eq_bot_iff_forall _).mpr fun p hp => by
    simp only [mem_pi, mem_bot] at *
    ext j
    exact hp j trivialₓ

@[to_additive]
theorem le_pi_iff {I : Set η} {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :
    J ≤ pi I H ↔ ∀ i : η, i ∈ I → map (Pi.evalMonoidHom f i) J ≤ H i := by
  constructor
  · intro h i hi
    rintro _ ⟨x, hx, rfl⟩
    exact (h hx) _ hi
    
  · intro h x hx i hi
    refine' h i hi ⟨_, hx, rfl⟩
    

@[simp, to_additive]
theorem mul_single_mem_pi [DecidableEq η] {I : Set η} {H : ∀ i, Subgroup (f i)} (i : η) (x : f i) :
    Pi.mulSingle i x ∈ pi I H ↔ i ∈ I → x ∈ H i := by
  constructor
  · intro h hi
    simpa using h i hi
    
  · intro h j hj
    by_cases' heq : j = i
    · subst HEq
      simpa using h hj
      
    · simp [HEq, one_mem]
      
    

@[to_additive]
theorem pi_mem_of_mul_single_mem_aux [DecidableEq η] (I : Finset η) {H : Subgroup (∀ i, f i)} (x : ∀ i, f i)
    (h1 : ∀ i, i ∉ I → x i = 1) (h2 : ∀ i, i ∈ I → Pi.mulSingle i (x i) ∈ H) : x ∈ H := by
  induction' I using Finset.induction_on with i I hnmem ih generalizing x
  · convert one_mem H
    ext i
    exact h1 i (not_mem_empty i)
    
  · have : x = Function.update x i 1 * Pi.mulSingle i (x i) := by
      ext j
      by_cases' heq : j = i
      · subst HEq
        simp
        
      · simp [HEq]
        
    rw [this]
    clear this
    apply mul_mem
    · apply ih <;> clear ih
      · intro j hj
        by_cases' heq : j = i
        · subst HEq
          simp
          
        · simp [HEq]
          apply h1 j
          simpa [HEq] using hj
          
        
      · intro j hj
        have : j ≠ i := by
          rintro rfl
          contradiction
        simp [this]
        exact h2 _ (Finset.mem_insert_of_mem hj)
        
      
    · apply h2
      simp
      
    

@[to_additive]
theorem pi_mem_of_mul_single_mem [Finite η] [DecidableEq η] {H : Subgroup (∀ i, f i)} (x : ∀ i, f i)
    (h : ∀ i, Pi.mulSingle i (x i) ∈ H) : x ∈ H := by
  cases nonempty_fintype η
  exact
    pi_mem_of_mul_single_mem_aux Finset.univ x
      (by
        simp )
      fun i _ => h i

/-- For finite index types, the `subgroup.pi` is generated by the embeddings of the groups.  -/
@[to_additive "For finite index types, the `subgroup.pi` is generated by the embeddings of the\nadditive groups."]
theorem pi_le_iff [DecidableEq η] [Finite η] {H : ∀ i, Subgroup (f i)} {J : Subgroup (∀ i, f i)} :
    pi Univ H ≤ J ↔ ∀ i : η, map (MonoidHom.single f i) (H i) ≤ J := by
  constructor
  · rintro h i _ ⟨x, hx, rfl⟩
    apply h
    simpa using hx
    
  · exact fun h x hx => pi_mem_of_mul_single_mem x fun i => h i (mem_map_of_mem _ (hx i trivialₓ))
    

@[to_additive]
theorem pi_eq_bot_iff (H : ∀ i, Subgroup (f i)) : pi Set.Univ H = ⊥ ↔ ∀ i, H i = ⊥ := by
  classical
  simp only [eq_bot_iff_forall]
  constructor
  · intro h i x hx
    have : MonoidHom.single f i x = 1 := h (MonoidHom.single f i x) ((mul_single_mem_pi i x).mpr fun _ => hx)
    simpa using congr_fun this i
    
  · exact fun h x hx => funext fun i => h _ _ (hx i trivialₓ)
    

end Pi

/-- A subgroup is normal if whenever `n ∈ H`, then `g * n * g⁻¹ ∈ H` for every `g : G` -/
structure Normal : Prop where
  conj_mem : ∀ n, n ∈ H → ∀ g : G, g * n * g⁻¹ ∈ H

attribute [class] normal

end Subgroup

namespace AddSubgroup

-- ./././Mathport/Syntax/Translate/Command.lean:324:30: infer kinds are unsupported in Lean 4: #[`conj_mem] []
/-- An add_subgroup is normal if whenever `n ∈ H`, then `g + n - g ∈ H` for every `g : G` -/
structure Normal (H : AddSubgroup A) : Prop where
  conj_mem : ∀ n, n ∈ H → ∀ g : A, g + n + -g ∈ H

attribute [to_additive AddSubgroup.Normal] Subgroup.Normal

attribute [class] normal

end AddSubgroup

namespace Subgroup

variable {H K : Subgroup G}

@[to_additive]
instance (priority := 100) normal_of_comm {G : Type _} [CommGroupₓ G] (H : Subgroup G) : H.Normal :=
  ⟨by
    simp [mul_comm, mul_left_commₓ]⟩

namespace Normal

variable (nH : H.Normal)

@[to_additive]
theorem mem_comm {a b : G} (h : a * b ∈ H) : b * a ∈ H := by
  have : a⁻¹ * (a * b) * a⁻¹⁻¹ ∈ H := nH.conj_mem (a * b) h a⁻¹
  simpa

@[to_additive]
theorem mem_comm_iff {a b : G} : a * b ∈ H ↔ b * a ∈ H :=
  ⟨nH.mem_comm, nH.mem_comm⟩

end Normal

variable (H)

/-- A subgroup is characteristic if it is fixed by all automorphisms.
  Several equivalent conditions are provided by lemmas of the form `characteristic.iff...` -/
structure Characteristic : Prop where
  fixed : ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom = H

attribute [class] characteristic

instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=
  ⟨fun a ha b => (SetLike.ext_iff.mp (h.fixed (MulAut.conj b)) a).mpr ha⟩

end Subgroup

namespace AddSubgroup

variable (H : AddSubgroup A)

/-- A add_subgroup is characteristic if it is fixed by all automorphisms.
  Several equivalent conditions are provided by lemmas of the form `characteristic.iff...` -/
structure Characteristic : Prop where
  fixed : ∀ ϕ : A ≃+ A, H.comap ϕ.toAddMonoidHom = H

attribute [to_additive AddSubgroup.Characteristic] Subgroup.Characteristic

attribute [class] characteristic

instance (priority := 100) normal_of_characteristic [h : H.Characteristic] : H.Normal :=
  ⟨fun a ha b => (SetLike.ext_iff.mp (h.fixed (AddAut.conj b)) a).mpr ha⟩

end AddSubgroup

namespace Subgroup

variable {H K : Subgroup G}

@[to_additive]
theorem characteristic_iff_comap_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom = H :=
  ⟨Characteristic.fixed, Characteristic.mk⟩

@[to_additive]
theorem characteristic_iff_comap_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.comap ϕ.toMonoidHom ≤ H :=
  characteristic_iff_comap_eq.trans
    ⟨fun h ϕ => le_of_eqₓ (h ϕ), fun h ϕ =>
      le_antisymmₓ (h ϕ) fun g hg => h ϕ.symm ((congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mpr hg)⟩

@[to_additive]
theorem characteristic_iff_le_comap : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.comap ϕ.toMonoidHom :=
  characteristic_iff_comap_eq.trans
    ⟨fun h ϕ => ge_of_eqₓ (h ϕ), fun h ϕ =>
      le_antisymmₓ (fun g hg => (congr_arg (· ∈ H) (ϕ.symm_apply_apply g)).mp (h ϕ.symm hg)) (h ϕ)⟩

@[to_additive]
theorem characteristic_iff_map_eq : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom = H := by
  simp_rw [map_equiv_eq_comap_symm]
  exact characteristic_iff_comap_eq.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩

@[to_additive]
theorem characteristic_iff_map_le : H.Characteristic ↔ ∀ ϕ : G ≃* G, H.map ϕ.toMonoidHom ≤ H := by
  simp_rw [map_equiv_eq_comap_symm]
  exact characteristic_iff_comap_le.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩

@[to_additive]
theorem characteristic_iff_le_map : H.Characteristic ↔ ∀ ϕ : G ≃* G, H ≤ H.map ϕ.toMonoidHom := by
  simp_rw [map_equiv_eq_comap_symm]
  exact characteristic_iff_le_comap.trans ⟨fun h ϕ => h ϕ.symm, fun h ϕ => h ϕ.symm⟩

@[to_additive]
instance bot_characteristic : Characteristic (⊥ : Subgroup G) :=
  characteristic_iff_le_map.mpr fun ϕ => bot_le

@[to_additive]
instance top_characteristic : Characteristic (⊤ : Subgroup G) :=
  characteristic_iff_map_le.mpr fun ϕ => le_top

variable (G)

/-- The center of a group `G` is the set of elements that commute with everything in `G` -/
@[to_additive "The center of an additive group `G` is the set of elements that commute with\neverything in `G`"]
def center : Subgroup G :=
  { Submonoid.center G with Carrier := Set.Center G, inv_mem' := fun a => Set.inv_mem_center }

@[to_additive]
theorem coe_center : ↑(center G) = Set.Center G :=
  rfl

@[simp, to_additive]
theorem center_to_submonoid : (center G).toSubmonoid = Submonoid.center G :=
  rfl

variable {G}

@[to_additive]
theorem mem_center_iff {z : G} : z ∈ center G ↔ ∀ g, g * z = z * g :=
  Iff.rfl

instance decidableMemCenter [DecidableEq G] [Fintype G] : DecidablePred (· ∈ center G) := fun _ =>
  decidableOfIff' _ mem_center_iff

@[to_additive]
instance center_characteristic : (center G).Characteristic := by
  refine' characteristic_iff_comap_le.mpr fun ϕ g hg h => _
  rw [← ϕ.injective.eq_iff, ϕ.map_mul, ϕ.map_mul]
  exact hg (ϕ h)

theorem _root_.comm_group.center_eq_top {G : Type _} [CommGroupₓ G] : center G = ⊤ := by
  rw [eq_top_iff']
  intro x y
  exact mul_comm y x

/-- A group is commutative if the center is the whole group -/
def _root_.group.comm_group_of_center_eq_top (h : center G = ⊤) : CommGroupₓ G :=
  { (_ : Groupₓ G) with
    mul_comm := by
      rw [eq_top_iff'] at h
      intro x y
      exact h y x }

variable {G} (H)

section Normalizer

/-- The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal. -/
@[to_additive "The `normalizer` of `H` is the largest subgroup of `G` inside which `H` is normal."]
def normalizer : Subgroup G where
  Carrier := { g : G | ∀ n, n ∈ H ↔ g * n * g⁻¹ ∈ H }
  one_mem' := by
    simp
  mul_mem' := fun a b (ha : ∀ n, n ∈ H ↔ a * n * a⁻¹ ∈ H) (hb : ∀ n, n ∈ H ↔ b * n * b⁻¹ ∈ H) n => by
    rw [hb, ha]
    simp [mul_assoc]
  inv_mem' := fun a (ha : ∀ n, n ∈ H ↔ a * n * a⁻¹ ∈ H) n => by
    rw [ha (a⁻¹ * n * a⁻¹⁻¹)]
    simp [mul_assoc]

-- variant for sets.
-- TODO should this replace `normalizer`?
/-- The `set_normalizer` of `S` is the subgroup of `G` whose elements satisfy `g*S*g⁻¹=S` -/
@[to_additive "The `set_normalizer` of `S` is the subgroup of `G` whose elements satisfy\n`g+S-g=S`."]
def setNormalizer (S : Set G) : Subgroup G where
  Carrier := { g : G | ∀ n, n ∈ S ↔ g * n * g⁻¹ ∈ S }
  one_mem' := by
    simp
  mul_mem' := fun a b (ha : ∀ n, n ∈ S ↔ a * n * a⁻¹ ∈ S) (hb : ∀ n, n ∈ S ↔ b * n * b⁻¹ ∈ S) n => by
    rw [hb, ha]
    simp [mul_assoc]
  inv_mem' := fun a (ha : ∀ n, n ∈ S ↔ a * n * a⁻¹ ∈ S) n => by
    rw [ha (a⁻¹ * n * a⁻¹⁻¹)]
    simp [mul_assoc]

theorem mem_normalizer_fintype {S : Set G} [Finite S] {x : G} (h : ∀ n, n ∈ S → x * n * x⁻¹ ∈ S) :
    x ∈ Subgroup.setNormalizer S := by
  haveI := Classical.propDecidable <;>
    cases nonempty_fintype S <;>
      haveI := Set.fintypeImage S fun n => x * n * x⁻¹ <;>
        exact fun n =>
          ⟨h n, fun h₁ =>
            have heq : (fun n => x * n * x⁻¹) '' S = S :=
              Set.eq_of_subset_of_card_le (fun n ⟨y, hy⟩ => hy.2 ▸ h y hy.1)
                (by
                  rw [Set.card_image_of_injective S conj_injective])
            have : x * n * x⁻¹ ∈ (fun n => x * n * x⁻¹) '' S := HEq.symm ▸ h₁
            let ⟨y, hy⟩ := this
            conj_injective hy.2 ▸ hy.1⟩

variable {H}

@[to_additive]
theorem mem_normalizer_iff {g : G} : g ∈ H.normalizer ↔ ∀ h, h ∈ H ↔ g * h * g⁻¹ ∈ H :=
  Iff.rfl

@[to_additive]
theorem mem_normalizer_iff'' {g : G} : g ∈ H.normalizer ↔ ∀ h : G, h ∈ H ↔ g⁻¹ * h * g ∈ H := by
  rw [← inv_mem_iff, mem_normalizer_iff, inv_invₓ]

@[to_additive]
theorem mem_normalizer_iff' {g : G} : g ∈ H.normalizer ↔ ∀ n, n * g ∈ H ↔ g * n ∈ H :=
  ⟨fun h n => by
    rw [h, mul_assoc, mul_inv_cancel_rightₓ], fun h n => by
    rw [mul_assoc, ← h, inv_mul_cancel_right]⟩

@[to_additive]
theorem le_normalizer : H ≤ normalizer H := fun x xH n => by
  rw [H.mul_mem_cancel_right (H.inv_mem xH), H.mul_mem_cancel_left xH]

@[to_additive]
instance (priority := 100) normal_in_normalizer : (H.comap H.normalizer.Subtype).Normal :=
  ⟨fun x xH g => by
    simpa using (g.2 x).1 xH⟩

@[to_additive]
theorem normalizer_eq_top : H.normalizer = ⊤ ↔ H.Normal :=
  eq_top_iff.trans
    ⟨fun h => ⟨fun a ha b => (h (mem_top b) a).mp ha⟩, fun h a ha b =>
      ⟨fun hb => h.conj_mem b hb a, fun hb => by
        rwa [h.mem_comm_iff, inv_mul_cancel_leftₓ] at hb⟩⟩

@[to_additive]
theorem center_le_normalizer : center G ≤ H.normalizer := fun x hx y => by
  simp [← mem_center_iff.mp hx y, mul_assoc]

open Classical

@[to_additive]
theorem le_normalizer_of_normal [hK : (H.comap K.Subtype).Normal] (HK : H ≤ K) : K ≤ H.normalizer := fun x hx y =>
  ⟨fun yH => hK.conj_mem ⟨y, HK yH⟩ yH ⟨x, hx⟩, fun yH => by
    simpa [mem_comap, mul_assoc] using hK.conj_mem ⟨x * y * x⁻¹, HK yH⟩ yH ⟨x⁻¹, K.inv_mem hx⟩⟩

variable {N : Type _} [Groupₓ N]

/-- The preimage of the normalizer is contained in the normalizer of the preimage. -/
@[to_additive "The preimage of the normalizer is contained in the normalizer of the preimage."]
theorem le_normalizer_comap (f : N →* G) : H.normalizer.comap f ≤ (H.comap f).normalizer := fun x => by
  simp only [mem_normalizer_iff, mem_comap]
  intro h n
  simp [h (f n)]

/-- The image of the normalizer is contained in the normalizer of the image. -/
@[to_additive "The image of the normalizer is contained in the normalizer of the image."]
theorem le_normalizer_map (f : G →* N) : H.normalizer.map f ≤ (H.map f).normalizer := fun _ => by
  simp only [and_imp, exists_prop, mem_map, exists_imp_distrib, mem_normalizer_iff]
  rintro x hx rfl n
  constructor
  · rintro ⟨y, hy, rfl⟩
    use x * y * x⁻¹, (hx y).1 hy
    simp
    
  · rintro ⟨y, hyH, hy⟩
    use x⁻¹ * y * x
    rw [hx]
    simp [hy, hyH, mul_assoc]
    

variable (G)

/-- Every proper subgroup `H` of `G` is a proper normal subgroup of the normalizer of `H` in `G`. -/
def _root_.normalizer_condition :=
  ∀ H : Subgroup G, H < ⊤ → H < normalizer H

variable {G}

/-- Alternative phrasing of the normalizer condition: Only the full group is self-normalizing.
This may be easier to work with, as it avoids inequalities and negations.  -/
theorem _root_.normalizer_condition_iff_only_full_group_self_normalizing :
    NormalizerCondition G ↔ ∀ H : Subgroup G, H.normalizer = H → H = ⊤ := by
  apply forall_congrₓ
  intro H
  simp only [lt_iff_le_and_neₓ, le_normalizer, true_andₓ, le_top, Ne.def]
  tauto!

variable (H)

/-- In a group that satisifes the normalizer condition, every maximal subgroup is normal -/
theorem NormalizerCondition.normal_of_coatom (hnc : NormalizerCondition G) (hmax : IsCoatom H) : H.Normal :=
  normalizer_eq_top.mp (hmax.2 _ (hnc H (lt_top_iff_ne_top.mpr hmax.1)))

end Normalizer

section Centralizer

/-- The `centralizer` of `H` is the subgroup of `g : G` commuting with every `h : H`. -/
@[to_additive "The `centralizer` of `H` is the additive subgroup of `g : G` commuting with\nevery `h : H`."]
def centralizer : Subgroup G :=
  { Submonoid.centralizer ↑H with Carrier := Set.Centralizer H, inv_mem' := fun g => Set.inv_mem_centralizer }

@[to_additive]
theorem mem_centralizer_iff {g : G} : g ∈ H.Centralizer ↔ ∀ h ∈ H, h * g = g * h :=
  Iff.rfl

@[to_additive]
theorem mem_centralizer_iff_commutator_eq_one {g : G} : g ∈ H.Centralizer ↔ ∀ h ∈ H, h * g * h⁻¹ * g⁻¹ = 1 := by
  simp only [mem_centralizer_iff, mul_inv_eq_iff_eq_mul, one_mulₓ]

@[to_additive]
theorem centralizer_top : centralizer ⊤ = center G :=
  SetLike.ext' (Set.centralizer_univ G)

@[to_additive]
instance Subgroup.Centralizer.characteristic [hH : H.Characteristic] : H.Centralizer.Characteristic := by
  refine' subgroup.characteristic_iff_comap_le.mpr fun ϕ g hg h hh => ϕ.Injective _
  rw [map_mul, map_mul]
  exact hg (ϕ h) (subgroup.characteristic_iff_le_comap.mp hH ϕ hh)

end Centralizer

/-- Commutivity of a subgroup -/
structure IsCommutative : Prop where
  is_comm : IsCommutative H (· * ·)

attribute [class] IsCommutative

/-- Commutivity of an additive subgroup -/
structure _root_.add_subgroup.is_commutative (H : AddSubgroup A) : Prop where
  is_comm : IsCommutative H (· + ·)

attribute [to_additive AddSubgroup.IsCommutative] Subgroup.IsCommutative

attribute [class] AddSubgroup.IsCommutative

/-- A commutative subgroup is commutative. -/
@[to_additive "A commutative subgroup is commutative."]
instance IsCommutative.commGroup [h : H.IsCommutative] : CommGroupₓ H :=
  { H.toGroup with mul_comm := h.is_comm.comm }

instance center.is_commutative : (center G).IsCommutative :=
  ⟨⟨fun a b => Subtype.ext (b.2 a)⟩⟩

@[to_additive]
instance map_is_commutative {G' : Type _} [Groupₓ G'] (f : G →* G') [H.IsCommutative] : (H.map f).IsCommutative :=
  ⟨⟨by
      rintro ⟨-, a, ha, rfl⟩ ⟨-, b, hb, rfl⟩
      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← map_mul, ← map_mul]
      exact congr_arg f (subtype.ext_iff.mp (mul_comm ⟨a, ha⟩ ⟨b, hb⟩))⟩⟩

@[to_additive]
theorem comap_injective_is_commutative {G' : Type _} [Groupₓ G'] {f : G' →* G} (hf : Function.Injective f)
    [H.IsCommutative] : (H.comap f).IsCommutative :=
  ⟨⟨fun a b =>
      Subtype.ext
        (by
          have := mul_comm (⟨f a, a.2⟩ : H) (⟨f b, b.2⟩ : H)
          rwa [Subtype.ext_iff, coe_mul, coe_mul, coe_mk, coe_mk, ← map_mul, ← map_mul, hf.eq_iff] at this)⟩⟩

@[to_additive]
instance subgroup_of_is_commutative [H.IsCommutative] : (H.subgroupOf K).IsCommutative :=
  H.comap_injective_is_commutative Subtype.coe_injective

end Subgroup

namespace Groupₓ

variable {s : Set G}

/-- Given a set `s`, `conjugates_of_set s` is the set of all conjugates of
the elements of `s`. -/
def ConjugatesOfSet (s : Set G) : Set G :=
  ⋃ a ∈ s, ConjugatesOf a

theorem mem_conjugates_of_set_iff {x : G} : x ∈ ConjugatesOfSet s ↔ ∃ a ∈ s, IsConj a x :=
  Set.mem_Union₂

theorem subset_conjugates_of_set : s ⊆ ConjugatesOfSet s := fun (x : G) (h : x ∈ s) =>
  mem_conjugates_of_set_iff.2 ⟨x, h, IsConj.refl _⟩

theorem conjugates_of_set_mono {s t : Set G} (h : s ⊆ t) : ConjugatesOfSet s ⊆ ConjugatesOfSet t :=
  Set.bUnion_subset_bUnion_left h

theorem conjugates_subset_normal {N : Subgroup G} [tn : N.Normal] {a : G} (h : a ∈ N) : ConjugatesOf a ⊆ N := by
  rintro a hc
  obtain ⟨c, rfl⟩ := is_conj_iff.1 hc
  exact tn.conj_mem a h c

theorem conjugates_of_set_subset {s : Set G} {N : Subgroup G} [N.Normal] (h : s ⊆ N) : ConjugatesOfSet s ⊆ N :=
  Set.Union₂_subset fun x H => conjugates_subset_normal (h H)

/-- The set of conjugates of `s` is closed under conjugation. -/
theorem conj_mem_conjugates_of_set {x c : G} : x ∈ ConjugatesOfSet s → c * x * c⁻¹ ∈ ConjugatesOfSet s := fun H => by
  rcases mem_conjugates_of_set_iff.1 H with ⟨a, h₁, h₂⟩
  exact mem_conjugates_of_set_iff.2 ⟨a, h₁, h₂.trans (is_conj_iff.2 ⟨c, rfl⟩)⟩

end Groupₓ

namespace Subgroup

open Groupₓ

variable {s : Set G}

/-- The normal closure of a set `s` is the subgroup closure of all the conjugates of
elements of `s`. It is the smallest normal subgroup containing `s`. -/
def normalClosure (s : Set G) : Subgroup G :=
  closure (ConjugatesOfSet s)

theorem conjugates_of_set_subset_normal_closure : ConjugatesOfSet s ⊆ normalClosure s :=
  subset_closure

theorem subset_normal_closure : s ⊆ normalClosure s :=
  Set.Subset.trans subset_conjugates_of_set conjugates_of_set_subset_normal_closure

theorem le_normal_closure {H : Subgroup G} : H ≤ normalClosure ↑H := fun _ h => subset_normal_closure h

/-- The normal closure of `s` is a normal subgroup. -/
instance normal_closure_normal : (normalClosure s).Normal :=
  ⟨fun n h g => by
    refine' Subgroup.closure_induction h (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _
    · exact conjugates_of_set_subset_normal_closure (conj_mem_conjugates_of_set hx)
      
    · simpa using (normal_closure s).one_mem
      
    · rw [← conj_mul]
      exact mul_mem ihx ihy
      
    · rw [← conj_inv]
      exact inv_mem ihx
      ⟩

/-- The normal closure of `s` is the smallest normal subgroup containing `s`. -/
theorem normal_closure_le_normal {N : Subgroup G} [N.Normal] (h : s ⊆ N) : normalClosure s ≤ N := by
  intro a w
  refine' closure_induction w (fun x hx => _) _ (fun x y ihx ihy => _) fun x ihx => _
  · exact conjugates_of_set_subset h hx
    
  · exact one_mem _
    
  · exact mul_mem ihx ihy
    
  · exact inv_mem ihx
    

theorem normal_closure_subset_iff {N : Subgroup G} [N.Normal] : s ⊆ N ↔ normalClosure s ≤ N :=
  ⟨normal_closure_le_normal, Set.Subset.trans subset_normal_closure⟩

theorem normal_closure_mono {s t : Set G} (h : s ⊆ t) : normalClosure s ≤ normalClosure t :=
  normal_closure_le_normal (Set.Subset.trans h subset_normal_closure)

theorem normal_closure_eq_infi : normalClosure s = ⨅ (N : Subgroup G) (_ : Normal N) (hs : s ⊆ N), N :=
  le_antisymmₓ (le_infi fun N => le_infi fun hN => le_infi normal_closure_le_normal)
    (infi_le_of_le (normalClosure s)
      (infi_le_of_le
        (by
          infer_instance)
        (infi_le_of_le subset_normal_closure le_rflₓ)))

@[simp]
theorem normal_closure_eq_self (H : Subgroup G) [H.Normal] : normalClosure ↑H = H :=
  le_antisymmₓ (normal_closure_le_normal rfl.Subset) le_normal_closure

@[simp]
theorem normal_closure_idempotent : normalClosure ↑(normalClosure s) = normalClosure s :=
  normal_closure_eq_self _

theorem closure_le_normal_closure {s : Set G} : closure s ≤ normalClosure s := by
  simp only [subset_normal_closure, closure_le]

@[simp]
theorem normal_closure_closure_eq_normal_closure {s : Set G} : normalClosure ↑(closure s) = normalClosure s :=
  le_antisymmₓ (normal_closure_le_normal closure_le_normal_closure) (normal_closure_mono subset_closure)

/-- The normal core of a subgroup `H` is the largest normal subgroup of `G` contained in `H`,
as shown by `subgroup.normal_core_eq_supr`. -/
def normalCore (H : Subgroup G) : Subgroup G where
  Carrier := { a : G | ∀ b : G, b * a * b⁻¹ ∈ H }
  one_mem' := fun a => by
    rw [mul_oneₓ, mul_inv_selfₓ] <;> exact H.one_mem
  inv_mem' := fun a h b => (congr_arg (· ∈ H) conj_inv).mp (H.inv_mem (h b))
  mul_mem' := fun a b ha hb c => (congr_arg (· ∈ H) conj_mul).mp (H.mul_mem (ha c) (hb c))

theorem normal_core_le (H : Subgroup G) : H.normalCore ≤ H := fun a h => by
  rw [← mul_oneₓ a, ← inv_one, ← one_mulₓ a]
  exact h 1

instance normal_core_normal (H : Subgroup G) : H.normalCore.Normal :=
  ⟨fun a h b c => by
    rw [mul_assoc, mul_assoc, ← mul_inv_rev, ← mul_assoc, ← mul_assoc] <;> exact h (c * b)⟩

theorem normal_le_normal_core {H : Subgroup G} {N : Subgroup G} [hN : N.Normal] : N ≤ H.normalCore ↔ N ≤ H :=
  ⟨ge_transₓ H.normal_core_le, fun h_le n hn g => h_le (hN.conj_mem n hn g)⟩

theorem normal_core_mono {H K : Subgroup G} (h : H ≤ K) : H.normalCore ≤ K.normalCore :=
  normal_le_normal_core.mpr (H.normal_core_le.trans h)

theorem normal_core_eq_supr (H : Subgroup G) : H.normalCore = ⨆ (N : Subgroup G) (_ : Normal N) (hs : N ≤ H), N :=
  le_antisymmₓ
    (le_supr_of_le H.normalCore (le_supr_of_le H.normal_core_normal (le_supr_of_le H.normal_core_le le_rflₓ)))
    (supr_le fun N => supr_le fun hN => supr_le normal_le_normal_core.mpr)

@[simp]
theorem normal_core_eq_self (H : Subgroup G) [H.Normal] : H.normalCore = H :=
  le_antisymmₓ H.normal_core_le (normal_le_normal_core.mpr le_rflₓ)

@[simp]
theorem normal_core_idempotent (H : Subgroup G) : H.normalCore.normalCore = H.normalCore :=
  H.normalCore.normal_core_eq_self

end Subgroup

namespace MonoidHom

variable {N : Type _} {P : Type _} [Groupₓ N] [Groupₓ P] (K : Subgroup G)

open Subgroup

/-- The range of a monoid homomorphism from a group is a subgroup. -/
@[to_additive "The range of an `add_monoid_hom` from an `add_group` is an `add_subgroup`."]
def range (f : G →* N) : Subgroup N :=
  Subgroup.copy ((⊤ : Subgroup G).map f) (Set.Range f)
    (by
      simp [Set.ext_iff])

@[to_additive]
instance decidableMemRange (f : G →* N) [Fintype G] [DecidableEq N] : DecidablePred (· ∈ f.range) := fun x =>
  Fintype.decidableExistsFintype

@[simp, to_additive]
theorem coe_range (f : G →* N) : (f.range : Set N) = Set.Range f :=
  rfl

@[simp, to_additive]
theorem mem_range {f : G →* N} {y : N} : y ∈ f.range ↔ ∃ x, f x = y :=
  Iff.rfl

@[to_additive]
theorem range_eq_map (f : G →* N) : f.range = (⊤ : Subgroup G).map f := by
  ext <;> simp

/-- The canonical surjective group homomorphism `G →* f(G)` induced by a group
homomorphism `G →* N`. -/
@[to_additive
      "The canonical surjective `add_group` homomorphism `G →+ f(G)` induced by a group\nhomomorphism `G →+ N`."]
def rangeRestrict (f : G →* N) : G →* f.range :=
  (codRestrict f _) fun x => ⟨x, rfl⟩

@[simp, to_additive]
theorem coe_range_restrict (f : G →* N) (g : G) : (f.range_restrict g : N) = f g :=
  rfl

@[to_additive]
theorem range_restrict_surjective (f : G →* N) : Function.Surjective f.range_restrict := fun ⟨_, g, rfl⟩ => ⟨g, rfl⟩

@[to_additive]
theorem map_range (g : N →* P) (f : G →* N) : f.range.map g = (g.comp f).range := by
  rw [range_eq_map, range_eq_map] <;> exact (⊤ : Subgroup G).map_map g f

@[to_additive]
theorem range_top_iff_surjective {N} [Groupₓ N] {f : G →* N} : f.range = (⊤ : Subgroup N) ↔ Function.Surjective f :=
  SetLike.ext'_iff.trans <|
    Iff.trans
      (by
        rw [coe_range, coe_top])
      Set.range_iff_surjective

/-- The range of a surjective monoid homomorphism is the whole of the codomain. -/
@[to_additive "The range of a surjective `add_monoid` homomorphism is the whole of the codomain."]
theorem range_top_of_surjective {N} [Groupₓ N] (f : G →* N) (hf : Function.Surjective f) : f.range = (⊤ : Subgroup N) :=
  range_top_iff_surjective.2 hf

@[simp, to_additive]
theorem range_one : (1 : G →* N).range = ⊥ :=
  SetLike.ext fun x => by
    simpa using @comm _ (· = ·) _ 1 x

@[simp, to_additive]
theorem _root_.subgroup.subtype_range (H : Subgroup G) : H.Subtype.range = H := by
  rw [range_eq_map, ← SetLike.coe_set_eq, coe_map, Subgroup.coe_subtype]
  ext
  simp

@[simp, to_additive]
theorem _root_.subgroup.inclusion_range {H K : Subgroup G} (h_le : H ≤ K) : (inclusion h_le).range = H.subgroupOf K :=
  Subgroup.ext fun g => Set.ext_iff.mp (Set.range_inclusion h_le) g

@[to_additive]
theorem subgroup_of_range_eq_of_le {G₁ G₂ : Type _} [Groupₓ G₁] [Groupₓ G₂] {K : Subgroup G₂} (f : G₁ →* G₂)
    (h : f.range ≤ K) : f.range.subgroupOf K = (f.codRestrict K fun x => h ⟨x, rfl⟩).range := by
  ext k
  refine' exists_congr _
  simp [Subtype.ext_iff]

/-- Computable alternative to `monoid_hom.of_injective`. -/
@[to_additive "Computable alternative to `add_monoid_hom.of_injective`."]
def ofLeftInverse {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f) : G ≃* f.range :=
  { f.range_restrict with toFun := f.range_restrict, invFun := g ∘ f.range.Subtype, left_inv := h,
    right_inv := by
      rintro ⟨x, y, rfl⟩
      apply Subtype.ext
      rw [coe_range_restrict, Function.comp_applyₓ, Subgroup.coe_subtype, Subtype.coe_mk, h] }

@[simp, to_additive]
theorem of_left_inverse_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f) (x : G) :
    ↑(ofLeftInverse h x) = f x :=
  rfl

@[simp, to_additive]
theorem of_left_inverse_symm_apply {f : G →* N} {g : N →* G} (h : Function.LeftInverse g f) (x : f.range) :
    (ofLeftInverse h).symm x = g x :=
  rfl

/-- The range of an injective group homomorphism is isomorphic to its domain. -/
@[to_additive "The range of an injective additive group homomorphism is isomorphic to its\ndomain."]
noncomputable def ofInjective {f : G →* N} (hf : Function.Injective f) : G ≃* f.range :=
  MulEquiv.ofBijective (f.codRestrict f.range fun x => ⟨x, rfl⟩)
    ⟨fun x y h => hf (Subtype.ext_iff.mp h), by
      rintro ⟨x, y, rfl⟩
      exact ⟨y, rfl⟩⟩

@[to_additive]
theorem of_injective_apply {f : G →* N} (hf : Function.Injective f) {x : G} : ↑(ofInjective hf x) = f x :=
  rfl

section Ker

variable {M : Type _} [MulOneClassₓ M]

/-- The multiplicative kernel of a monoid homomorphism is the subgroup of elements `x : G` such that
`f x = 1` -/
@[to_additive
      "The additive kernel of an `add_monoid` homomorphism is the `add_subgroup` of elements\nsuch that `f x = 0`"]
def ker (f : G →* M) : Subgroup G :=
  { f.mker with
    inv_mem' := fun x (hx : f x = 1) =>
      calc
        f x⁻¹ = f x * f x⁻¹ := by
          rw [hx, one_mulₓ]
        _ = f (x * x⁻¹) := by
          rw [f.map_mul]
        _ = f 1 := by
          rw [mul_right_invₓ]
        _ = 1 := f.map_one
         }

@[to_additive]
theorem mem_ker (f : G →* M) {x : G} : x ∈ f.ker ↔ f x = 1 :=
  Iff.rfl

@[to_additive]
theorem coe_ker (f : G →* M) : (f.ker : Set G) = (f : G → M) ⁻¹' {1} :=
  rfl

@[to_additive]
theorem eq_iff (f : G →* N) {x y : G} : f x = f y ↔ y⁻¹ * x ∈ f.ker := by
  rw [f.mem_ker, f.map_mul, f.map_inv, inv_mul_eq_one, eq_comm]

@[to_additive]
instance decidableMemKer [DecidableEq M] (f : G →* M) : DecidablePred (· ∈ f.ker) := fun x =>
  decidableOfIff (f x = 1) f.mem_ker

@[to_additive]
theorem comap_ker (g : N →* P) (f : G →* N) : g.ker.comap f = (g.comp f).ker :=
  rfl

@[simp, to_additive]
theorem comap_bot (f : G →* N) : (⊥ : Subgroup N).comap f = f.ker :=
  rfl

@[to_additive]
theorem range_restrict_ker (f : G →* N) : ker (rangeRestrict f) = ker f := by
  ext
  change (⟨f x, _⟩ : range f) = ⟨1, _⟩ ↔ f x = 1
  simp only

@[simp, to_additive]
theorem ker_one : (1 : G →* M).ker = ⊤ := by
  ext
  simp [mem_ker]

@[to_additive]
theorem ker_eq_bot_iff (f : G →* N) : f.ker = ⊥ ↔ Function.Injective f := by
  constructor
  · intro h x y hxy
    rwa [← mul_inv_eq_one, ← map_inv, ← map_mul, ← mem_ker, h, mem_bot, mul_inv_eq_one] at hxy
    
  · exact fun h => le_bot_iff.mp fun x hx => h (hx.trans f.map_one.symm)
    

@[simp, to_additive]
theorem _root_.subgroup.ker_subtype (H : Subgroup G) : H.Subtype.ker = ⊥ :=
  H.Subtype.ker_eq_bot_iff.mpr Subtype.coe_injective

@[simp, to_additive]
theorem _root_.subgroup.ker_inclusion {H K : Subgroup G} (h : H ≤ K) : (inclusion h).ker = ⊥ :=
  (inclusion h).ker_eq_bot_iff.mpr (Set.inclusion_injective h)

@[to_additive]
theorem prod_map_comap_prod {G' : Type _} {N' : Type _} [Groupₓ G'] [Groupₓ N'] (f : G →* N) (g : G' →* N')
    (S : Subgroup N) (S' : Subgroup N') : (S.Prod S').comap (prodMap f g) = (S.comap f).Prod (S'.comap g) :=
  SetLike.coe_injective <| Set.preimage_prod_map_prod f g _ _

@[to_additive]
theorem ker_prod_map {G' : Type _} {N' : Type _} [Groupₓ G'] [Groupₓ N'] (f : G →* N) (g : G' →* N') :
    (prodMap f g).ker = f.ker.Prod g.ker := by
  rw [← comap_bot, ← comap_bot, ← comap_bot, ← prod_map_comap_prod, bot_prod_bot]

end Ker

/-- The subgroup of elements `x : G` such that `f x = g x` -/
@[to_additive "The additive subgroup of elements `x : G` such that `f x = g x`"]
def eqLocus (f g : G →* N) : Subgroup G :=
  { eqMlocus f g with
    inv_mem' := fun x (hx : f x = g x) =>
      show f x⁻¹ = g x⁻¹ by
        rw [f.map_inv, g.map_inv, hx] }

/-- If two monoid homomorphisms are equal on a set, then they are equal on its subgroup closure. -/
@[to_additive "If two monoid homomorphisms are equal on a set, then they are equal on its subgroup\nclosure."]
theorem eq_on_closure {f g : G →* N} {s : Set G} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=
  show closure s ≤ f.eqLocus g from (closure_le _).2 h

@[to_additive]
theorem eq_of_eq_on_top {f g : G →* N} (h : Set.EqOn f g (⊤ : Subgroup G)) : f = g :=
  ext fun x => h trivialₓ

@[to_additive]
theorem eq_of_eq_on_dense {s : Set G} (hs : closure s = ⊤) {f g : G →* N} (h : s.EqOn f g) : f = g :=
  eq_of_eq_on_top <| hs ▸ eq_on_closure h

@[to_additive]
theorem gclosure_preimage_le (f : G →* N) (s : Set N) : closure (f ⁻¹' s) ≤ (closure s).comap f :=
  (closure_le _).2 fun x hx => by
    rw [SetLike.mem_coe, mem_comap] <;> exact subset_closure hx

/-- The image under a monoid homomorphism of the subgroup generated by a set equals the subgroup
generated by the image of the set. -/
@[to_additive
      "The image under an `add_monoid` hom of the `add_subgroup` generated by a set equals\nthe `add_subgroup` generated by the image of the set."]
theorem map_closure (f : G →* N) (s : Set G) : (closure s).map f = closure (f '' s) :=
  Set.image_preimage.l_comm_of_u_comm (Subgroup.gc_map_comap f) (Subgroup.gi N).gc (Subgroup.gi G).gc fun t => rfl

-- this instance can't go just after the definition of `mrange` because `fintype` is
-- not imported at that stage
/-- The range of a finite monoid under a monoid homomorphism is finite.
Note: this instance can form a diamond with `subtype.fintype` in the
presence of `fintype N`. -/
@[to_additive
      "The range of a finite additive monoid under an additive monoid homomorphism is\nfinite.\n\nNote: this instance can form a diamond with `subtype.fintype` or `subgroup.fintype` in the\npresence of `fintype N`."]
instance fintypeMrange {M N : Type _} [Monoidₓ M] [Monoidₓ N] [Fintype M] [DecidableEq N] (f : M →* N) :
    Fintype (mrange f) :=
  Set.fintypeRange f

/-- The range of a finite group under a group homomorphism is finite.

Note: this instance can form a diamond with `subtype.fintype` or `subgroup.fintype` in the
presence of `fintype N`. -/
@[to_additive
      "The range of a finite additive group under an additive group homomorphism is finite.\n\nNote: this instance can form a diamond with `subtype.fintype` or `subgroup.fintype` in the\npresence of `fintype N`."]
instance fintypeRange [Fintype G] [DecidableEq N] (f : G →* N) : Fintype (range f) :=
  Set.fintypeRange f

end MonoidHom

namespace Subgroup

variable {N : Type _} [Groupₓ N] (H : Subgroup G)

@[to_additive]
theorem map_eq_bot_iff {f : G →* N} : H.map f = ⊥ ↔ H ≤ f.ker := by
  rw [eq_bot_iff]
  constructor
  · exact fun h x hx => h ⟨x, hx, rfl⟩
    
  · intro h x hx
    obtain ⟨y, hy, rfl⟩ := hx
    exact h hy
    

@[to_additive]
theorem map_eq_bot_iff_of_injective {f : G →* N} (hf : Function.Injective f) : H.map f = ⊥ ↔ H = ⊥ := by
  rw [map_eq_bot_iff, f.ker_eq_bot_iff.mpr hf, le_bot_iff]

end Subgroup

namespace Subgroup

open MonoidHom

variable {N : Type _} [Groupₓ N] (f : G →* N)

@[to_additive]
theorem map_le_range (H : Subgroup G) : map f H ≤ f.range :=
  (range_eq_map f).symm ▸ map_mono le_top

@[to_additive]
theorem map_subtype_le {H : Subgroup G} (K : Subgroup H) : K.map H.Subtype ≤ H :=
  (K.map_le_range H.Subtype).trans (le_of_eqₓ H.subtype_range)

@[to_additive]
theorem ker_le_comap (H : Subgroup N) : f.ker ≤ comap f H :=
  comap_bot f ▸ comap_mono bot_le

@[to_additive]
theorem map_comap_le (H : Subgroup N) : map f (comap f H) ≤ H :=
  (gc_map_comap f).l_u_le _

@[to_additive]
theorem le_comap_map (H : Subgroup G) : H ≤ comap f (map f H) :=
  (gc_map_comap f).le_u_l _

@[to_additive]
theorem map_comap_eq (H : Subgroup N) : map f (comap f H) = f.range⊓H :=
  SetLike.ext'
    (by
      convert Set.image_preimage_eq_inter_range
      simp [Set.inter_comm])

@[to_additive]
theorem comap_map_eq (H : Subgroup G) : comap f (map f H) = H⊔f.ker := by
  refine' le_antisymmₓ _ (sup_le (le_comap_map _ _) (ker_le_comap _ _))
  intro x hx
  simp only [exists_prop, mem_map, mem_comap] at hx
  rcases hx with ⟨y, hy, hy'⟩
  rw [← mul_inv_cancel_left y x]
  exact
    mul_mem_sup hy
      (by
        simp [mem_ker, hy'])

@[to_additive]
theorem map_comap_eq_self {f : G →* N} {H : Subgroup N} (h : H ≤ f.range) : map f (comap f H) = H := by
  rwa [map_comap_eq, inf_eq_right]

@[to_additive]
theorem map_comap_eq_self_of_surjective {f : G →* N} (h : Function.Surjective f) (H : Subgroup N) :
    map f (comap f H) = H :=
  map_comap_eq_self ((range_top_of_surjective _ h).symm ▸ le_top)

@[to_additive]
theorem comap_le_comap_of_le_range {f : G →* N} {K L : Subgroup N} (hf : K ≤ f.range) : K.comap f ≤ L.comap f ↔ K ≤ L :=
  ⟨(map_comap_eq_self hf).Ge.trans ∘ map_le_iff_le_comap.mpr, comap_mono⟩

@[to_additive]
theorem comap_le_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :
    K.comap f ≤ L.comap f ↔ K ≤ L :=
  comap_le_comap_of_le_range (le_top.trans (f.range_top_of_surjective hf).Ge)

@[to_additive]
theorem comap_lt_comap_of_surjective {f : G →* N} {K L : Subgroup N} (hf : Function.Surjective f) :
    K.comap f < L.comap f ↔ K < L := by
  simp_rw [lt_iff_le_not_leₓ, comap_le_comap_of_surjective hf]

@[to_additive]
theorem comap_injective {f : G →* N} (h : Function.Surjective f) : Function.Injective (comap f) := fun K L => by
  simp only [le_antisymm_iffₓ, comap_le_comap_of_surjective h, imp_self]

@[to_additive]
theorem comap_map_eq_self {f : G →* N} {H : Subgroup G} (h : f.ker ≤ H) : comap f (map f H) = H := by
  rwa [comap_map_eq, sup_eq_left]

@[to_additive]
theorem comap_map_eq_self_of_injective {f : G →* N} (h : Function.Injective f) (H : Subgroup G) :
    comap f (map f H) = H :=
  comap_map_eq_self (((ker_eq_bot_iff _).mpr h).symm ▸ bot_le)

@[to_additive]
theorem map_le_map_iff_of_injective {f : G →* N} (hf : Function.Injective f) {H K : Subgroup G} :
    H.map f ≤ K.map f ↔ H ≤ K :=
  ⟨(congr_arg2ₓ (· ≤ ·) (H.comap_map_eq_self_of_injective hf) (K.comap_map_eq_self_of_injective hf)).mp ∘ comap_mono,
    map_mono⟩

@[simp, to_additive]
theorem map_subtype_le_map_subtype {G' : Subgroup G} {H K : Subgroup G'} :
    H.map G'.Subtype ≤ K.map G'.Subtype ↔ H ≤ K :=
  map_le_map_iff_of_injective Subtype.coe_injective

@[to_additive]
theorem map_injective {f : G →* N} (h : Function.Injective f) : Function.Injective (map f) := fun K L hKL => by
  apply_fun comap f  at hKL
  simpa [comap_map_eq_self_of_injective h] using hKL

@[to_additive]
theorem map_eq_comap_of_inverse {f : G →* N} {g : N →* G} (hl : Function.LeftInverse g f)
    (hr : Function.RightInverse g f) (H : Subgroup G) : map f H = comap g H :=
  SetLike.ext' <| by
    rw [coe_map, coe_comap, Set.image_eq_preimage_of_inverse hl hr]

/-- Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`. -/
@[to_additive "Given `f(A) = f(B)`, `ker f ≤ A`, and `ker f ≤ B`, deduce that `A = B`."]
theorem map_injective_of_ker_le {H K : Subgroup G} (hH : f.ker ≤ H) (hK : f.ker ≤ K) (hf : map f H = map f K) : H = K :=
  by
  apply_fun comap f  at hf
  rwa [comap_map_eq, comap_map_eq, sup_of_le_left hH, sup_of_le_left hK] at hf

@[to_additive]
theorem comap_sup_eq_of_le_range {H K : Subgroup N} (hH : H ≤ f.range) (hK : K ≤ f.range) :
    comap f H⊔comap f K = comap f (H⊔K) :=
  map_injective_of_ker_le f ((ker_le_comap f H).trans le_sup_left) (ker_le_comap f (H⊔K))
    (by
      rw [map_comap_eq, map_sup, map_comap_eq, map_comap_eq, inf_eq_right.mpr hH, inf_eq_right.mpr hK,
        inf_eq_right.mpr (sup_le hH hK)])

@[to_additive]
theorem comap_sup_eq (H K : Subgroup N) (hf : Function.Surjective f) : comap f H⊔comap f K = comap f (H⊔K) :=
  comap_sup_eq_of_le_range f (le_top.trans (ge_of_eqₓ (f.range_top_of_surjective hf)))
    (le_top.trans (ge_of_eqₓ (f.range_top_of_surjective hf)))

@[to_additive]
theorem sup_subgroup_of_eq {H K L : Subgroup G} (hH : H ≤ L) (hK : K ≤ L) :
    H.subgroupOf L⊔K.subgroupOf L = (H⊔K).subgroupOf L :=
  comap_sup_eq_of_le_range L.Subtype (hH.trans (ge_of_eqₓ L.subtype_range)) (hK.trans (ge_of_eqₓ L.subtype_range))

/-- A subgroup is isomorphic to its image under an injective function -/
@[to_additive "An additive subgroup is isomorphic to its image under an injective function"]
noncomputable def equivMapOfInjective (H : Subgroup G) (f : G →* N) (hf : Function.Injective f) : H ≃* H.map f :=
  { Equivₓ.Set.image f H hf with map_mul' := fun _ _ => Subtype.ext (f.map_mul _ _) }

@[simp, to_additive]
theorem coe_equiv_map_of_injective_apply (H : Subgroup G) (f : G →* N) (hf : Function.Injective f) (h : H) :
    (equivMapOfInjective H f hf h : N) = f h :=
  rfl

/-- The preimage of the normalizer is equal to the normalizer of the preimage of a surjective
  function. -/
@[to_additive "The preimage of the normalizer is equal to the normalizer of the preimage of\na surjective function."]
theorem comap_normalizer_eq_of_surjective (H : Subgroup G) {f : N →* G} (hf : Function.Surjective f) :
    H.normalizer.comap f = (H.comap f).normalizer :=
  le_antisymmₓ (le_normalizer_comap f)
    (by
      intro x hx
      simp only [mem_comap, mem_normalizer_iff] at *
      intro n
      rcases hf n with ⟨y, rfl⟩
      simp [hx y])

@[to_additive]
theorem comap_normalizer_eq_of_injective_of_le_range {N : Type _} [Groupₓ N] (H : Subgroup G) {f : N →* G}
    (hf : Function.Injective f) (h : H.normalizer ≤ f.range) : comap f H.normalizer = (comap f H).normalizer := by
  apply Subgroup.map_injective hf
  rw [map_comap_eq_self h]
  apply le_antisymmₓ
  · refine' le_transₓ (le_of_eqₓ _) (map_mono (le_normalizer_comap _))
    rw [map_comap_eq_self h]
    
  · refine' le_transₓ (le_normalizer_map f) (le_of_eqₓ _)
    rw [map_comap_eq_self (le_transₓ le_normalizer h)]
    

@[to_additive]
theorem comap_subtype_normalizer_eq {H N : Subgroup G} (h : H.normalizer ≤ N) :
    comap N.Subtype H.normalizer = (comap N.Subtype H).normalizer := by
  apply comap_normalizer_eq_of_injective_of_le_range
  exact Subtype.coe_injective
  simpa

/-- The image of the normalizer is equal to the normalizer of the image of an isomorphism. -/
@[to_additive "The image of the normalizer is equal to the normalizer of the image of an\nisomorphism."]
theorem map_equiv_normalizer_eq (H : Subgroup G) (f : G ≃* N) :
    H.normalizer.map f.toMonoidHom = (H.map f.toMonoidHom).normalizer := by
  ext x
  simp only [mem_normalizer_iff, mem_map_equiv]
  rw [f.to_equiv.forall_congr]
  simp

/-- The image of the normalizer is equal to the normalizer of the image of a bijective
  function. -/
@[to_additive "The image of the normalizer is equal to the normalizer of the image of a bijective\n  function."]
theorem map_normalizer_eq_of_bijective (H : Subgroup G) {f : G →* N} (hf : Function.Bijective f) :
    H.normalizer.map f = (H.map f).normalizer :=
  map_equiv_normalizer_eq H (MulEquiv.ofBijective f hf)

end Subgroup

namespace MonoidHom

variable {G₁ G₂ G₃ : Type _} [Groupₓ G₁] [Groupₓ G₂] [Groupₓ G₃]

variable (f : G₁ →* G₂) (f_inv : G₂ → G₁)

/-- Auxiliary definition used to define `lift_of_right_inverse` -/
@[to_additive "Auxiliary definition used to define `lift_of_right_inverse`"]
def liftOfRightInverseAux (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃) (hg : f.ker ≤ g.ker) : G₂ →* G₃ where
  toFun := fun b => g (f_inv b)
  map_one' := hg (hf 1)
  map_mul' := by
    intro x y
    rw [← g.map_mul, ← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]
    apply hg
    rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one, f.map_mul]
    simp only [hf _]

@[simp, to_additive]
theorem lift_of_right_inverse_aux_comp_apply (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃) (hg : f.ker ≤ g.ker)
    (x : G₁) : (f.liftOfRightInverseAux f_inv hf g hg) (f x) = g x := by
  dsimp' [lift_of_right_inverse_aux]
  rw [← mul_inv_eq_one, ← g.map_inv, ← g.map_mul, ← g.mem_ker]
  apply hg
  rw [f.mem_ker, f.map_mul, f.map_inv, mul_inv_eq_one]
  simp only [hf _]

/-- `lift_of_right_inverse f hf g hg` is the unique group homomorphism `φ`

* such that `φ.comp f = g` (`monoid_hom.lift_of_right_inverse_comp`),
* where `f : G₁ →+* G₂` has a right_inverse `f_inv` (`hf`),
* and `g : G₂ →+* G₃` satisfies `hg : f.ker ≤ g.ker`.

See `monoid_hom.eq_lift_of_right_inverse` for the uniqueness lemma.

```
   G₁.
   |  \
 f |   \ g
   |    \
   v     \⌟
   G₂----> G₃
      ∃!φ
```
 -/
@[to_additive
      "`lift_of_right_inverse f f_inv hf g hg` is the unique additive group homomorphism `φ`\n\n* such that `φ.comp f = g` (`add_monoid_hom.lift_of_right_inverse_comp`),\n* where `f : G₁ →+ G₂` has a right_inverse `f_inv` (`hf`),\n* and `g : G₂ →+ G₃` satisfies `hg : f.ker ≤ g.ker`.\n\nSee `add_monoid_hom.eq_lift_of_right_inverse` for the uniqueness lemma.\n\n```\n   G₁.\n   |  \\\n f |   \\ g\n   |    \\\n   v     \\⌟\n   G₂----> G₃\n      ∃!φ\n```"]
def liftOfRightInverse (hf : Function.RightInverse f_inv f) : { g : G₁ →* G₃ // f.ker ≤ g.ker } ≃ (G₂ →* G₃) where
  toFun := fun g => f.liftOfRightInverseAux f_inv hf g.1 g.2
  invFun := fun φ =>
    ⟨φ.comp f, fun x hx =>
      (mem_ker _).mpr <| by
        simp [(mem_ker _).mp hx]⟩
  left_inv := fun g => by
    ext
    simp only [comp_apply, lift_of_right_inverse_aux_comp_apply, Subtype.coe_mk, Subtype.val_eq_coe]
  right_inv := fun φ => by
    ext b
    simp [lift_of_right_inverse_aux, hf b]

/-- A non-computable version of `monoid_hom.lift_of_right_inverse` for when no computable right
inverse is available, that uses `function.surj_inv`. -/
@[simp,
  to_additive
      "A non-computable version of `add_monoid_hom.lift_of_right_inverse` for when no\ncomputable right inverse is available."]
noncomputable abbrev liftOfSurjective (hf : Function.Surjective f) : { g : G₁ →* G₃ // f.ker ≤ g.ker } ≃ (G₂ →* G₃) :=
  f.liftOfRightInverse (Function.surjInv hf) (Function.right_inverse_surj_inv hf)

@[simp, to_additive]
theorem lift_of_right_inverse_comp_apply (hf : Function.RightInverse f_inv f) (g : { g : G₁ →* G₃ // f.ker ≤ g.ker })
    (x : G₁) : (f.liftOfRightInverse f_inv hf g) (f x) = g x :=
  f.lift_of_right_inverse_aux_comp_apply f_inv hf g.1 g.2 x

@[simp, to_additive]
theorem lift_of_right_inverse_comp (hf : Function.RightInverse f_inv f) (g : { g : G₁ →* G₃ // f.ker ≤ g.ker }) :
    (f.liftOfRightInverse f_inv hf g).comp f = g :=
  MonoidHom.ext <| f.lift_of_right_inverse_comp_apply f_inv hf g

@[to_additive]
theorem eq_lift_of_right_inverse (hf : Function.RightInverse f_inv f) (g : G₁ →* G₃) (hg : f.ker ≤ g.ker) (h : G₂ →* G₃)
    (hh : h.comp f = g) : h = f.liftOfRightInverse f_inv hf ⟨g, hg⟩ := by
  simp_rw [← hh]
  exact ((f.lift_of_right_inverse f_inv hf).apply_symm_apply _).symm

end MonoidHom

variable {N : Type _} [Groupₓ N]

-- Here `H.normal` is an explicit argument so we can use dot notation with `comap`.
@[to_additive]
theorem Subgroup.Normal.comap {H : Subgroup N} (hH : H.Normal) (f : G →* N) : (H.comap f).Normal :=
  ⟨fun _ => by
    simp (config := { contextual := true })[Subgroup.mem_comap, hH.conj_mem]⟩

@[to_additive]
instance (priority := 100) Subgroup.normal_comap {H : Subgroup N} [nH : H.Normal] (f : G →* N) : (H.comap f).Normal :=
  nH.comap _

@[to_additive]
instance (priority := 100) MonoidHom.normal_ker (f : G →* N) : f.ker.Normal := by
  rw [← f.comap_bot]
  infer_instance

@[to_additive]
instance (priority := 100) Subgroup.normal_inf (H N : Subgroup G) [hN : N.Normal] : ((H⊓N).comap H.Subtype).Normal :=
  ⟨fun x hx g => by
    simp only [Subgroup.mem_inf, coeSubtype, Subgroup.mem_comap] at hx
    simp only [Subgroup.coe_mul, Subgroup.mem_inf, coeSubtype, Subgroup.coe_inv, Subgroup.mem_comap]
    exact ⟨H.mul_mem (H.mul_mem g.2 hx.1) (H.inv_mem g.2), hN.1 x hx.2 g⟩⟩

namespace Subgroup

/-- The subgroup generated by an element. -/
def zpowers (g : G) : Subgroup G :=
  Subgroup.copy (zpowersHom G g).range (Set.Range ((· ^ ·) g : ℤ → G)) rfl

@[simp]
theorem mem_zpowers (g : G) : g ∈ zpowers g :=
  ⟨1, zpow_one _⟩

theorem zpowers_eq_closure (g : G) : zpowers g = closure {g} := by
  ext
  exact mem_closure_singleton.symm

@[simp]
theorem range_zpowers_hom (g : G) : (zpowersHom G g).range = zpowers g :=
  rfl

theorem zpowers_subset {a : G} {K : Subgroup G} (h : a ∈ K) : zpowers a ≤ K := fun x hx =>
  match x, hx with
  | _, ⟨i, rfl⟩ => K.zpow_mem h i

theorem mem_zpowers_iff {g h : G} : h ∈ zpowers g ↔ ∃ k : ℤ, g ^ k = h :=
  Iff.rfl

@[simp]
theorem forall_zpowers {x : G} {p : zpowers x → Prop} : (∀ g, p g) ↔ ∀ m : ℤ, p ⟨x ^ m, m, rfl⟩ :=
  Set.forall_subtype_range_iff

@[simp]
theorem exists_zpowers {x : G} {p : zpowers x → Prop} : (∃ g, p g) ↔ ∃ m : ℤ, p ⟨x ^ m, m, rfl⟩ :=
  Set.exists_subtype_range_iff

theorem forall_mem_zpowers {x : G} {p : G → Prop} : (∀ g ∈ zpowers x, p g) ↔ ∀ m : ℤ, p (x ^ m) :=
  Set.forall_range_iff

theorem exists_mem_zpowers {x : G} {p : G → Prop} : (∃ g ∈ zpowers x, p g) ↔ ∃ m : ℤ, p (x ^ m) :=
  Set.exists_range_iff

end Subgroup

namespace AddSubgroup

/-- The subgroup generated by an element. -/
def zmultiples (a : A) : AddSubgroup A :=
  AddSubgroup.copy (zmultiplesHom A a).range (Set.Range ((· • a) : ℤ → A)) rfl

@[simp]
theorem range_zmultiples_hom (a : A) : (zmultiplesHom A a).range = zmultiples a :=
  rfl

attribute [to_additive AddSubgroup.zmultiples] Subgroup.zpowers

attribute [to_additive AddSubgroup.mem_zmultiples] Subgroup.mem_zpowers

attribute [to_additive AddSubgroup.zmultiples_eq_closure] Subgroup.zpowers_eq_closure

attribute [to_additive AddSubgroup.range_zmultiples_hom] Subgroup.range_zpowers_hom

attribute [to_additive AddSubgroup.zmultiples_subset] Subgroup.zpowers_subset

attribute [to_additive AddSubgroup.mem_zmultiples_iff] Subgroup.mem_zpowers_iff

attribute [to_additive AddSubgroup.forall_zmultiples] Subgroup.forall_zpowers

attribute [to_additive AddSubgroup.forall_mem_zmultiples] Subgroup.forall_mem_zpowers

attribute [to_additive AddSubgroup.exists_zmultiples] Subgroup.exists_zpowers

attribute [to_additive AddSubgroup.exists_mem_zmultiples] Subgroup.exists_mem_zpowers

end AddSubgroup

theorem Int.mem_zmultiples_iff {a b : ℤ} : b ∈ AddSubgroup.zmultiples a ↔ a ∣ b :=
  exists_congr fun k => by
    rw [mul_comm, eq_comm, ← smul_eq_mul]

theorem of_mul_image_zpowers_eq_zmultiples_of_mul {x : G} :
    Additive.ofMul '' (Subgroup.zpowers x : Set G) = AddSubgroup.zmultiples (Additive.ofMul x) := by
  ext y
  constructor
  · rintro ⟨z, ⟨m, hm⟩, hz2⟩
    use m
    simp only
    rwa [← of_mul_zpow, hm]
    
  · rintro ⟨n, hn⟩
    refine' ⟨x ^ n, ⟨n, rfl⟩, _⟩
    rwa [of_mul_zpow]
    

theorem of_add_image_zmultiples_eq_zpowers_of_add {x : A} :
    Multiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) = Subgroup.zpowers (Multiplicative.ofAdd x) := by
  symm
  rw [Equivₓ.eq_image_iff_symm_image_eq]
  exact of_mul_image_zpowers_eq_zmultiples_of_mul

namespace Subgroup

@[to_additive zmultiples_is_commutative]
instance zpowers_is_commutative (g : G) : (zpowers g).IsCommutative :=
  ⟨⟨fun ⟨_, _, h₁⟩ ⟨_, _, h₂⟩ => by
      rw [Subtype.ext_iff, coe_mul, coe_mul, Subtype.coe_mk, Subtype.coe_mk, ← h₁, ← h₂, zpow_mul_comm]⟩⟩

@[simp, to_additive zmultiples_le]
theorem zpowers_le {g : G} {H : Subgroup G} : zpowers g ≤ H ↔ g ∈ H := by
  rw [zpowers_eq_closure, closure_le, Set.singleton_subset_iff, SetLike.mem_coe]

@[simp, to_additive zmultiples_eq_bot]
theorem zpowers_eq_bot {g : G} : zpowers g = ⊥ ↔ g = 1 := by
  rw [eq_bot_iff, zpowers_le, mem_bot]

@[simp, to_additive zmultiples_zero_eq_bot]
theorem zpowers_one_eq_bot : Subgroup.zpowers (1 : G) = ⊥ :=
  Subgroup.zpowers_eq_bot.mpr rfl

end Subgroup

namespace MonoidHom

variable {G' : Type _} [Groupₓ G']

/-- The `monoid_hom` from the preimage of a subgroup to itself. -/
@[to_additive "the `add_monoid_hom` from the preimage of an additive subgroup to itself.", simps]
def subgroupComap (f : G →* G') (H' : Subgroup G') : H'.comap f →* H' :=
  f.submonoidComap H'.toSubmonoid

/-- The `monoid_hom` from a subgroup to its image. -/
@[to_additive "the `add_monoid_hom` from an additive subgroup to its image", simps]
def subgroupMap (f : G →* G') (H : Subgroup G) : H →* H.map f :=
  f.submonoidMap H.toSubmonoid

@[to_additive]
theorem subgroup_map_surjective (f : G →* G') (H : Subgroup G) : Function.Surjective (f.subgroupMap H) :=
  f.submonoid_map_surjective H.toSubmonoid

end MonoidHom

namespace MulEquiv

variable {H K : Subgroup G}

/-- Makes the identity isomorphism from a proof two subgroups of a multiplicative
    group are equal. -/
@[to_additive "Makes the identity additive isomorphism from a proof\ntwo subgroups of an additive group are equal."]
def subgroupCongr (h : H = K) : H ≃* K :=
  { Equivₓ.setCongr <| congr_arg _ h with map_mul' := fun _ _ => rfl }

/-- A `mul_equiv` `φ` between two groups `G` and `G'` induces a `mul_equiv` between
a subgroup `H ≤ G` and the subgroup `φ(H) ≤ G'`. -/
@[to_additive
      "An `add_equiv` `φ` between two additive groups `G` and `G'` induces an `add_equiv`\nbetween a subgroup `H ≤ G` and the subgroup `φ(H) ≤ G'`. "]
def subgroupMap {G'} [Groupₓ G'] (e : G ≃* G') (H : Subgroup G) : H ≃* H.map e.toMonoidHom :=
  e.submonoidMap H.toSubmonoid

end MulEquiv

-- TODO : ↥(⊤ : subgroup H) ≃* H ?
namespace Subgroup

variable {C : Type _} [CommGroupₓ C] {s t : Subgroup C} {x : C}

@[to_additive]
theorem mem_sup : x ∈ s⊔t ↔ ∃ y ∈ s, ∃ z ∈ t, y * z = x :=
  ⟨fun h => by
    rw [← closure_eq s, ← closure_eq t, ← closure_union] at h
    apply closure_induction h
    · rintro y (h | h)
      · exact
          ⟨y, h, 1, t.one_mem, by
            simp ⟩
        
      · exact
          ⟨1, s.one_mem, y, h, by
            simp ⟩
        
      
    · exact ⟨1, s.one_mem, 1, ⟨t.one_mem, mul_oneₓ 1⟩⟩
      
    · rintro _ _ ⟨y₁, hy₁, z₁, hz₁, rfl⟩ ⟨y₂, hy₂, z₂, hz₂, rfl⟩
      exact
        ⟨_, mul_mem hy₁ hy₂, _, mul_mem hz₁ hz₂, by
          simp [mul_assoc] <;> cc⟩
      
    · rintro _ ⟨y, hy, z, hz, rfl⟩
      exact ⟨_, inv_mem hy, _, inv_mem hz, mul_comm z y ▸ (mul_inv_rev z y).symm⟩
      ,
    by
    rintro ⟨y, hy, z, hz, rfl⟩ <;> exact mul_mem_sup hy hz⟩

@[to_additive]
theorem mem_sup' : x ∈ s⊔t ↔ ∃ (y : s)(z : t), (y : C) * z = x :=
  mem_sup.trans <| by
    simp only [SetLike.exists, coe_mk]

@[to_additive]
theorem mem_closure_pair {x y z : C} : z ∈ closure ({x, y} : Set C) ↔ ∃ m n : ℤ, x ^ m * y ^ n = z := by
  rw [← Set.singleton_union, Subgroup.closure_union, mem_sup]
  simp_rw [exists_prop, mem_closure_singleton, exists_exists_eq_and]

@[to_additive]
instance : IsModularLattice (Subgroup C) :=
  ⟨fun x y z xz a ha => by
    rw [mem_inf, mem_sup] at ha
    rcases ha with ⟨⟨b, hb, c, hc, rfl⟩, haz⟩
    rw [mem_sup]
    refine' ⟨b, hb, c, mem_inf.2 ⟨hc, _⟩, rfl⟩
    rw [← inv_mul_cancel_leftₓ b c]
    apply z.mul_mem (z.inv_mem (xz hb)) haz⟩

end Subgroup

section

variable (G) (A)

/-- A `group` is simple when it has exactly two normal `subgroup`s. -/
class IsSimpleGroup extends Nontrivial G : Prop where
  eq_bot_or_eq_top_of_normal : ∀ H : Subgroup G, H.Normal → H = ⊥ ∨ H = ⊤

/-- An `add_group` is simple when it has exactly two normal `add_subgroup`s. -/
class IsSimpleAddGroup extends Nontrivial A : Prop where
  eq_bot_or_eq_top_of_normal : ∀ H : AddSubgroup A, H.Normal → H = ⊥ ∨ H = ⊤

attribute [to_additive] IsSimpleGroup

variable {G} {A}

@[to_additive]
theorem Subgroup.Normal.eq_bot_or_eq_top [IsSimpleGroup G] {H : Subgroup G} (Hn : H.Normal) : H = ⊥ ∨ H = ⊤ :=
  IsSimpleGroup.eq_bot_or_eq_top_of_normal H Hn

namespace IsSimpleGroup

@[to_additive]
instance {C : Type _} [CommGroupₓ C] [IsSimpleGroup C] : IsSimpleOrder (Subgroup C) :=
  ⟨fun H => H.normal_of_comm.eq_bot_or_eq_top⟩

open _Root_.Subgroup

@[to_additive]
theorem is_simple_group_of_surjective {H : Type _} [Groupₓ H] [IsSimpleGroup G] [Nontrivial H] (f : G →* H)
    (hf : Function.Surjective f) : IsSimpleGroup H :=
  ⟨Nontrivial.exists_pair_ne, fun H iH => by
    refine' (iH.comap f).eq_bot_or_eq_top.imp (fun h => _) fun h => _
    · rw [← map_bot f, ← h, map_comap_eq_self_of_surjective hf]
      
    · rw [← comap_top f] at h
      exact comap_injective hf h
      ⟩

end IsSimpleGroup

end

namespace Subgroup

section Pointwise

@[to_additive]
theorem closure_mul_le (S T : Set G) : closure (S * T) ≤ closure S⊔closure T :=
  Inf_le fun x ⟨s, t, hs, ht, hx⟩ =>
    hx ▸
      (closure S⊔closure T).mul_mem (SetLike.le_def.mp le_sup_left <| subset_closure hs)
        (SetLike.le_def.mp le_sup_right <| subset_closure ht)

@[to_additive]
theorem sup_eq_closure (H K : Subgroup G) : H⊔K = closure (H * K) :=
  le_antisymmₓ
    (sup_le (fun h hh => subset_closure ⟨h, 1, hh, K.one_mem, mul_oneₓ h⟩) fun k hk =>
      subset_closure ⟨1, k, H.one_mem, hk, one_mulₓ k⟩)
    (by
      conv_rhs => rw [← closure_eq H, ← closure_eq K] <;> apply closure_mul_le)

@[to_additive]
private def mul_normal_aux (H N : Subgroup G) [hN : N.Normal] : Subgroup G where
  Carrier := (H : Set G) * N
  one_mem' :=
    ⟨1, 1, H.one_mem, N.one_mem, by
      rw [mul_oneₓ]⟩
  mul_mem' := fun a b ⟨h, n, hh, hn, ha⟩ ⟨h', n', hh', hn', hb⟩ =>
    ⟨h * h', h'⁻¹ * n * h' * n', H.mul_mem hh hh',
      N.mul_mem
        (by
          simpa using hN.conj_mem _ hn h'⁻¹)
        hn',
      by
      simp [← ha, ← hb, mul_assoc]⟩
  inv_mem' := fun x ⟨h, n, hh, hn, hx⟩ =>
    ⟨h⁻¹, h * n⁻¹ * h⁻¹, H.inv_mem hh, hN.conj_mem _ (N.inv_mem hn) h, by
      rw [mul_assoc h, inv_mul_cancel_leftₓ, ← hx, mul_inv_rev]⟩

/-- The carrier of `H ⊔ N` is just `↑H * ↑N` (pointwise set product) when `N` is normal. -/
@[to_additive "The carrier of `H ⊔ N` is just `↑H + ↑N` (pointwise set addition)\nwhen `N` is normal."]
theorem mul_normal (H N : Subgroup G) [N.Normal] : (↑(H⊔N) : Set G) = H * N :=
  Set.Subset.antisymm
    (show H⊔N ≤ mulNormalAux H N by
      rw [sup_eq_closure]
      apply Inf_le _
      dsimp'
      rfl)
    ((sup_eq_closure H N).symm ▸ subset_closure)

@[to_additive]
private def normal_mul_aux (N H : Subgroup G) [hN : N.Normal] : Subgroup G where
  Carrier := (N : Set G) * H
  one_mem' :=
    ⟨1, 1, N.one_mem, H.one_mem, by
      rw [mul_oneₓ]⟩
  mul_mem' := fun a b ⟨n, h, hn, hh, ha⟩ ⟨n', h', hn', hh', hb⟩ =>
    ⟨n * (h * n' * h⁻¹), h * h', N.mul_mem hn (hN.conj_mem _ hn' _), H.mul_mem hh hh', by
      simp [← ha, ← hb, mul_assoc]⟩
  inv_mem' := fun x ⟨n, h, hn, hh, hx⟩ =>
    ⟨h⁻¹ * n⁻¹ * h, h⁻¹, by
      simpa using hN.conj_mem _ (N.inv_mem hn) h⁻¹, H.inv_mem hh, by
      rw [mul_inv_cancel_rightₓ, ← mul_inv_rev, hx]⟩

/-- The carrier of `N ⊔ H` is just `↑N * ↑H` (pointwise set product) when `N` is normal. -/
@[to_additive "The carrier of `N ⊔ H` is just `↑N + ↑H` (pointwise set addition)\nwhen `N` is normal."]
theorem normal_mul (N H : Subgroup G) [N.Normal] : (↑(N⊔H) : Set G) = N * H :=
  Set.Subset.antisymm
    (show N⊔H ≤ normalMulAux N H by
      rw [sup_eq_closure]
      apply Inf_le _
      dsimp'
      rfl)
    ((sup_eq_closure N H).symm ▸ subset_closure)

@[to_additive]
theorem mul_inf_assoc (A B C : Subgroup G) (h : A ≤ C) : (A : Set G) * ↑(B⊓C) = A * B⊓C := by
  ext
  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]
  constructor
  · rintro ⟨y, z, hy, ⟨hzB, hzC⟩, rfl⟩
    refine' ⟨_, mul_mem (h hy) hzC⟩
    exact ⟨y, z, hy, hzB, rfl⟩
    
  rintro ⟨⟨y, z, hy, hz, rfl⟩, hyz⟩
  refine' ⟨y, z, hy, ⟨hz, _⟩, rfl⟩
  suffices y⁻¹ * (y * z) ∈ C by
    simpa
  exact mul_mem (inv_mem (h hy)) hyz

@[to_additive]
theorem inf_mul_assoc (A B C : Subgroup G) (h : C ≤ A) : ((A⊓B : Subgroup G) : Set G) * C = A⊓B * C := by
  ext
  simp only [coe_inf, Set.inf_eq_inter, Set.mem_mul, Set.mem_inter_iff]
  constructor
  · rintro ⟨y, z, ⟨hyA, hyB⟩, hz, rfl⟩
    refine' ⟨A.mul_mem hyA (h hz), _⟩
    exact ⟨y, z, hyB, hz, rfl⟩
    
  rintro ⟨hyz, y, z, hy, hz, rfl⟩
  refine' ⟨y, z, ⟨_, hy⟩, hz, rfl⟩
  suffices y * z * z⁻¹ ∈ A by
    simpa
  exact mul_mem hyz (inv_mem (h hz))

end Pointwise

section SubgroupNormal

@[to_additive]
theorem normal_subgroup_of_iff {H K : Subgroup G} (hHK : H ≤ K) :
    (H.subgroupOf K).Normal ↔ ∀ h k, h ∈ H → k ∈ K → k * h * k⁻¹ ∈ H :=
  ⟨fun hN h k hH hK => hN.conj_mem ⟨h, hHK hH⟩ hH ⟨k, hK⟩, fun hN => { conj_mem := fun h hm k => hN h.1 k.1 hm k.2 }⟩

@[to_additive]
instance prod_subgroup_of_prod_normal {H₁ K₁ : Subgroup G} {H₂ K₂ : Subgroup N} [h₁ : (H₁.subgroupOf K₁).Normal]
    [h₂ : (H₂.subgroupOf K₂).Normal] :
    ((H₁.Prod H₂).subgroupOf
        (K₁.Prod
          K₂)).Normal where conj_mem := fun n hgHK g =>
    ⟨h₁.conj_mem ⟨(n : G × N).fst, (mem_prod.mp n.2).1⟩ hgHK.1 ⟨(g : G × N).fst, (mem_prod.mp g.2).1⟩,
      h₂.conj_mem ⟨(n : G × N).snd, (mem_prod.mp n.2).2⟩ hgHK.2 ⟨(g : G × N).snd, (mem_prod.mp g.2).2⟩⟩

@[to_additive]
instance prod_normal (H : Subgroup G) (K : Subgroup N) [hH : H.Normal] [hK : K.Normal] :
    (H.Prod
        K).Normal where conj_mem := fun n hg g =>
    ⟨hH.conj_mem n.fst (Subgroup.mem_prod.mp hg).1 g.fst, hK.conj_mem n.snd (Subgroup.mem_prod.mp hg).2 g.snd⟩

@[to_additive]
theorem inf_subgroup_of_inf_normal_of_right (A B' B : Subgroup G) (hB : B' ≤ B) [hN : (B'.subgroupOf B).Normal] :
    ((A⊓B').subgroupOf (A⊓B)).Normal :=
  { conj_mem := fun n hn g =>
      ⟨mul_mem (mul_mem (mem_inf.1 g.2).1 (mem_inf.1 n.2).1) (inv_mem (mem_inf.1 g.2).1),
        (normal_subgroup_of_iff hB).mp hN n g hn.2 (mem_inf.mp g.2).2⟩ }

@[to_additive]
theorem inf_subgroup_of_inf_normal_of_left {A' A : Subgroup G} (B : Subgroup G) (hA : A' ≤ A)
    [hN : (A'.subgroupOf A).Normal] : ((A'⊓B).subgroupOf (A⊓B)).Normal :=
  { conj_mem := fun n hn g =>
      ⟨(normal_subgroup_of_iff hA).mp hN n g hn.1 (mem_inf.mp g.2).1,
        mul_mem (mul_mem (mem_inf.1 g.2).2 (mem_inf.1 n.2).2) (inv_mem (mem_inf.1 g.2).2)⟩ }

instance sup_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] :
    (H⊔K).Normal where conj_mem := fun n hmem g => by
    change n ∈ ↑(H⊔K) at hmem
    change g * n * g⁻¹ ∈ ↑(H⊔K)
    rw [normal_mul, Set.mem_mul] at *
    rcases hmem with ⟨h, k, hh, hk, rfl⟩
    refine' ⟨g * h * g⁻¹, g * k * g⁻¹, hH.conj_mem h hh g, hK.conj_mem k hk g, _⟩
    simp

@[to_additive]
instance normal_inf_normal (H K : Subgroup G) [hH : H.Normal] [hK : K.Normal] :
    (H⊓K).Normal where conj_mem := fun n hmem g => by
    rw [mem_inf] at *
    exact ⟨hH.conj_mem n hmem.1 g, hK.conj_mem n hmem.2 g⟩

@[to_additive]
theorem subgroup_of_sup (A A' B : Subgroup G) (hA : A ≤ B) (hA' : A' ≤ B) :
    (A⊔A').subgroupOf B = A.subgroupOf B⊔A'.subgroupOf B := by
  refine' map_injective_of_ker_le B.subtype (ker_le_comap _ _) (le_transₓ (ker_le_comap B.subtype _) le_sup_left) _
  · simp only [subgroup_of, map_comap_eq, map_sup, subtype_range]
    rw [inf_of_le_right (sup_le hA hA'), inf_of_le_right hA', inf_of_le_right hA]
    

@[to_additive]
theorem SubgroupNormal.mem_comm {H K : Subgroup G} (hK : H ≤ K) [hN : (H.subgroupOf K).Normal] {a b : G} (hb : b ∈ K)
    (h : a * b ∈ H) : b * a ∈ H := by
  have := (normal_subgroup_of_iff hK).mp hN (a * b) b h hb
  rwa [mul_assoc, mul_assoc, mul_right_invₓ, mul_oneₓ] at this

/-- Elements of disjoint, normal subgroups commute. -/
@[to_additive "Elements of disjoint, normal subgroups commute."]
theorem commute_of_normal_of_disjoint (H₁ H₂ : Subgroup G) (hH₁ : H₁.Normal) (hH₂ : H₂.Normal) (hdis : Disjoint H₁ H₂)
    (x y : G) (hx : x ∈ H₁) (hy : y ∈ H₂) : Commute x y := by
  suffices x * y * x⁻¹ * y⁻¹ = 1 by
    show x * y = y * x
    · rw [mul_assoc, mul_eq_one_iff_eq_inv] at this
      simpa
      
  apply hdis
  constructor
  · suffices x * (y * x⁻¹ * y⁻¹) ∈ H₁ by
      simpa [mul_assoc]
    exact H₁.mul_mem hx (hH₁.conj_mem _ (H₁.inv_mem hx) _)
    
  · show x * y * x⁻¹ * y⁻¹ ∈ H₂
    apply H₂.mul_mem _ (H₂.inv_mem hy)
    apply hH₂.conj_mem _ hy
    

end SubgroupNormal

@[to_additive]
theorem disjoint_def {H₁ H₂ : Subgroup G} : Disjoint H₁ H₂ ↔ ∀ {x : G}, x ∈ H₁ → x ∈ H₂ → x = 1 :=
  show (∀ x, x ∈ H₁ ∧ x ∈ H₂ → x ∈ ({1} : Set G)) ↔ _ by
    simp

@[to_additive]
theorem disjoint_def' {H₁ H₂ : Subgroup G} : Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x = y → x = 1 :=
  disjoint_def.trans ⟨fun h x y hx hy hxy => h hx <| hxy.symm ▸ hy, fun h x hx hx' => h hx hx' rfl⟩

@[to_additive]
theorem disjoint_iff_mul_eq_one {H₁ H₂ : Subgroup G} :
    Disjoint H₁ H₂ ↔ ∀ {x y : G}, x ∈ H₁ → y ∈ H₂ → x * y = 1 → x = 1 ∧ y = 1 :=
  disjoint_def'.trans
    ⟨fun h x y hx hy hxy =>
      let hx1 : x = 1 := h hx (H₂.inv_mem hy) (eq_inv_iff_mul_eq_one.mpr hxy)
      ⟨hx1, by
        simpa [hx1] using hxy⟩,
      fun h x y hx hy hxy => (h hx (H₂.inv_mem hy) (mul_inv_eq_one.mpr hxy)).1⟩

/-- `finset.noncomm_prod` is “injective” in `f` if `f` maps into independent subgroups.  This
generalizes (one direction of) `subgroup.disjoint_iff_mul_eq_one`. -/
@[to_additive
      "`finset.noncomm_sum` is “injective” in `f` if `f` maps into independent subgroups.\nThis generalizes (one direction of) `add_subgroup.disjoint_iff_add_eq_zero`. "]
theorem eq_one_of_noncomm_prod_eq_one_of_independent {ι : Type _} (s : Finset ι) (f : ι → G)
    (comm : ∀ x ∈ s, ∀ y ∈ s, Commute (f x) (f y)) (K : ι → Subgroup G) (hind : CompleteLattice.Independent K)
    (hmem : ∀ x ∈ s, f x ∈ K x) (heq1 : s.noncommProd f comm = 1) : ∀ i ∈ s, f i = 1 := by
  classical
  revert heq1
  induction' s using Finset.induction_on with i s hnmem ih
  · simp
    
  · simp only [Finset.forall_mem_insert] at comm hmem
    specialize ih (fun x hx => (comm.2 x hx).2) hmem.2
    have hmem_bsupr : (s.noncomm_prod f fun x hx => (comm.2 x hx).2) ∈ ⨆ i ∈ (s : Set ι), K i := by
      refine' Subgroup.noncomm_prod_mem _ _ _
      intro x hx
      have : K x ≤ ⨆ i ∈ (s : Set ι), K i := le_supr₂ x hx
      exact this (hmem.2 x hx)
    intro heq1
    rw [Finset.noncomm_prod_insert_of_not_mem _ _ _ _ hnmem] at heq1
    have hnmem' : i ∉ (s : Set ι) := by
      simpa
    obtain ⟨heq1i : f i = 1, heq1S : s.noncomm_prod f _ = 1⟩ :=
      subgroup.disjoint_iff_mul_eq_one.mp (hind.disjoint_bsupr hnmem') hmem.1 hmem_bsupr heq1
    specialize ih heq1S
    intro i h
    simp only [Finset.mem_insert] at h
    rcases h with ⟨rfl | _⟩
    · exact heq1i
      
    · exact ih _ h
      
    

end Subgroup

namespace IsConj

open Subgroup

theorem normal_closure_eq_top_of {N : Subgroup G} [hn : N.Normal] {g g' : G} {hg : g ∈ N} {hg' : g' ∈ N}
    (hc : IsConj g g') (ht : normalClosure ({⟨g, hg⟩} : Set N) = ⊤) : normalClosure ({⟨g', hg'⟩} : Set N) = ⊤ := by
  obtain ⟨c, rfl⟩ := is_conj_iff.1 hc
  have h : ∀ x : N, (MulAut.conj c) x ∈ N := by
    rintro ⟨x, hx⟩
    exact hn.conj_mem _ hx c
  have hs : Function.Surjective (((MulAut.conj c).toMonoidHom.restrict N).codRestrict _ h) := by
    rintro ⟨x, hx⟩
    refine' ⟨⟨c⁻¹ * x * c, _⟩, _⟩
    · have h := hn.conj_mem _ hx c⁻¹
      rwa [inv_invₓ] at h
      
    simp only [MonoidHom.cod_restrict_apply, MulEquiv.coe_to_monoid_hom, MulAut.conj_apply, coe_mk,
      MonoidHom.restrict_apply, Subtype.mk_eq_mk, ← mul_assoc, mul_inv_selfₓ, one_mulₓ]
    rw [mul_assoc, mul_inv_selfₓ, mul_oneₓ]
  have ht' := map_mono (eq_top_iff.1 ht)
  rw [← MonoidHom.range_eq_map, MonoidHom.range_top_of_surjective _ hs] at ht'
  refine' eq_top_iff.2 (le_transₓ ht' (map_le_iff_le_comap.2 (normal_closure_le_normal _)))
  rw [Set.singleton_subset_iff, SetLike.mem_coe]
  simp only [MonoidHom.cod_restrict_apply, MulEquiv.coe_to_monoid_hom, MulAut.conj_apply, coe_mk,
    MonoidHom.restrict_apply, mem_comap]
  exact subset_normal_closure (Set.mem_singleton _)

end IsConj

/-! ### Actions by `subgroup`s

These are just copies of the definitions about `submonoid` starting from `submonoid.mul_action`.
-/


section Actions

namespace Subgroup

variable {α β : Type _}

/-- The action by a subgroup is the action by the underlying group. -/
@[to_additive "The additive action by an add_subgroup is the action by the underlying\nadd_group. "]
instance [MulAction G α] (S : Subgroup G) : MulAction S α :=
  S.toSubmonoid.MulAction

@[to_additive]
theorem smul_def [MulAction G α] {S : Subgroup G} (g : S) (m : α) : g • m = (g : G) • m :=
  rfl

@[to_additive]
instance smul_comm_class_left [MulAction G β] [HasSmul α β] [SmulCommClass G α β] (S : Subgroup G) :
    SmulCommClass S α β :=
  S.toSubmonoid.smul_comm_class_left

@[to_additive]
instance smul_comm_class_right [HasSmul α β] [MulAction G β] [SmulCommClass α G β] (S : Subgroup G) :
    SmulCommClass α S β :=
  S.toSubmonoid.smul_comm_class_right

/-- Note that this provides `is_scalar_tower S G G` which is needed by `smul_mul_assoc`. -/
instance [HasSmul α β] [MulAction G α] [MulAction G β] [IsScalarTower G α β] (S : Subgroup G) : IsScalarTower S α β :=
  S.toSubmonoid.IsScalarTower

instance [MulAction G α] [HasFaithfulSmul G α] (S : Subgroup G) : HasFaithfulSmul S α :=
  S.toSubmonoid.HasFaithfulSmul

/-- The action by a subgroup is the action by the underlying group. -/
instance [AddMonoidₓ α] [DistribMulAction G α] (S : Subgroup G) : DistribMulAction S α :=
  S.toSubmonoid.DistribMulAction

/-- The action by a subgroup is the action by the underlying group. -/
instance [Monoidₓ α] [MulDistribMulAction G α] (S : Subgroup G) : MulDistribMulAction S α :=
  S.toSubmonoid.MulDistribMulAction

/-- The center of a group acts commutatively on that group. -/
instance center.smul_comm_class_left : SmulCommClass (center G) G G :=
  Submonoid.center.smul_comm_class_left

/-- The center of a group acts commutatively on that group. -/
instance center.smul_comm_class_right : SmulCommClass G (center G) G :=
  Submonoid.center.smul_comm_class_right

end Subgroup

end Actions

/-! ### Mul-opposite subgroups -/


section MulOpposite

namespace Subgroup

/-- A subgroup `H` of `G` determines a subgroup `H.opposite` of the opposite group `Gᵐᵒᵖ`. -/
@[to_additive
      "An additive subgroup `H` of `G` determines an additive subgroup `H.opposite` of the\n  opposite additive group `Gᵃᵒᵖ`."]
def opposite (H : Subgroup G) : Subgroup Gᵐᵒᵖ where
  Carrier := MulOpposite.unop ⁻¹' (H : Set G)
  one_mem' := H.one_mem
  mul_mem' := fun a b ha hb => H.mul_mem hb ha
  inv_mem' := fun a => H.inv_mem

/-- Bijection between a subgroup `H` and its opposite. -/
@[to_additive "Bijection between an additive subgroup `H` and its opposite.", simps]
def oppositeEquiv (H : Subgroup G) : H ≃ H.opposite :=
  MulOpposite.opEquiv.subtypeEquiv fun _ => Iff.rfl

@[to_additive]
instance (H : Subgroup G) [Encodable H] : Encodable H.opposite :=
  Encodable.ofEquiv H H.oppositeEquiv.symm

@[to_additive]
theorem smul_opposite_mul {H : Subgroup G} (x g : G) (h : H.opposite) : h • (g * x) = g * h • x := by
  cases h
  simp [(· • ·), mul_assoc]

@[to_additive]
theorem smul_opposite_image_mul_preimage {H : Subgroup G} (g : G) (h : H.opposite) (s : Set G) :
    (fun y => h • y) '' (Mul.mul g ⁻¹' s) = Mul.mul g ⁻¹' ((fun y => h • y) '' s) := by
  ext x
  cases h
  simp [(· • ·), mul_assoc]

end Subgroup

end MulOpposite

/-! ### Saturated subgroups -/


section Saturated

namespace Subgroup

/-- A subgroup `H` of `G` is *saturated* if for all `n : ℕ` and `g : G` with `g^n ∈ H`
we have `n = 0` or `g ∈ H`. -/
@[to_additive
      "An additive subgroup `H` of `G` is *saturated* if\nfor all `n : ℕ` and `g : G` with `n•g ∈ H` we have `n = 0` or `g ∈ H`."]
def Saturated (H : Subgroup G) : Prop :=
  ∀ ⦃n g⦄, g ^ n ∈ H → n = 0 ∨ g ∈ H

@[to_additive]
theorem saturated_iff_npow {H : Subgroup G} : Saturated H ↔ ∀ (n : ℕ) (g : G), g ^ n ∈ H → n = 0 ∨ g ∈ H :=
  Iff.rfl

@[to_additive]
theorem saturated_iff_zpow {H : Subgroup G} : Saturated H ↔ ∀ (n : ℤ) (g : G), g ^ n ∈ H → n = 0 ∨ g ∈ H := by
  constructor
  · rintro hH ⟨n⟩ g hgn
    · simp only [Int.coe_nat_eq_zero, Int.of_nat_eq_coe, zpow_coe_nat] at hgn⊢
      exact hH hgn
      
    · suffices g ^ (n + 1) ∈ H by
        refine' (hH this).imp _ id
        simp only [IsEmpty.forall_iff, Nat.succ_ne_zero]
      simpa only [inv_mem_iff, zpow_neg_succ_of_nat] using hgn
      
    
  · intro h n g hgn
    specialize h n g
    simp only [Int.coe_nat_eq_zero, zpow_coe_nat] at h
    apply h hgn
    

end Subgroup

namespace AddSubgroup

theorem ker_saturated {A₁ A₂ : Type _} [AddCommGroupₓ A₁] [AddCommGroupₓ A₂] [NoZeroSmulDivisors ℕ A₂] (f : A₁ →+ A₂) :
    f.ker.Saturated := by
  intro n g hg
  simpa only [f.mem_ker, nsmul_eq_smul, f.map_nsmul, smul_eq_zero] using hg

end AddSubgroup

end Saturated

