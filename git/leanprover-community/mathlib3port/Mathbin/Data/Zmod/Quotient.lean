/-
Copyright (c) 2021 Anne Baanen. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anne Baanen
-/
import Mathbin.Data.Zmod.Basic
import Mathbin.GroupTheory.QuotientGroup
import Mathbin.RingTheory.Int.Basic

/-!
# `zmod n` and quotient groups / rings

This file relates `zmod n` to the quotient group
`quotient_add_group.quotient (add_subgroup.zmultiples n)` and to the quotient ring
`(ideal.span {n}).quotient`.

## Main definitions

 - `zmod.quotient_zmultiples_nat_equiv_zmod` and `zmod.quotient_zmultiples_equiv_zmod`:
   `zmod n` is the group quotient of `ℤ` by `n ℤ := add_subgroup.zmultiples (n)`,
   (where `n : ℕ` and `n : ℤ` respectively)
 - `zmod.quotient_span_nat_equiv_zmod` and `zmod.quotient_span_equiv_zmod`:
   `zmod n` is the ring quotient of `ℤ` by `n ℤ : ideal.span {n}`
   (where `n : ℕ` and `n : ℤ` respectively)
 - `zmod.lift n f` is the map from `zmod n` induced by `f : ℤ →+ A` that maps `n` to `0`.

## Tags

zmod, quotient group, quotient ring, ideal quotient
-/


open QuotientAddGroup

open Zmod

variable (n : ℕ) {A R : Type _} [AddGroupₓ A] [Ringₓ R]

namespace Int

/-- `ℤ` modulo multiples of `n : ℕ` is `zmod n`. -/
def quotientZmultiplesNatEquivZmod : ℤ ⧸ AddSubgroup.zmultiples (n : ℤ) ≃+ Zmod n :=
  (equivQuotientOfEq (Zmod.ker_int_cast_add_hom _)).symm.trans <|
    quotientKerEquivOfRightInverse (Int.castAddHom (Zmod n)) coe int_cast_zmod_cast

/-- `ℤ` modulo multiples of `a : ℤ` is `zmod a.nat_abs`. -/
def quotientZmultiplesEquivZmod (a : ℤ) : ℤ ⧸ AddSubgroup.zmultiples a ≃+ Zmod a.natAbs :=
  (equivQuotientOfEq (zmultiples_nat_abs a)).symm.trans (quotientZmultiplesNatEquivZmod a.natAbs)

/-- `ℤ` modulo the ideal generated by `n : ℕ` is `zmod n`. -/
def quotientSpanNatEquivZmod : ℤ ⧸ Ideal.span {↑n} ≃+* Zmod n :=
  (Ideal.quotEquivOfEq (Zmod.ker_int_cast_ring_hom _)).symm.trans <|
    RingHom.quotientKerEquivOfRightInverse <|
      show Function.RightInverse coe (Int.castRingHom (Zmod n)) from int_cast_zmod_cast

/-- `ℤ` modulo the ideal generated by `a : ℤ` is `zmod a.nat_abs`. -/
def quotientSpanEquivZmod (a : ℤ) : ℤ ⧸ Ideal.span ({a} : Set ℤ) ≃+* Zmod a.natAbs :=
  (Ideal.quotEquivOfEq (span_nat_abs a)).symm.trans (quotientSpanNatEquivZmod a.natAbs)

end Int

namespace AddAction

open AddSubgroup AddMonoidHom AddEquiv Function

variable {α β : Type _} [AddGroupₓ α] (a : α) [AddAction α β] (b : β)

/-- The quotient `(ℤ ∙ a) ⧸ (stabilizer b)` is cyclic of order `minimal_period ((+ᵥ) a) b`. -/
noncomputable def zmultiplesQuotientStabilizerEquiv :
    zmultiples a ⧸ stabilizer (zmultiples a) b ≃+ Zmod (minimalPeriod ((· +ᵥ ·) a) b) :=
  (ofBijective
          (map _ (stabilizer (zmultiples a) b) (zmultiplesHom (zmultiples a) ⟨a, mem_zmultiples a⟩)
            (by
              rw [zmultiples_le, mem_comap, mem_stabilizer_iff, zmultiples_hom_apply, coe_nat_zsmul, ← vadd_iterate]
              exact is_periodic_pt_minimal_period ((· +ᵥ ·) a) b))
          ⟨by
            rw [← ker_eq_bot_iff, eq_bot_iff]
            refine' fun q => induction_on' q fun n hn => _
            rw [mem_bot, eq_zero_iff, Int.mem_zmultiples_iff, ← zsmul_vadd_eq_iff_minimal_period_dvd]
            exact (eq_zero_iff _).mp hn, fun q => induction_on' q fun ⟨_, n, rfl⟩ => ⟨n, rfl⟩⟩).symm.trans
    (Int.quotientZmultiplesNatEquivZmod (minimalPeriod ((· +ᵥ ·) a) b))

theorem zmultiples_quotient_stabilizer_equiv_symm_apply (n : Zmod (minimalPeriod ((· +ᵥ ·) a) b)) :
    (zmultiplesQuotientStabilizerEquiv a b).symm n = (n : ℤ) • (⟨a, mem_zmultiples a⟩ : zmultiples a) :=
  rfl

end AddAction

namespace MulAction

open AddAction Subgroup AddSubgroup Function

variable {α β : Type _} [Groupₓ α] (a : α) [MulAction α β] (b : β)

/-- The quotient `(a ^ ℤ) ⧸ (stabilizer b)` is cyclic of order `minimal_period ((•) a) b`. -/
noncomputable def zpowersQuotientStabilizerEquiv :
    zpowers a ⧸ stabilizer (zpowers a) b ≃* Multiplicative (Zmod (minimalPeriod ((· • ·) a) b)) :=
  let f := zmultiplesQuotientStabilizerEquiv (Additive.ofMul a) b
  ⟨f.toFun, f.invFun, f.left_inv, f.right_inv, f.map_add'⟩

theorem zpowers_quotient_stabilizer_equiv_symm_apply (n : Zmod (minimalPeriod ((· • ·) a) b)) :
    (zpowersQuotientStabilizerEquiv a b).symm n = (⟨a, mem_zpowers a⟩ : zpowers a) ^ (n : ℤ) :=
  rfl

/-- The orbit `(a ^ ℤ) • b` is a cycle of order `minimal_period ((•) a) b`. -/
noncomputable def orbitZpowersEquiv : Orbit (zpowers a) b ≃ Zmod (minimalPeriod ((· • ·) a) b) :=
  (orbitEquivQuotientStabilizer _ b).trans (zpowersQuotientStabilizerEquiv a b).toEquiv

/-- The orbit `(ℤ • a) +ᵥ b` is a cycle of order `minimal_period ((+ᵥ) a) b`. -/
noncomputable def _root_.add_action.orbit_zmultiples_equiv {α β : Type _} [AddGroupₓ α] (a : α) [AddAction α β]
    (b : β) : AddAction.Orbit (zmultiples a) b ≃ Zmod (minimalPeriod ((· +ᵥ ·) a) b) :=
  (AddAction.orbitEquivQuotientStabilizer (zmultiples a) b).trans (zmultiplesQuotientStabilizerEquiv a b).toEquiv

attribute [to_additive orbit_zmultiples_equiv] orbit_zpowers_equiv

@[to_additive orbit_zmultiples_equiv_symm_apply]
theorem orbit_zpowers_equiv_symm_apply (k : Zmod (minimalPeriod ((· • ·) a) b)) :
    (orbitZpowersEquiv a b).symm k = (⟨a, mem_zpowers a⟩ : zpowers a) ^ (k : ℤ) • ⟨b, mem_orbit_self b⟩ :=
  rfl

theorem orbit_zpowers_equiv_symm_apply' (k : ℤ) :
    (orbitZpowersEquiv a b).symm k = (⟨a, mem_zpowers a⟩ : zpowers a) ^ k • ⟨b, mem_orbit_self b⟩ := by
  rw [orbit_zpowers_equiv_symm_apply, Zmod.coe_int_cast]
  exact Subtype.ext (zpow_smul_mod_minimal_period _ _ k)

theorem _root_.add_action.orbit_zmultiples_equiv_symm_apply' {α β : Type _} [AddGroupₓ α] (a : α) [AddAction α β]
    (b : β) (k : ℤ) :
    (AddAction.orbitZmultiplesEquiv a b).symm k =
      k • (⟨a, mem_zmultiples a⟩ : zmultiples a) +ᵥ ⟨b, AddAction.mem_orbit_self b⟩ :=
  by
  rw [AddAction.orbit_zmultiples_equiv_symm_apply, Zmod.coe_int_cast]
  exact Subtype.ext (zsmul_vadd_mod_minimal_period _ _ k)

attribute [to_additive orbit_zmultiples_equiv_symm_apply'] orbit_zpowers_equiv_symm_apply'

@[to_additive]
theorem minimal_period_eq_card [Fintype (Orbit (zpowers a) b)] :
    minimalPeriod ((· • ·) a) b = Fintype.card (Orbit (zpowers a) b) := by
  rw [← Fintype.of_equiv_card (orbit_zpowers_equiv a b), Zmod.card]

@[to_additive]
instance minimal_period_pos [Fintype <| Orbit (zpowers a) b] : NeZero <| minimalPeriod ((· • ·) a) b :=
  ⟨by
    have : Nonempty (orbit (zpowers a) b) := (orbit_nonempty b).to_subtype
    rw [minimal_period_eq_card]
    exact Fintype.card_ne_zero⟩

end MulAction

