/-
Copyright (c) 2022 Pierre-Alexandre Bazin. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Pierre-Alexandre Bazin
-/
import Mathbin.Algebra.Module.Default
import Mathbin.LinearAlgebra.Quotient
import Mathbin.RingTheory.Ideal.Quotient
import Mathbin.RingTheory.NonZeroDivisors
import Mathbin.Algebra.DirectSum.Module
import Mathbin.GroupTheory.Torsion
import Mathbin.LinearAlgebra.Isomorphisms
import Mathbin.GroupTheory.Torsion

/-!
# Torsion submodules

## Main definitions

* `torsion_of R M x` : the torsion ideal of `x`, containing all `a` such that `a • x = 0`.
* `submodule.torsion_by R M a` : the `a`-torsion submodule, containing all elements `x` of `M` such
  that `a • x = 0`.
* `submodule.torsion_by_set R M s` : the submodule containing all elements `x` of `M` such that
  `a • x = 0` for all `a` in `s`.
* `submodule.torsion' R M S` : the `S`-torsion submodule, containing all elements `x` of `M` such
  that `a • x = 0` for some `a` in `S`.
* `submodule.torsion R M` : the torsion submoule, containing all elements `x` of `M` such that
  `a • x = 0` for some non-zero-divisor `a` in `R`.
* `module.is_torsion_by R M a` : the property that defines a `a`-torsion module. Similarly,
  `is_torsion_by_set`, `is_torsion'` and `is_torsion`.
* `module.is_torsion_by_set.module` : Creates a `R ⧸ I`-module from a `R`-module that
  `is_torsion_by_set R _ I`.

## Main statements

* `quot_torsion_of_equiv_span_singleton` : isomorphism between the span of an element of `M` and
  the quotient by its torsion ideal.
* `torsion' R M S` and `torsion R M` are submodules.
* `torsion_by_set_eq_torsion_by_span` : torsion by a set is torsion by the ideal generated by it.
* `submodule.torsion_by_is_torsion_by` : the `a`-torsion submodule is a `a`-torsion module.
  Similar lemmas for `torsion'` and `torsion`.
* `submodule.torsion_is_internal` : a `∏ i, p i`-torsion module is the internal direct sum of its
  `p i`-torsion submodules when the `p i` are pairwise coprime.
* `submodule.no_zero_smul_divisors_iff_torsion_bot` : a module over a domain has
  `no_zero_smul_divisors` (that is, there is no non-zero `a`, `x` such that `a • x = 0`)
  iff its torsion submodule is trivial.
* `submodule.quotient_torsion.torsion_eq_bot` : quotienting by the torsion submodule makes the
  torsion submodule of the new module trivial. If `R` is a domain, we can derive an instance
  `submodule.quotient_torsion.no_zero_smul_divisors : no_zero_smul_divisors R (M ⧸ torsion R M)`.

## Notation

* The notions are defined for a `comm_semiring R` and a `module R M`. Some additional hypotheses on
  `R` and `M` are required by some lemmas.
* The letters `a`, `b`, ... are used for scalars (in `R`), while `x`, `y`, ... are used for vectors
  (in `M`).

## Tags

Torsion, submodule, module, quotient
-/


section

variable (R M : Type _) [Semiringₓ R] [AddCommMonoidₓ M] [Module R M]

/-- The torsion ideal of `x`, containing all `a` such that `a • x = 0`.-/
@[simps]
def torsionOf (x : M) : Ideal R :=
  (LinearMap.toSpanSingleton R M x).ker

variable {R M}

@[simp]
theorem mem_torsion_of_iff (x : M) (a : R) : a ∈ torsionOf R M x ↔ a • x = 0 :=
  Iff.rfl

end

section

variable (R M : Type _) [Ringₓ R] [AddCommGroupₓ M] [Module R M]

/-- The span of `x` in `M` is isomorphic to `R` quotiented by the torsion ideal of `x`.-/
noncomputable def quotTorsionOfEquivSpanSingleton (x : M) : (R ⧸ torsionOf R M x) ≃ₗ[R] R∙x :=
  (LinearMap.toSpanSingleton R M x).quotKerEquivRange.trans <|
    LinearEquiv.ofEq _ _ (LinearMap.span_singleton_eq_range R M x).symm

@[simp]
theorem quot_torsion_of_equiv_span_singleton_apply_mk (x : M) (a : R) :
    quotTorsionOfEquivSpanSingleton R M x (Submodule.Quotient.mk a) = a • ⟨x, Submodule.mem_span_singleton_self x⟩ :=
  rfl

end

open nonZeroDivisors

section Defs

variable (R M : Type _) [CommSemiringₓ R] [AddCommMonoidₓ M] [Module R M]

namespace Submodule

/-- The `a`-torsion submodule for `a` in `R`, containing all elements `x` of `M` such that
  `a • x = 0`. -/
@[simps]
def torsionBy (a : R) : Submodule R M :=
  (DistribMulAction.toLinearMap _ _ a).ker

/-- The submodule containing all elements `x` of `M` such that `a • x = 0` for all `a` in `s`. -/
@[simps]
def torsionBySet (s : Set R) : Submodule R M :=
  inf (torsionBy R M '' s)

/-- The `S`-torsion submodule, containing all elements `x` of `M` such that `a • x = 0` for some
`a` in `S`. -/
@[simps]
def torsion' (S : Type _) [CommMonoidₓ S] [DistribMulAction S M] [SmulCommClass S R M] : Submodule R M where
  Carrier := { x | ∃ a : S, a • x = 0 }
  zero_mem' := ⟨1, smul_zero _⟩
  add_mem' := fun x y ⟨a, hx⟩ ⟨b, hy⟩ =>
    ⟨b * a, by
      rw [smul_add, mul_smul, mul_comm, mul_smul, hx, hy, smul_zero, smul_zero, add_zeroₓ]⟩
  smul_mem' := fun a x ⟨b, h⟩ =>
    ⟨b, by
      rw [smul_comm, h, smul_zero]⟩

/-- The torsion submodule, containing all elements `x` of `M` such that  `a • x = 0` for some
  non-zero-divisor `a` in `R`. -/
@[reducible]
def torsion :=
  torsion' R M R⁰

end Submodule

namespace Module

/-- A `a`-torsion module is a module where every element is `a`-torsion. -/
@[reducible]
def IsTorsionBy (a : R) :=
  ∀ ⦃x : M⦄, a • x = 0

/-- A module where every element is `a`-torsion for all `a` in `s`. -/
@[reducible]
def IsTorsionBySet (s : Set R) :=
  ∀ ⦃x : M⦄ ⦃a : s⦄, (a : R) • x = 0

/-- A `S`-torsion module is a module where every element is `a`-torsion for some `a` in `S`. -/
@[reducible]
def IsTorsion' (S : Type _) [HasScalar S M] :=
  ∀ ⦃x : M⦄, ∃ a : S, a • x = 0

/-- A torsion module is a module where every element is `a`-torsion for some non-zero-divisor `a`.
-/
@[reducible]
def IsTorsion :=
  ∀ ⦃x : M⦄, ∃ a : R⁰, a • x = 0

end Module

end Defs

variable {R M : Type _}

namespace Submodule

open Module

variable [CommSemiringₓ R] [AddCommMonoidₓ M] [Module R M] (s : Set R) (a : R)

@[simp]
theorem smul_torsion_by (x : torsionBy R M a) : a • x = 0 :=
  Subtype.ext x.Prop

@[simp]
theorem smul_coe_torsion_by (x : torsionBy R M a) : a • (x : M) = 0 :=
  x.Prop

@[simp]
theorem mem_torsion_by_iff (x : M) : x ∈ torsionBy R M a ↔ a • x = 0 :=
  Iff.rfl

@[simp]
theorem mem_torsion_by_set_iff (x : M) : x ∈ torsionBySet R M s ↔ ∀ a : s, (a : R) • x = 0 := by
  refine' ⟨fun h ⟨a, ha⟩ => mem_Inf.mp h _ (Set.mem_image_of_mem _ ha), fun h => mem_Inf.mpr _⟩
  rintro _ ⟨a, ha, rfl⟩
  exact h ⟨a, ha⟩

@[simp]
theorem torsion_by_singleton_eq : torsionBySet R M {a} = torsionBy R M a := by
  ext x
  simp only [mem_torsion_by_set_iff, SetCoe.forall, Subtype.coe_mk, Set.mem_singleton_iff, forall_eq,
    mem_torsion_by_iff]

@[simp]
theorem is_torsion_by_singleton_iff : IsTorsionBySet R M {a} ↔ IsTorsionBy R M a := by
  refine' ⟨fun h x => @h _ ⟨_, Set.mem_singleton _⟩, fun h x => _⟩
  rintro ⟨b, rfl : b = a⟩
  exact @h _

theorem is_torsion_by_set_iff_torsion_by_set_eq_top : IsTorsionBySet R M s ↔ torsionBySet R M s = ⊤ :=
  ⟨fun h => eq_top_iff.mpr fun _ _ => (mem_torsion_by_set_iff _ _).mpr <| @h _, fun h x => by
    rw [← mem_torsion_by_set_iff, h]
    trivial⟩

/-- A `a`-torsion module is a module whose `a`-torsion submodule is the full space. -/
theorem is_torsion_by_iff_torsion_by_eq_top : IsTorsionBy R M a ↔ torsionBy R M a = ⊤ := by
  rw [← torsion_by_singleton_eq, ← is_torsion_by_singleton_iff, is_torsion_by_set_iff_torsion_by_set_eq_top]

theorem torsion_by_set_is_torsion_by_set : IsTorsionBySet R (torsionBySet R M s) s := fun a =>
  Subtype.ext <| (mem_torsion_by_set_iff _ _).mp hx a

/-- The `a`-torsion submodule is a `a`-torsion module. -/
theorem torsion_by_is_torsion_by : IsTorsionBy R (torsionBy R M a) a := fun _ => smul_torsion_by _ _

@[simp]
theorem torsion_by_torsion_by_eq_top : torsionBy R (torsionBy R M a) a = ⊤ :=
  (is_torsion_by_iff_torsion_by_eq_top a).mp <| torsion_by_is_torsion_by a

@[simp]
theorem torsion_by_set_torsion_by_set_eq_top : torsionBySet R (torsionBySet R M s) s = ⊤ :=
  (is_torsion_by_set_iff_torsion_by_set_eq_top s).mp <| torsion_by_set_is_torsion_by_set s

theorem torsion_by_set_le_torsion_by_set_of_subset {s t : Set R} (st : s ⊆ t) :
    torsionBySet R M t ≤ torsionBySet R M s :=
  Inf_le_Inf fun _ ⟨a, ha, h⟩ => ⟨a, st ha, h⟩

/-- Torsion by a set is torsion by the ideal generated by it. -/
theorem torsion_by_set_eq_torsion_by_span : torsionBySet R M s = torsionBySet R M (Ideal.span s) := by
  refine' le_antisymmₓ (fun x hx => _) (torsion_by_set_le_torsion_by_set_of_subset subset_span)
  rw [mem_torsion_by_set_iff] at hx⊢
  suffices Ideal.span s ≤ torsionOf R M x by
    rintro ⟨a, ha⟩
    exact this ha
  rw [Ideal.span_le]
  exact fun a ha => hx ⟨a, ha⟩

theorem is_torsion_by_set_iff_is_torsion_by_span : IsTorsionBySet R M s ↔ IsTorsionBySet R M (Ideal.span s) := by
  rw [is_torsion_by_set_iff_torsion_by_set_eq_top, is_torsion_by_set_iff_torsion_by_set_eq_top,
    torsion_by_set_eq_torsion_by_span]

theorem torsion_by_span_singleton_eq : torsionBySet R M (R∙a) = torsionBy R M a :=
  (torsion_by_set_eq_torsion_by_span _).symm.trans <| torsion_by_singleton_eq _

theorem is_torsion_by_span_singleton_iff : IsTorsionBySet R M (R∙a) ↔ IsTorsionBy R M a :=
  (is_torsion_by_set_iff_is_torsion_by_span _).symm.trans <| is_torsion_by_singleton_iff _

theorem torsion_by_le_torsion_by_of_dvd (a b : R) (dvd : a ∣ b) : torsionBy R M a ≤ torsionBy R M b := by
  rw [← torsion_by_span_singleton_eq, ← torsion_by_singleton_eq]
  apply torsion_by_set_le_torsion_by_set_of_subset
  rintro c (rfl : c = b)
  exact ideal.mem_span_singleton.mpr dvd

@[simp]
theorem torsion_by_one : torsionBy R M 1 = ⊥ :=
  eq_bot_iff.mpr fun _ h => by
    rw [mem_torsion_by_iff, one_smul] at h
    exact h

@[simp]
theorem torsion_by_univ : torsionBySet R M Set.Univ = ⊥ := by
  rw [eq_bot_iff, ← torsion_by_one, ← torsion_by_singleton_eq]
  exact torsion_by_set_le_torsion_by_set_of_subset fun _ _ => trivialₓ

section Coprime

open BigOperators

open Dfinsupp

variable {ι : Type _} {p : ι → R} {S : Finset ι} (hp : Pairwise (IsCoprime on fun s : S => p s))

include hp

theorem supr_torsion_by_eq_torsion_by_prod : (⨆ i : S, torsionBy R M (p i)) = torsionBy R M (∏ i in S, p i) := by
  cases' S.eq_empty_or_nonempty with h h
  · rw [h, Finset.prod_empty, torsion_by_one]
    convert supr_of_empty _
    exact Subtype.is_empty_false
    
  apply le_antisymmₓ
  · apply supr_le _
    rintro ⟨i, is⟩
    exact torsion_by_le_torsion_by_of_dvd _ _ (Finset.dvd_prod_of_mem p is)
    
  · intro x hx
    classical
    rw [mem_supr_iff_exists_dfinsupp']
    cases' (exists_sum_eq_one_iff_pairwise_coprime h).mpr hp with f hf
    use
      equiv_fun_on_fintype.inv_fun fun i =>
        ⟨(f i * ∏ j in S \ {i}, p j) • x, by
          obtain ⟨i, is⟩ := i
          change p i • (f i * ∏ j in S \ {i}, _) • _ = _
          change _ • _ = _ at hx
          rw [smul_smul, mul_comm, mul_assoc, mul_smul, ← Finset.prod_eq_prod_diff_singleton_mul is, hx, smul_zero]⟩
    simp only [Equivₓ.inv_fun_as_coe, sum_eq_sum_fintype, coe_eq_zero, eq_self_iff_true, implies_true_iff,
      Finset.univ_eq_attach, equiv_fun_on_fintype_apply]
    change (∑ i : S, (f i * ∏ j in S \ {i}, p j) • x) = x
    have : (∑ i : S, _) = _ := S.sum_finset_coe fun i => f i * ∏ j in S \ {i}, p j
    rw [← Finset.sum_smul, this, hf, one_smul]
    

theorem torsion_by_independent : CompleteLattice.Independent fun i : S => torsionBy R M (p i) := fun i => by
  classical
  dsimp'
  rw [disjoint_iff, eq_bot_iff]
  intro x hx
  rw [Submodule.mem_inf] at hx
  obtain ⟨hxi, hxj⟩ := hx
  have hxi : p i • x = 0 := hxi
  rw [mem_supr_iff_exists_dfinsupp'] at hxj
  cases' hxj with f hf
  obtain ⟨b, c, h1⟩ := pairwise_coprime_iff_coprime_prod.mp hp i i.2
  rw [mem_bot, ← one_smul _ x, ← h1, add_smul]
  convert zero_addₓ (0 : M)
  · rw [mul_smul, hxi, smul_zero]
    
  · rw [← hf, smul_sum, sum_eq_zero]
    intro j
    by_cases' ji : j = i
    · convert smul_zero _
      rw [← mem_bot _]
      convert coe_mem (f j)
      symm
      rw [supr_eq_bot]
      intro hj'
      exfalso
      exact hj' ji
      
    · have hj' : ↑j ∈ S \ {i} := by
        rw [Finset.mem_sdiff]
        refine' ⟨j.2, fun hj' => ji _⟩
        ext
        rw [← Finset.mem_singleton]
        exact hj'
      rw [Finset.prod_eq_prod_diff_singleton_mul hj', ← mul_assoc, mul_smul]
      have : (⨆ H : ¬j = i, torsion_by R M (p j)) ≤ torsion_by R M (p j) := supr_const_le
      have : _ • _ = _ := this (coe_mem _)
      rw [this, smul_zero]
      
    

end Coprime

end Submodule

section NeedsGroup

variable [CommRingₓ R] [AddCommGroupₓ M] [Module R M]

namespace Submodule

open BigOperators

variable {ι : Type _} {p : ι → R} {S : Finset ι} (hp : Pairwise (IsCoprime on fun s : S => p s))

include hp

/-- If the `p i` are pairwise coprime, a `∏ i, p i`-torsion module is the internal direct sum of
its `p i`-torsion submodules.-/
theorem torsion_is_internal [DecidableEq ι] (hM : torsionBy R M (∏ i in S, p i) = ⊤) :
    DirectSum.SubmoduleIsInternal fun i : S => torsionBy R M (p i) :=
  DirectSum.submodule_is_internal_of_independent_of_supr_eq_top (torsion_by_independent hp)
    (by
      rw [← hM]
      exact supr_torsion_by_eq_torsion_by_prod hp)

end Submodule

namespace Module

variable {I : Ideal R} (hM : IsTorsionBySet R M I)

include hM

/-- can't be an instance because hM can't be inferred -/
def IsTorsionBySet.hasScalar : HasScalar (R ⧸ I) M where
  smul := fun b x =>
    (Quotientₓ.liftOn' b (· • x)) fun b₁ b₂ h => by
      show b₁ • x = b₂ • x
      have : (-b₁ + b₂) • x = 0 := @hM x ⟨_, h⟩
      rw [add_smul, neg_smul, neg_add_eq_zero] at this
      exact this

@[simp]
theorem IsTorsionBySet.mk_smul (b : R) (x : M) :
    have := hM.has_scalar
    Ideal.Quotient.mk I b • x = b • x :=
  rfl

/-- A `(R ⧸ I)`-module is a `R`-module which `is_torsion_by_set R M I`. -/
def IsTorsionBySet.module : Module (R ⧸ I) M :=
  @Function.Surjective.moduleLeft _ _ _ _ _ _ _ hM.HasScalar _ Ideal.Quotient.mk_surjective (IsTorsionBySet.mk_smul hM)

end Module

namespace Submodule

instance (I : Ideal R) : Module (R ⧸ I) (torsionBySet R M I) :=
  Module.IsTorsionBySet.module <| torsion_by_set_is_torsion_by_set I

@[simp]
theorem torsionBySet.mk_smul (I : Ideal R) (b : R) (x : torsionBySet R M I) : Ideal.Quotient.mk I b • x = b • x :=
  rfl

instance (I : Ideal R) {S : Type _} [HasScalar S R] [HasScalar S M] [IsScalarTower S R M] [IsScalarTower S R R] :
    IsScalarTower S (R ⧸ I) (torsionBySet R M I) where
  smul_assoc := fun b d x => (Quotientₓ.induction_on' d) fun c => (smul_assoc b c x : _)

/-- The `a`-torsion submodule as a `(R ⧸ R∙a)`-module. -/
instance (a : R) : Module (R ⧸ R∙a) (torsionBy R M a) :=
  Module.IsTorsionBySet.module <| (is_torsion_by_span_singleton_iff a).mpr <| torsion_by_is_torsion_by a

@[simp]
theorem torsionBy.mk_smul (a b : R) (x : torsionBy R M a) : Ideal.Quotient.mk (R∙a) b • x = b • x :=
  rfl

instance (a : R) {S : Type _} [HasScalar S R] [HasScalar S M] [IsScalarTower S R M] [IsScalarTower S R R] :
    IsScalarTower S (R ⧸ R∙a) (torsionBy R M a) where
  smul_assoc := fun b d x => (Quotientₓ.induction_on' d) fun c => (smul_assoc b c x : _)

end Submodule

end NeedsGroup

namespace Submodule

section Torsion'

open Module

variable [CommSemiringₓ R] [AddCommMonoidₓ M] [Module R M]

variable (S : Type _) [CommMonoidₓ S] [DistribMulAction S M] [SmulCommClass S R M]

@[simp]
theorem mem_torsion'_iff (x : M) : x ∈ torsion' R M S ↔ ∃ a : S, a • x = 0 :=
  Iff.rfl

@[simp]
theorem mem_torsion_iff (x : M) : x ∈ torsion R M ↔ ∃ a : R⁰, a • x = 0 :=
  Iff.rfl

@[simps]
instance : HasScalar S (torsion' R M S) :=
  ⟨fun s x =>
    ⟨s • x, by
      obtain ⟨x, a, h⟩ := x
      use a
      dsimp'
      rw [smul_comm, h, smul_zero]⟩⟩

instance : DistribMulAction S (torsion' R M S) :=
  Subtype.coe_injective.DistribMulAction (torsion' R M S).Subtype.toAddMonoidHom fun x => rfl

instance : SmulCommClass S R (torsion' R M S) :=
  ⟨fun s a x => Subtype.ext <| smul_comm _ _ _⟩

/-- A `S`-torsion module is a module whose `S`-torsion submodule is the full space. -/
theorem is_torsion'_iff_torsion'_eq_top : IsTorsion' M S ↔ torsion' R M S = ⊤ :=
  ⟨fun h => eq_top_iff.mpr fun _ _ => @h _, fun h x => by
    rw [← @mem_torsion'_iff R, h]
    trivial⟩

/-- The `S`-torsion submodule is a `S`-torsion module. -/
theorem torsion'_is_torsion' : IsTorsion' (torsion' R M S) S := fun ⟨x, ⟨a, h⟩⟩ => ⟨a, Subtype.ext h⟩

@[simp]
theorem torsion'_torsion'_eq_top : torsion' R (torsion' R M S) S = ⊤ :=
  (is_torsion'_iff_torsion'_eq_top S).mp <| torsion'_is_torsion' S

/-- The torsion submodule of the torsion submodule (viewed as a module) is the full
torsion module. -/
@[simp]
theorem torsion_torsion_eq_top : torsion R (torsion R M) = ⊤ :=
  torsion'_torsion'_eq_top R⁰

/-- The torsion submodule is always a torsion module. -/
theorem torsion_is_torsion : Module.IsTorsion R (torsion R M) :=
  torsion'_is_torsion' R⁰

theorem is_torsion'_powers_iff (p : R) : IsTorsion' M (Submonoid.powers p) ↔ ∀ x : M, ∃ n : ℕ, p ^ n • x = 0 :=
  ⟨fun h x =>
    let ⟨⟨a, ⟨n, rfl⟩⟩, hx⟩ := @h x
    ⟨n, hx⟩,
    fun h x =>
    let ⟨n, hn⟩ := h x
    ⟨⟨_, ⟨n, rfl⟩⟩, hn⟩⟩

end Torsion'

section torsion

variable [CommSemiringₓ R] [AddCommMonoidₓ M] [Module R M] [NoZeroDivisors R] [Nontrivial R]

theorem coe_torsion_eq_annihilator_ne_bot : (torsion R M : Set M) = { x : M | (R∙x).annihilator ≠ ⊥ } := by
  ext x
  simp_rw [Submodule.ne_bot_iff, mem_annihilator, mem_span_singleton]
  exact
    ⟨fun ⟨a, hax⟩ =>
      ⟨a, fun _ ⟨b, hb⟩ => by
        rw [← hb, smul_comm, ← Submonoid.smul_def, hax, smul_zero], nonZeroDivisors.coe_ne_zero _⟩,
      fun ⟨a, hax, ha⟩ => ⟨⟨_, mem_non_zero_divisors_of_ne_zero ha⟩, hax x ⟨1, one_smul _ _⟩⟩⟩

/-- A module over a domain has `no_zero_smul_divisors` iff its torsion submodule is trivial. -/
theorem no_zero_smul_divisors_iff_torsion_eq_bot : NoZeroSmulDivisors R M ↔ torsion R M = ⊥ := by
  constructor <;> intro h
  · have : NoZeroSmulDivisors R M := h
    rw [eq_bot_iff]
    rintro x ⟨a, hax⟩
    change (a : R) • x = 0 at hax
    cases' eq_zero_or_eq_zero_of_smul_eq_zero hax with h0 h0
    · exfalso
      exact nonZeroDivisors.coe_ne_zero a h0
      
    · exact h0
      
    
  · exact
      { eq_zero_or_eq_zero_of_smul_eq_zero := fun a x hax => by
          by_cases' ha : a = 0
          · left
            exact ha
            
          · right
            rw [← mem_bot _, ← h]
            exact ⟨⟨a, mem_non_zero_divisors_of_ne_zero ha⟩, hax⟩
             }
    

end torsion

namespace QuotientTorsion

variable [CommRingₓ R] [AddCommGroupₓ M] [Module R M]

/-- Quotienting by the torsion submodule gives a torsion-free module. -/
@[simp]
theorem torsion_eq_bot : torsion R (M ⧸ torsion R M) = ⊥ :=
  eq_bot_iff.mpr fun z =>
    (Quotientₓ.induction_on' z) fun x ⟨a, hax⟩ => by
      rw [Quotientₓ.mk'_eq_mk, ← quotient.mk_smul, quotient.mk_eq_zero] at hax
      rw [mem_bot, Quotientₓ.mk'_eq_mk, quotient.mk_eq_zero]
      cases' hax with b h
      exact ⟨b * a, (mul_smul _ _ _).trans h⟩

instance no_zero_smul_divisors [IsDomain R] : NoZeroSmulDivisors R (M ⧸ torsion R M) :=
  no_zero_smul_divisors_iff_torsion_eq_bot.mpr torsion_eq_bot

end QuotientTorsion

end Submodule

namespace Ideal.Quotient

open Submodule

theorem torsion_by_eq_span_singleton {R : Type _} [CommRingₓ R] (a b : R) (ha : a ∈ R⁰) :
    torsionBy R (R ⧸ R∙a * b) a = R∙mk _ b := by
  ext x
  rw [mem_torsion_by_iff, mem_span_singleton]
  obtain ⟨x, rfl⟩ := mk_surjective x
  constructor <;> intro h
  · rw [← mk_eq_mk, ← quotient.mk_smul, quotient.mk_eq_zero, mem_span_singleton] at h
    obtain ⟨c, h⟩ := h
    rw [smul_eq_mul, smul_eq_mul, mul_comm, mul_assoc, mul_cancel_left_mem_non_zero_divisor ha, mul_comm] at h
    use c
    rw [← h, ← mk_eq_mk, ← quotient.mk_smul, smul_eq_mul, mk_eq_mk]
    
  · obtain ⟨c, h⟩ := h
    rw [← h, smul_comm, ← mk_eq_mk, ← quotient.mk_smul, (quotient.mk_eq_zero _).mpr <| mem_span_singleton_self _,
      smul_zero]
    

end Ideal.Quotient

namespace AddMonoidₓ

theorem is_torsion_iff_is_torsion_nat [AddCommMonoidₓ M] : AddMonoidₓ.IsTorsion M ↔ Module.IsTorsion ℕ M := by
  refine' ⟨fun h x => _, fun h x => _⟩
  · obtain ⟨n, h0, hn⟩ := (is_of_fin_add_order_iff_nsmul_eq_zero x).mp (h x)
    exact ⟨⟨n, mem_non_zero_divisors_of_ne_zero <| ne_of_gtₓ h0⟩, hn⟩
    
  · rw [is_of_fin_add_order_iff_nsmul_eq_zero]
    obtain ⟨n, hn⟩ := @h x
    refine' ⟨n, Nat.pos_of_ne_zeroₓ (nonZeroDivisors.coe_ne_zero _), hn⟩
    

theorem is_torsion_iff_is_torsion_int [AddCommGroupₓ M] : AddMonoidₓ.IsTorsion M ↔ Module.IsTorsion ℤ M := by
  refine' ⟨fun h x => _, fun h x => _⟩
  · obtain ⟨n, h0, hn⟩ := (is_of_fin_add_order_iff_nsmul_eq_zero x).mp (h x)
    exact ⟨⟨n, mem_non_zero_divisors_of_ne_zero <| ne_of_gtₓ <| int.coe_nat_pos.mpr h0⟩, (coe_nat_zsmul _ _).trans hn⟩
    
  · rw [is_of_fin_add_order_iff_nsmul_eq_zero]
    obtain ⟨n, hn⟩ := @h x
    exact exists_nsmul_eq_zero_of_zsmul_eq_zero (nonZeroDivisors.coe_ne_zero n) hn
    

end AddMonoidₓ

