/-
Copyright (c) 2019 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import Mathbin.Order.Filter.Bases

/-!
# Lift filters along filter and set functions
-/


open Set

open_locale Classical Filter

namespace Filter

variable {Œ± : Type _} {Œ≤ : Type _} {Œ≥ : Type _} {Œπ : Sort _}

section lift

/-- A variant on `bind` using a function `g` taking a set instead of a member of `Œ±`.
This is essentially a push-forward along a function mapping each set to a filter. -/
protected def lift (f : Filter Œ±) (g : Set Œ± ‚Üí Filter Œ≤) :=
  ‚®Ö s ‚àà f, g s

variable {f f‚ÇÅ f‚ÇÇ : Filter Œ±} {g g‚ÇÅ g‚ÇÇ : Set Œ± ‚Üí Filter Œ≤}

@[simp]
theorem lift_top (g : Set Œ± ‚Üí Filter Œ≤) : (‚ä§ : Filter Œ±).lift g = g Univ := by
  simp [Filter.lift]

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type, see `filter.has_basis.lift`.
This lemma states the corresponding `mem_iff` statement without using a sigma type. -/
theorem HasBasis.mem_lift_iff {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {f : Filter Œ±} (hf : f.HasBasis p s) {Œ≤ : Œπ ‚Üí Type _}
    {pg : ‚àÄ i, Œ≤ i ‚Üí Prop} {sg : ‚àÄ i, Œ≤ i ‚Üí Set Œ≥} {g : Set Œ± ‚Üí Filter Œ≥} (hg : ‚àÄ i, (g <| s i).HasBasis (pg i) (sg i))
    (gm : Monotone g) {s : Set Œ≥} : s ‚àà f.lift g ‚Üî ‚àÉ (i : Œπ)(hi : p i)(x : Œ≤ i)(hx : pg i x), sg i x ‚äÜ s := by
  refine' (mem_binfi_of_directed _ ‚ü®univ, univ_sets _‚ü©).trans _
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm <| inter_subset_left _ _, gm <| inter_subset_right _ _‚ü©
    
  ¬∑ simp only [‚Üê (hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H
    

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type. See also `filter.has_basis.mem_lift_iff`
for the corresponding `mem_iff` statement formulated without using a sigma type. -/
theorem HasBasis.lift {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {f : Filter Œ±} (hf : f.HasBasis p s) {Œ≤ : Œπ ‚Üí Type _}
    {pg : ‚àÄ i, Œ≤ i ‚Üí Prop} {sg : ‚àÄ i, Œ≤ i ‚Üí Set Œ≥} {g : Set Œ± ‚Üí Filter Œ≥} (hg : ‚àÄ i, (g <| s i).HasBasis (pg i) (sg i))
    (gm : Monotone g) : (f.lift g).HasBasis (fun i : Œ£i, Œ≤ i => p i.1 ‚àß pg i.1 i.2) fun i : Œ£i, Œ≤ i => sg i.1 i.2 := by
  refine' ‚ü®fun t => (hf.mem_lift_iff hg gm).trans _‚ü©
  simp [Sigma.exists, and_assoc, exists_and_distrib_left]

theorem mem_lift_sets (hg : Monotone g) {s : Set Œ≤} : s ‚àà f.lift g ‚Üî ‚àÉ t ‚àà f, s ‚àà g t :=
  (f.basis_sets.mem_lift_iff (fun s => (g s).basis_sets) hg).trans <| by
    simp only [id, exists_mem_subset_iff]

theorem mem_lift {s : Set Œ≤} {t : Set Œ±} (ht : t ‚àà f) (hs : s ‚àà g t) : s ‚àà f.lift g :=
  le_principal_iff.mp <| show f.lift g ‚â§ ùìü s from infi_le_of_le t <| infi_le_of_le ht <| le_principal_iff.mpr hs

theorem lift_le {f : Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} {h : Filter Œ≤} {s : Set Œ±} (hs : s ‚àà f) (hg : g s ‚â§ h) :
    f.lift g ‚â§ h :=
  infi_le_of_le s <| infi_le_of_le hs <| hg

theorem le_lift {f : Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} {h : Filter Œ≤} (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h ‚â§ g s) : h ‚â§ f.lift g :=
  le_infi fun s => le_infi fun hs => hh s hs

theorem lift_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) : f‚ÇÅ.lift g‚ÇÅ ‚â§ f‚ÇÇ.lift g‚ÇÇ :=
  infi_le_infi fun s => infi_le_infi2 fun hs => ‚ü®hf hs, hg s‚ü©

theorem lift_mono' (hg : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, g‚ÇÅ s ‚â§ g‚ÇÇ s) : f.lift g‚ÇÅ ‚â§ f.lift g‚ÇÇ :=
  infi_le_infi fun s => infi_le_infi fun hs => hg s hs

theorem tendsto_lift {m : Œ≥ ‚Üí Œ≤} {l : Filter Œ≥} : Tendsto m l (f.lift g) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, Tendsto m l (g s) := by
  simp only [Filter.lift, tendsto_infi]

theorem map_lift_eq {m : Œ≤ ‚Üí Œ≥} (hg : Monotone g) : map m (f.lift g) = f.lift (map m ‚àò g) :=
  have : Monotone (map m ‚àò g) := map_mono.comp hg
  Filter.ext fun s => by
    simp only [mem_lift_sets hg, mem_lift_sets this, exists_prop, mem_map, Function.comp_app]

theorem comap_lift_eq {m : Œ≥ ‚Üí Œ≤} (hg : Monotone g) : comap m (f.lift g) = f.lift (comap m ‚àò g) := by
  have : Monotone (comap m ‚àò g) := comap_mono.comp hg
  ext
  simp only [mem_lift_sets hg, mem_lift_sets this, mem_comap, exists_prop, mem_lift_sets]
  exact ‚ü®fun ‚ü®b, ‚ü®a, ha, hb‚ü©, hs‚ü© => ‚ü®a, ha, b, hb, hs‚ü©, fun ‚ü®a, ha, b, hb, hs‚ü© => ‚ü®b, ‚ü®a, ha, hb‚ü©, hs‚ü©‚ü©

theorem comap_lift_eq2 {m : Œ≤ ‚Üí Œ±} {g : Set Œ≤ ‚Üí Filter Œ≥} (hg : Monotone g) :
    (comap m f).lift g = f.lift (g ‚àò Preimage m) :=
  le_antisymm‚Çì (le_infi fun s => le_infi fun hs => infi_le_of_le (Preimage m s) <| infi_le _ ‚ü®s, hs, Subset.refl _‚ü©)
    (le_infi fun s =>
      le_infi fun ‚ü®s', hs', (h_sub : preimage m s' ‚äÜ s)‚ü© => infi_le_of_le s' <| infi_le_of_le hs' <| hg h_sub)

theorem map_lift_eq2 {g : Set Œ≤ ‚Üí Filter Œ≥} {m : Œ± ‚Üí Œ≤} (hg : Monotone g) : (map m f).lift g = f.lift (g ‚àò Image m) :=
  le_antisymm‚Çì
    (infi_le_infi2 fun s =>
      ‚ü®Image m s, infi_le_infi2 fun hs => ‚ü®(f.sets_of_superset hs) fun a h => mem_image_of_mem _ h, le_rfl‚ü©‚ü©)
    (infi_le_infi2 fun t =>
      ‚ü®Preimage m t,
        infi_le_infi2 fun ht =>
          ‚ü®ht,
            hg fun x => fun h : x ‚àà m '' Preimage m t =>
              let ‚ü®y, hy, h_eq‚ü© := h
              show x ‚àà t from h_eq ‚ñ∏ hy‚ü©‚ü©)

theorem lift_comm {g : Filter Œ≤} {h : Set Œ± ‚Üí Set Œ≤ ‚Üí Filter Œ≥} :
    (f.lift fun s => g.lift (h s)) = g.lift fun t => f.lift fun s => h s t :=
  le_antisymm‚Çì
    (le_infi fun i =>
      le_infi fun hi =>
        le_infi fun j => le_infi fun hj => infi_le_of_le j <| infi_le_of_le hj <| infi_le_of_le i <| infi_le _ hi)
    (le_infi fun i =>
      le_infi fun hi =>
        le_infi fun j => le_infi fun hj => infi_le_of_le j <| infi_le_of_le hj <| infi_le_of_le i <| infi_le _ hi)

theorem lift_assoc {h : Set Œ≤ ‚Üí Filter Œ≥} (hg : Monotone g) : (f.lift g).lift h = f.lift fun s => (g s).lift h :=
  le_antisymm‚Çì
    (le_infi fun s =>
      le_infi fun hs =>
        le_infi fun t => le_infi fun ht => infi_le_of_le t <| infi_le _ <| (mem_lift_sets hg).mpr ‚ü®_, hs, ht‚ü©)
    (le_infi fun t =>
      le_infi fun ht =>
        let ‚ü®s, hs, h'‚ü© := (mem_lift_sets hg).mp ht
        infi_le_of_le s <| infi_le_of_le hs <| infi_le_of_le t <| infi_le _ h')

theorem lift_lift_same_le_lift {g : Set Œ± ‚Üí Set Œ± ‚Üí Filter Œ≤} :
    (f.lift fun s => f.lift (g s)) ‚â§ f.lift fun s => g s s :=
  le_infi fun s => le_infi fun hs => infi_le_of_le s <| infi_le_of_le hs <| infi_le_of_le s <| infi_le _ hs

theorem lift_lift_same_eq_lift {g : Set Œ± ‚Üí Set Œ± ‚Üí Filter Œ≤} (hg‚ÇÅ : ‚àÄ s, Monotone fun t => g s t)
    (hg‚ÇÇ : ‚àÄ t, Monotone fun s => g s t) : (f.lift fun s => f.lift (g s)) = f.lift fun s => g s s :=
  le_antisymm‚Çì lift_lift_same_le_lift
    (le_infi fun s =>
      le_infi fun hs =>
        le_infi fun t =>
          le_infi fun ht =>
            infi_le_of_le (s ‚à© t) <|
              infi_le_of_le (inter_mem hs ht) <|
                calc
                  g (s ‚à© t) (s ‚à© t) ‚â§ g s (s ‚à© t) := hg‚ÇÇ (s ‚à© t) (inter_subset_left _ _)
                  _ ‚â§ g s t := hg‚ÇÅ s (inter_subset_right _ _)
                  )

theorem lift_principal {s : Set Œ±} (hg : Monotone g) : (ùìü s).lift g = g s :=
  le_antisymm‚Çì (infi_le_of_le s <| infi_le _ <| Subset.refl _) (le_infi fun t => le_infi fun hi => hg hi)

theorem monotone_lift [Preorder‚Çì Œ≥] {f : Œ≥ ‚Üí Filter Œ±} {g : Œ≥ ‚Üí Set Œ± ‚Üí Filter Œ≤} (hf : Monotone f) (hg : Monotone g) :
    Monotone fun c => (f c).lift (g c) := fun a b h => lift_mono (hf h) (hg h)

theorem lift_ne_bot_iff (hm : Monotone g) : (ne_bot <| f.lift g) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, NeBot (g s) := by
  rw [Filter.lift, infi_subtype', infi_ne_bot_iff_of_directed', Subtype.forall']
  ¬∑ rintro ‚ü®s, hs‚ü© ‚ü®t, ht‚ü©
    exact ‚ü®‚ü®s ‚à© t, inter_mem hs ht‚ü©, hm (inter_subset_left s t), hm (inter_subset_right s t)‚ü©
    

@[simp]
theorem lift_const {f : Filter Œ±} {g : Filter Œ≤} : (f.lift fun x => g) = g :=
  le_antisymm‚Çì (lift_le univ_mem <| le_refl‚Çì g) (le_lift fun s hs => le_refl‚Çì g)

@[simp]
theorem lift_inf {f : Filter Œ±} {g h : Set Œ± ‚Üí Filter Œ≤} : (f.lift fun x => g x‚äìh x) = f.lift g‚äìf.lift h := by
  simp only [Filter.lift, infi_inf_eq, eq_self_iff_true]

@[simp]
theorem lift_principal2 {f : Filter Œ±} : f.lift ùìü = f :=
  le_antisymm‚Çì (fun s hs => mem_lift hs (mem_principal_self s))
    (le_infi fun s =>
      le_infi fun hs => by
        simp only [hs, le_principal_iff])

theorem lift_infi {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} [hŒπ : Nonempty Œπ] (hg : ‚àÄ {s t}, g s‚äìg t = g (s ‚à© t)) :
    (infi f).lift g = ‚®Ö i, (f i).lift g :=
  le_antisymm‚Çì (le_infi fun i => lift_mono (infi_le _ _) le_rfl) fun s => by
    have g_mono : Monotone g := fun s t h =>
      le_of_inf_eq <| Eq.trans hg <| congr_arg‚Çì g <| inter_eq_self_of_subset_left h
    have : ‚àÄ, ‚àÄ t ‚àà infi f, ‚àÄ, (‚®Ö i : Œπ, Filter.lift (f i) g) ‚â§ g t := fun t ht =>
      infi_sets_induct ht
        (let ‚ü®i‚ü© := hŒπ
        infi_le_of_le i <| infi_le_of_le Univ <| infi_le _ univ_mem)
        fun i s‚ÇÅ s‚ÇÇ hs‚ÇÅ hs‚ÇÇ => @hg s‚ÇÅ s‚ÇÇ ‚ñ∏ le_inf (infi_le_of_le i <| infi_le_of_le s‚ÇÅ <| infi_le _ hs‚ÇÅ) hs‚ÇÇ
    simp only [mem_lift_sets g_mono, exists_imp_distrib]
    exact fun t ht hs => this t ht hs

end lift

section Lift'

/-- Specialize `lift` to functions `set Œ± ‚Üí set Œ≤`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set. -/
protected def lift' (f : Filter Œ±) (h : Set Œ± ‚Üí Set Œ≤) :=
  f.lift (ùìü ‚àò h)

variable {f f‚ÇÅ f‚ÇÇ : Filter Œ±} {h h‚ÇÅ h‚ÇÇ : Set Œ± ‚Üí Set Œ≤}

@[simp]
theorem lift'_top (h : Set Œ± ‚Üí Set Œ≤) : (‚ä§ : Filter Œ±).lift' h = ùìü (h Univ) :=
  lift_top _

theorem mem_lift' {t : Set Œ±} (ht : t ‚àà f) : h t ‚àà f.lift' h :=
  le_principal_iff.mp <| show f.lift' h ‚â§ ùìü (h t) from infi_le_of_le t <| infi_le_of_le ht <| le_rfl

theorem tendsto_lift' {m : Œ≥ ‚Üí Œ≤} {l : Filter Œ≥} : Tendsto m l (f.lift' h) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, ‚àÄ·∂† a in l, m a ‚àà h s := by
  simp only [Filter.lift', tendsto_lift, tendsto_principal]

theorem HasBasis.lift' {Œπ} {p : Œπ ‚Üí Prop} {s} (hf : f.HasBasis p s) (hh : Monotone h) :
    (f.lift' h).HasBasis p (h ‚àò s) := by
  refine' ‚ü®fun t => (hf.mem_lift_iff _ (monotone_principal.comp hh)).trans _‚ü©
  show ‚àÄ i, (ùìü (h (s i))).HasBasis (fun j : Unit => True) fun j : Unit => h (s i)
  exact fun i => has_basis_principal _
  simp only [exists_const]

theorem mem_lift'_sets (hh : Monotone h) {s : Set Œ≤} : s ‚àà f.lift' h ‚Üî ‚àÉ t ‚àà f, h t ‚äÜ s :=
  mem_lift_sets <| monotone_principal.comp hh

theorem eventually_lift'_iff (hh : Monotone h) {p : Œ≤ ‚Üí Prop} :
    (‚àÄ·∂† y in f.lift' h, p y) ‚Üî ‚àÉ t ‚àà f, ‚àÄ, ‚àÄ y ‚àà h t, ‚àÄ, p y :=
  mem_lift'_sets hh

theorem lift'_le {f : Filter Œ±} {g : Set Œ± ‚Üí Set Œ≤} {h : Filter Œ≤} {s : Set Œ±} (hs : s ‚àà f) (hg : ùìü (g s) ‚â§ h) :
    f.lift' g ‚â§ h :=
  lift_le hs hg

theorem lift'_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hh : h‚ÇÅ ‚â§ h‚ÇÇ) : f‚ÇÅ.lift' h‚ÇÅ ‚â§ f‚ÇÇ.lift' h‚ÇÇ :=
  (lift_mono hf) fun s => principal_mono.mpr <| hh s

theorem lift'_mono' (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h‚ÇÅ s ‚äÜ h‚ÇÇ s) : f.lift' h‚ÇÅ ‚â§ f.lift' h‚ÇÇ :=
  infi_le_infi fun s => infi_le_infi fun hs => principal_mono.mpr <| hh s hs

theorem lift'_cong (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h‚ÇÅ s = h‚ÇÇ s) : f.lift' h‚ÇÅ = f.lift' h‚ÇÇ :=
  le_antisymm‚Çì (lift'_mono' fun s hs => le_of_eq‚Çì <| hh s hs) (lift'_mono' fun s hs => le_of_eq‚Çì <| (hh s hs).symm)

theorem map_lift'_eq {m : Œ≤ ‚Üí Œ≥} (hh : Monotone h) : map m (f.lift' h) = f.lift' (Image m ‚àò h) :=
  calc
    map m (f.lift' h) = f.lift (map m ‚àò ùìü ‚àò h) := map_lift_eq <| monotone_principal.comp hh
    _ = f.lift' (Image m ‚àò h) := by
      simp only [(¬∑ ‚àò ¬∑), Filter.lift', map_principal, eq_self_iff_true]
    

theorem map_lift'_eq2 {g : Set Œ≤ ‚Üí Set Œ≥} {m : Œ± ‚Üí Œ≤} (hg : Monotone g) : (map m f).lift' g = f.lift' (g ‚àò Image m) :=
  map_lift_eq2 <| monotone_principal.comp hg

theorem comap_lift'_eq {m : Œ≥ ‚Üí Œ≤} (hh : Monotone h) : comap m (f.lift' h) = f.lift' (Preimage m ‚àò h) :=
  calc
    comap m (f.lift' h) = f.lift (comap m ‚àò ùìü ‚àò h) := comap_lift_eq <| monotone_principal.comp hh
    _ = f.lift' (Preimage m ‚àò h) := by
      simp only [(¬∑ ‚àò ¬∑), Filter.lift', comap_principal, eq_self_iff_true]
    

theorem comap_lift'_eq2 {m : Œ≤ ‚Üí Œ±} {g : Set Œ≤ ‚Üí Set Œ≥} (hg : Monotone g) :
    (comap m f).lift' g = f.lift' (g ‚àò Preimage m) :=
  comap_lift_eq2 <| monotone_principal.comp hg

theorem lift'_principal {s : Set Œ±} (hh : Monotone h) : (ùìü s).lift' h = ùìü (h s) :=
  lift_principal <| monotone_principal.comp hh

theorem lift'_pure {a : Œ±} (hh : Monotone h) : (pure a : Filter Œ±).lift' h = ùìü (h {a}) := by
  rw [‚Üê principal_singleton, lift'_principal hh]

theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) := by
  rw [‚Üê principal_empty, lift'_principal hh]

theorem principal_le_lift' {t : Set Œ≤} (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, t ‚äÜ h s) : ùìü t ‚â§ f.lift' h :=
  le_infi fun s => le_infi fun hs => principal_mono.mpr (hh s hs)

theorem monotone_lift' [Preorder‚Çì Œ≥] {f : Œ≥ ‚Üí Filter Œ±} {g : Œ≥ ‚Üí Set Œ± ‚Üí Set Œ≤} (hf : Monotone f) (hg : Monotone g) :
    Monotone fun c => (f c).lift' (g c) := fun a b h => lift'_mono (hf h) (hg h)

theorem lift_lift'_assoc {g : Set Œ± ‚Üí Set Œ≤} {h : Set Œ≤ ‚Üí Filter Œ≥} (hg : Monotone g) (hh : Monotone h) :
    (f.lift' g).lift h = f.lift fun s => h (g s) :=
  calc
    (f.lift' g).lift h = f.lift fun s => (ùìü (g s)).lift h := lift_assoc (monotone_principal.comp hg)
    _ = f.lift fun s => h (g s) := by
      simp only [lift_principal, hh, eq_self_iff_true]
    

theorem lift'_lift'_assoc {g : Set Œ± ‚Üí Set Œ≤} {h : Set Œ≤ ‚Üí Set Œ≥} (hg : Monotone g) (hh : Monotone h) :
    (f.lift' g).lift' h = f.lift' fun s => h (g s) :=
  lift_lift'_assoc hg (monotone_principal.comp hh)

theorem lift'_lift_assoc {g : Set Œ± ‚Üí Filter Œ≤} {h : Set Œ≤ ‚Üí Set Œ≥} (hg : Monotone g) :
    (f.lift g).lift' h = f.lift fun s => (g s).lift' h :=
  lift_assoc hg

theorem lift_lift'_same_le_lift' {g : Set Œ± ‚Üí Set Œ± ‚Üí Set Œ≤} :
    (f.lift fun s => f.lift' (g s)) ‚â§ f.lift' fun s => g s s :=
  lift_lift_same_le_lift

theorem lift_lift'_same_eq_lift' {g : Set Œ± ‚Üí Set Œ± ‚Üí Set Œ≤} (hg‚ÇÅ : ‚àÄ s, Monotone fun t => g s t)
    (hg‚ÇÇ : ‚àÄ t, Monotone fun s => g s t) : (f.lift fun s => f.lift' (g s)) = f.lift' fun s => g s s :=
  lift_lift_same_eq_lift (fun s => monotone_principal.comp (hg‚ÇÅ s)) fun t => monotone_principal.comp (hg‚ÇÇ t)

theorem lift'_inf_principal_eq {h : Set Œ± ‚Üí Set Œ≤} {s : Set Œ≤} : f.lift' h‚äìùìü s = f.lift' fun t => h t ‚à© s := by
  simp only [Filter.lift', Filter.lift, (¬∑ ‚àò ¬∑), ‚Üê inf_principal, infi_subtype', ‚Üê infi_inf]

theorem lift'_ne_bot_iff (hh : Monotone h) : NeBot (f.lift' h) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, (h s).Nonempty :=
  calc
    NeBot (f.lift' h) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, NeBot (ùìü (h s)) := lift_ne_bot_iff (monotone_principal.comp hh)
    _ ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, (h s).Nonempty := by
      simp only [principal_ne_bot_iff]
    

@[simp]
theorem lift'_id {f : Filter Œ±} : f.lift' id = f :=
  lift_principal2

theorem le_lift' {f : Filter Œ±} {h : Set Œ± ‚Üí Set Œ≤} {g : Filter Œ≤} (h_le : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h s ‚àà g) : g ‚â§ f.lift' h :=
  le_infi fun s =>
    le_infi fun hs => by
      simpa only [h_le, le_principal_iff, Function.comp_app] using h_le s hs

theorem lift_infi' {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} [Nonempty Œπ] (hf : Directed (¬∑ ‚â• ¬∑) f) (hg : Monotone g) :
    (infi f).lift g = ‚®Ö i, (f i).lift g :=
  le_antisymm‚Çì (le_infi fun i => lift_mono (infi_le _ _) le_rfl) fun s => by
    rw [mem_lift_sets hg]
    simp only [exists_imp_distrib, mem_infi_of_directed hf]
    exact fun t i ht hs => mem_infi_of_mem i <| mem_lift ht hs

theorem lift'_infi {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Set Œ≤} [Nonempty Œπ] (hg : ‚àÄ {s t}, g s ‚à© g t = g (s ‚à© t)) :
    (infi f).lift' g = ‚®Ö i, (f i).lift' g :=
  lift_infi fun s t => by
    simp only [principal_eq_iff_eq, inf_principal, (¬∑ ‚àò ¬∑), hg]

theorem lift'_inf (f g : Filter Œ±) {s : Set Œ± ‚Üí Set Œ≤} (hs : ‚àÄ {t‚ÇÅ t‚ÇÇ}, s t‚ÇÅ ‚à© s t‚ÇÇ = s (t‚ÇÅ ‚à© t‚ÇÇ)) :
    (f‚äìg).lift' s = f.lift' s‚äìg.lift' s := by
  have : (‚®Ö b : Bool, cond b f g).lift' s = ‚®Ö b : Bool, (cond b f g).lift' s := lift'_infi @hs
  simpa only [infi_bool_eq]

theorem comap_eq_lift' {f : Filter Œ≤} {m : Œ± ‚Üí Œ≤} : comap m f = f.lift' (Preimage m) :=
  Filter.ext fun s => (mem_lift'_sets monotone_preimage).symm

theorem lift'_infi_powerset {f : Œπ ‚Üí Filter Œ±} : (infi f).lift' Powerset = ‚®Ö i, (f i).lift' Powerset := by
  cases' is_empty_or_nonempty Œπ
  ¬∑ rw [infi_of_empty f, infi_of_empty, lift'_top, powerset_univ, principal_univ]
    
  ¬∑ exact lift'_infi fun _ _ => (powerset_inter _ _).symm
    

theorem lift'_inf_powerset (f g : Filter Œ±) : (f‚äìg).lift' Powerset = f.lift' Powerset‚äìg.lift' Powerset :=
  (lift'_inf f g) fun _ _ => (powerset_inter _ _).symm

-- ././Mathport/Syntax/Translate/Basic.lean:598:2: warning: expanding binder collection (t ¬´expr ‚äÜ ¬ª s)
theorem eventually_lift'_powerset {f : Filter Œ±} {p : Set Œ± ‚Üí Prop} :
    (‚àÄ·∂† s in f.lift' Powerset, p s) ‚Üî ‚àÉ s ‚àà f, ‚àÄ t _ : t ‚äÜ s, p t :=
  eventually_lift'_iff monotone_powerset

theorem eventually_lift'_powerset' {f : Filter Œ±} {p : Set Œ± ‚Üí Prop} (hp : ‚àÄ ‚¶És t‚¶Ñ, s ‚äÜ t ‚Üí p t ‚Üí p s) :
    (‚àÄ·∂† s in f.lift' Powerset, p s) ‚Üî ‚àÉ s ‚àà f, p s :=
  eventually_lift'_powerset.trans <| exists‚ÇÇ_congr‚Çì fun s hsf => ‚ü®fun H => H s (Subset.refl s), fun hs t ht => hp ht hs‚ü©

instance lift'_powerset_ne_bot (f : Filter Œ±) : NeBot (f.lift' Powerset) :=
  (lift'_ne_bot_iff monotone_powerset).2 fun _ _ => powerset_nonempty

theorem tendsto_lift'_powerset_mono {la : Filter Œ±} {lb : Filter Œ≤} {s t : Œ± ‚Üí Set Œ≤}
    (ht : Tendsto t la (lb.lift' Powerset)) (hst : ‚àÄ·∂† x in la, s x ‚äÜ t x) : Tendsto s la (lb.lift' Powerset) := by
  simp only [Filter.lift', Filter.lift, (¬∑ ‚àò ¬∑), tendsto_infi, tendsto_principal] at ht‚ä¢
  exact fun u hu => (ht u hu).mp (hst.mono fun a hst ht => subset.trans hst ht)

@[simp]
theorem eventually_lift'_powerset_forall {f : Filter Œ±} {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† s in f.lift' Powerset, ‚àÄ, ‚àÄ x ‚àà s, ‚àÄ, p x) ‚Üî ‚àÄ·∂† x in f, p x :=
  Iff.trans (eventually_lift'_powerset' fun s t hst ht x hx => ht x (hst hx)) exists_mem_subset_iff

alias eventually_lift'_powerset_forall ‚Üî Filter.Eventually.of_lift'_powerset Filter.Eventually.lift'_powerset

@[simp]
theorem eventually_lift'_powerset_eventually {f g : Filter Œ±} {p : Œ± ‚Üí Prop} :
    (‚àÄ·∂† s in f.lift' Powerset, ‚àÄ·∂† x in g, x ‚àà s ‚Üí p x) ‚Üî ‚àÄ·∂† x in f‚äìg, p x :=
  calc
    _ ‚Üî ‚àÉ s ‚àà f, ‚àÄ·∂† x in g, x ‚àà s ‚Üí p x :=
      eventually_lift'_powerset' fun s t hst ht => ht.mono fun x hx hs => hx (hst hs)
    _ ‚Üî ‚àÉ s ‚àà f, ‚àÉ t ‚àà g, ‚àÄ x, x ‚àà t ‚Üí x ‚àà s ‚Üí p x := by
      simp only [eventually_iff_exists_mem]
    _ ‚Üî ‚àÄ·∂† x in f‚äìg, p x := by
      simp only [eventually_inf, and_comm, mem_inter_iff, ‚Üê and_imp]
    

end Lift'

section Prod

variable {f : Filter Œ±}

theorem prod_def {f : Filter Œ±} {g : Filter Œ≤} : f √ó·∂† g = f.lift fun s => g.lift' fun t => s √óÀ¢ t := by
  have : ‚àÄ s : Set Œ± t : Set Œ≤, ùìü (s √óÀ¢ t) = (ùìü s).comap Prod.fst‚äì(ùìü t).comap Prod.snd := by
    simp only [principal_eq_iff_eq, comap_principal, inf_principal] <;> intros <;> rfl
  simp only [Filter.lift', Function.comp, this, lift_inf, lift_const, lift_inf]
  rw [‚Üê comap_lift_eq monotone_principal, ‚Üê comap_lift_eq monotone_principal]
  simp only [Filter.prod, lift_principal2, eq_self_iff_true]

theorem prod_same_eq : f √ó·∂† f = f.lift' fun t : Set Œ± => t √óÀ¢ t := by
  rw [prod_def] <;>
    exact
      lift_lift'_same_eq_lift' (fun s => Set.monotone_prod monotone_const monotone_id) fun t =>
        Set.monotone_prod monotone_id monotone_const

theorem mem_prod_same_iff {s : Set (Œ± √ó Œ±)} : s ‚àà f √ó·∂† f ‚Üî ‚àÉ t ‚àà f, t √óÀ¢ t ‚äÜ s := by
  rw [prod_same_eq, mem_lift'_sets] <;> exact Set.monotone_prod monotone_id monotone_id

theorem tendsto_prod_self_iff {f : Œ± √ó Œ± ‚Üí Œ≤} {x : Filter Œ±} {y : Filter Œ≤} :
    Filter.Tendsto f (x √ó·∂† x) y ‚Üî ‚àÄ, ‚àÄ W ‚àà y, ‚àÄ, ‚àÉ U ‚àà x, ‚àÄ x x' : Œ±, x ‚àà U ‚Üí x' ‚àà U ‚Üí f (x, x') ‚àà W := by
  simp only [tendsto_def, mem_prod_same_iff, prod_sub_preimage_iff, exists_prop, iff_self‚Çì]

variable {Œ±‚ÇÅ : Type _} {Œ±‚ÇÇ : Type _} {Œ≤‚ÇÅ : Type _} {Œ≤‚ÇÇ : Type _}

theorem prod_lift_lift {f‚ÇÅ : Filter Œ±‚ÇÅ} {f‚ÇÇ : Filter Œ±‚ÇÇ} {g‚ÇÅ : Set Œ±‚ÇÅ ‚Üí Filter Œ≤‚ÇÅ} {g‚ÇÇ : Set Œ±‚ÇÇ ‚Üí Filter Œ≤‚ÇÇ}
    (hg‚ÇÅ : Monotone g‚ÇÅ) (hg‚ÇÇ : Monotone g‚ÇÇ) :
    f‚ÇÅ.lift g‚ÇÅ √ó·∂† f‚ÇÇ.lift g‚ÇÇ = f‚ÇÅ.lift fun s => f‚ÇÇ.lift fun t => g‚ÇÅ s √ó·∂† g‚ÇÇ t := by
  simp only [prod_def]
  rw [lift_assoc]
  apply congr_arg‚Çì
  funext x
  rw [lift_comm]
  apply congr_arg‚Çì
  funext y
  rw [lift'_lift_assoc]
  exact hg‚ÇÇ
  exact hg‚ÇÅ

theorem prod_lift'_lift' {f‚ÇÅ : Filter Œ±‚ÇÅ} {f‚ÇÇ : Filter Œ±‚ÇÇ} {g‚ÇÅ : Set Œ±‚ÇÅ ‚Üí Set Œ≤‚ÇÅ} {g‚ÇÇ : Set Œ±‚ÇÇ ‚Üí Set Œ≤‚ÇÇ}
    (hg‚ÇÅ : Monotone g‚ÇÅ) (hg‚ÇÇ : Monotone g‚ÇÇ) :
    f‚ÇÅ.lift' g‚ÇÅ √ó·∂† f‚ÇÇ.lift' g‚ÇÇ = f‚ÇÅ.lift fun s => f‚ÇÇ.lift' fun t => g‚ÇÅ s √óÀ¢ g‚ÇÇ t := by
  rw [prod_def, lift_lift'_assoc]
  apply congr_arg‚Çì
  funext x
  rw [lift'_lift'_assoc]
  exact hg‚ÇÇ
  exact Set.monotone_prod monotone_const monotone_id
  exact hg‚ÇÅ
  exact monotone_lift' monotone_const <| monotone_lam fun x => Set.monotone_prod monotone_id monotone_const

end Prod

end Filter

