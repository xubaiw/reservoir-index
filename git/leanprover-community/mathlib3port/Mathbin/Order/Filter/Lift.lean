/-
Copyright (c) 2019 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl
-/
import Mathbin.Order.Filter.Bases

/-!
# Lift filters along filter and set functions
-/


open Set

open Classical Filter

namespace Filter

variable {Œ± : Type _} {Œ≤ : Type _} {Œ≥ : Type _} {Œπ : Sort _}

section lift

/-- A variant on `bind` using a function `g` taking a set instead of a member of `Œ±`.
This is essentially a push-forward along a function mapping each set to a filter. -/
protected def lift (f : Filter Œ±) (g : Set Œ± ‚Üí Filter Œ≤) :=
  ‚®Ö s ‚àà f, g s

variable {f f‚ÇÅ f‚ÇÇ : Filter Œ±} {g g‚ÇÅ g‚ÇÇ : Set Œ± ‚Üí Filter Œ≤}

@[simp]
theorem lift_top (g : Set Œ± ‚Üí Filter Œ≤) : (‚ä§ : Filter Œ±).lift g = g Univ := by
  simp [‚Üê Filter.lift]

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type, see `filter.has_basis.lift`.
This lemma states the corresponding `mem_iff` statement without using a sigma type. -/
theorem HasBasis.mem_lift_iff {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {f : Filter Œ±} (hf : f.HasBasis p s) {Œ≤ : Œπ ‚Üí Type _}
    {pg : ‚àÄ i, Œ≤ i ‚Üí Prop} {sg : ‚àÄ i, Œ≤ i ‚Üí Set Œ≥} {g : Set Œ± ‚Üí Filter Œ≥} (hg : ‚àÄ i, (g <| s i).HasBasis (pg i) (sg i))
    (gm : Monotone g) {s : Set Œ≥} : s ‚àà f.lift g ‚Üî ‚àÉ (i : Œπ)(hi : p i)(x : Œ≤ i)(hx : pg i x), sg i x ‚äÜ s := by
  refine' (mem_binfi_of_directed _ ‚ü®univ, univ_sets _‚ü©).trans _
  ¬∑ intro t‚ÇÅ ht‚ÇÅ t‚ÇÇ ht‚ÇÇ
    exact ‚ü®t‚ÇÅ ‚à© t‚ÇÇ, inter_mem ht‚ÇÅ ht‚ÇÇ, gm <| inter_subset_left _ _, gm <| inter_subset_right _ _‚ü©
    
  ¬∑ simp only [(hg _).mem_iff]
    exact hf.exists_iff fun t‚ÇÅ t‚ÇÇ ht H => gm ht H
    

/-- If `(p : Œπ ‚Üí Prop, s : Œπ ‚Üí set Œ±)` is a basis of a filter `f`, `g` is a monotone function
`set Œ± ‚Üí filter Œ≥`, and for each `i`, `(pg : Œ≤ i ‚Üí Prop, sg : Œ≤ i ‚Üí set Œ±)` is a basis
of the filter `g (s i)`, then `(Œª (i : Œπ) (x : Œ≤ i), p i ‚àß pg i x, Œª (i : Œπ) (x : Œ≤ i), sg i x)`
is a basis of the filter `f.lift g`.

This basis is parametrized by `i : Œπ` and `x : Œ≤ i`, so in order to formulate this fact using
`has_basis` one has to use `Œ£ i, Œ≤ i` as the index type. See also `filter.has_basis.mem_lift_iff`
for the corresponding `mem_iff` statement formulated without using a sigma type. -/
theorem HasBasis.lift {Œπ} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set Œ±} {f : Filter Œ±} (hf : f.HasBasis p s) {Œ≤ : Œπ ‚Üí Type _}
    {pg : ‚àÄ i, Œ≤ i ‚Üí Prop} {sg : ‚àÄ i, Œ≤ i ‚Üí Set Œ≥} {g : Set Œ± ‚Üí Filter Œ≥} (hg : ‚àÄ i, (g <| s i).HasBasis (pg i) (sg i))
    (gm : Monotone g) : (f.lift g).HasBasis (fun i : Œ£i, Œ≤ i => p i.1 ‚àß pg i.1 i.2) fun i : Œ£i, Œ≤ i => sg i.1 i.2 := by
  refine' ‚ü®fun t => (hf.mem_lift_iff hg gm).trans _‚ü©
  simp [‚Üê Sigma.exists, ‚Üê and_assoc, ‚Üê exists_and_distrib_left]

theorem mem_lift_sets (hg : Monotone g) {s : Set Œ≤} : s ‚àà f.lift g ‚Üî ‚àÉ t ‚àà f, s ‚àà g t :=
  (f.basis_sets.mem_lift_iff (fun s => (g s).basis_sets) hg).trans <| by
    simp only [‚Üê id, ‚Üê exists_mem_subset_iff]

theorem mem_lift {s : Set Œ≤} {t : Set Œ±} (ht : t ‚àà f) (hs : s ‚àà g t) : s ‚àà f.lift g :=
  le_principal_iff.mp <| show f.lift g ‚â§ ùìü s from infi_le_of_le t <| infi_le_of_le ht <| le_principal_iff.mpr hs

theorem lift_le {f : Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} {h : Filter Œ≤} {s : Set Œ±} (hs : s ‚àà f) (hg : g s ‚â§ h) :
    f.lift g ‚â§ h :=
  infi‚ÇÇ_le_of_le s hs hg

theorem le_lift {f : Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} {h : Filter Œ≤} (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h ‚â§ g s) : h ‚â§ f.lift g :=
  le_infi‚ÇÇ hh

theorem lift_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hg : g‚ÇÅ ‚â§ g‚ÇÇ) : f‚ÇÅ.lift g‚ÇÅ ‚â§ f‚ÇÇ.lift g‚ÇÇ :=
  infi_mono fun s => infi_mono' fun hs => ‚ü®hf hs, hg s‚ü©

theorem lift_mono' (hg : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, g‚ÇÅ s ‚â§ g‚ÇÇ s) : f.lift g‚ÇÅ ‚â§ f.lift g‚ÇÇ :=
  infi‚ÇÇ_mono hg

theorem tendsto_lift {m : Œ≥ ‚Üí Œ≤} {l : Filter Œ≥} : Tendsto m l (f.lift g) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, Tendsto m l (g s) := by
  simp only [‚Üê Filter.lift, ‚Üê tendsto_infi]

theorem map_lift_eq {m : Œ≤ ‚Üí Œ≥} (hg : Monotone g) : map m (f.lift g) = f.lift (map m ‚àò g) :=
  have : Monotone (map m ‚àò g) := map_mono.comp hg
  Filter.ext fun s => by
    simp only [‚Üê mem_lift_sets hg, ‚Üê mem_lift_sets this, ‚Üê exists_prop, ‚Üê mem_map, ‚Üê Function.comp_app]

theorem comap_lift_eq {m : Œ≥ ‚Üí Œ≤} : comap m (f.lift g) = f.lift (comap m ‚àò g) := by
  simp only [‚Üê Filter.lift, ‚Üê comap_infi]

theorem comap_lift_eq2 {m : Œ≤ ‚Üí Œ±} {g : Set Œ≤ ‚Üí Filter Œ≥} (hg : Monotone g) :
    (comap m f).lift g = f.lift (g ‚àò Preimage m) :=
  le_antisymm‚Çì (le_infi‚ÇÇ fun s hs => infi‚ÇÇ_le (m ‚Åª¬π' s) ‚ü®s, hs, Subset.rfl‚ü©)
    (le_infi‚ÇÇ fun s ‚ü®s', hs', (h_sub : m ‚Åª¬π' s' ‚äÜ s)‚ü© => infi‚ÇÇ_le_of_le s' hs' <| hg h_sub)

theorem map_lift_eq2 {g : Set Œ≤ ‚Üí Filter Œ≥} {m : Œ± ‚Üí Œ≤} (hg : Monotone g) : (map m f).lift g = f.lift (g ‚àò Image m) :=
  le_antisymm‚Çì
    (infi_mono' fun s =>
      ‚ü®Image m s, infi_mono' fun hs => ‚ü®(f.sets_of_superset hs) fun a h => mem_image_of_mem _ h, le_rfl‚ü©‚ü©)
    (infi_mono' fun t =>
      ‚ü®Preimage m t,
        infi_mono' fun ht =>
          ‚ü®ht,
            hg fun x => fun h : x ‚àà m '' Preimage m t =>
              let ‚ü®y, hy, h_eq‚ü© := h
              show x ‚àà t from h_eq ‚ñ∏ hy‚ü©‚ü©)

theorem lift_comm {g : Filter Œ≤} {h : Set Œ± ‚Üí Set Œ≤ ‚Üí Filter Œ≥} :
    (f.lift fun s => g.lift (h s)) = g.lift fun t => f.lift fun s => h s t :=
  le_antisymm‚Çì
    (le_infi fun i =>
      le_infi fun hi =>
        le_infi fun j => le_infi fun hj => infi_le_of_le j <| infi_le_of_le hj <| infi_le_of_le i <| infi_le _ hi)
    (le_infi fun i =>
      le_infi fun hi =>
        le_infi fun j => le_infi fun hj => infi_le_of_le j <| infi_le_of_le hj <| infi_le_of_le i <| infi_le _ hi)

theorem lift_assoc {h : Set Œ≤ ‚Üí Filter Œ≥} (hg : Monotone g) : (f.lift g).lift h = f.lift fun s => (g s).lift h :=
  le_antisymm‚Çì
    (le_infi fun s =>
      le_infi fun hs =>
        le_infi fun t => le_infi fun ht => infi_le_of_le t <| infi_le _ <| (mem_lift_sets hg).mpr ‚ü®_, hs, ht‚ü©)
    (le_infi fun t =>
      le_infi fun ht =>
        let ‚ü®s, hs, h'‚ü© := (mem_lift_sets hg).mp ht
        infi_le_of_le s <| infi_le_of_le hs <| infi_le_of_le t <| infi_le _ h')

theorem lift_lift_same_le_lift {g : Set Œ± ‚Üí Set Œ± ‚Üí Filter Œ≤} :
    (f.lift fun s => f.lift (g s)) ‚â§ f.lift fun s => g s s :=
  le_infi fun s => le_infi fun hs => infi_le_of_le s <| infi_le_of_le hs <| infi_le_of_le s <| infi_le _ hs

theorem lift_lift_same_eq_lift {g : Set Œ± ‚Üí Set Œ± ‚Üí Filter Œ≤} (hg‚ÇÅ : ‚àÄ s, Monotone fun t => g s t)
    (hg‚ÇÇ : ‚àÄ t, Monotone fun s => g s t) : (f.lift fun s => f.lift (g s)) = f.lift fun s => g s s :=
  le_antisymm‚Çì lift_lift_same_le_lift
    (le_infi fun s =>
      le_infi fun hs =>
        le_infi fun t =>
          le_infi fun ht =>
            infi_le_of_le (s ‚à© t) <|
              infi_le_of_le (inter_mem hs ht) <|
                calc
                  g (s ‚à© t) (s ‚à© t) ‚â§ g s (s ‚à© t) := hg‚ÇÇ (s ‚à© t) (inter_subset_left _ _)
                  _ ‚â§ g s t := hg‚ÇÅ s (inter_subset_right _ _)
                  )

theorem lift_principal {s : Set Œ±} (hg : Monotone g) : (ùìü s).lift g = g s :=
  le_antisymm‚Çì (infi_le_of_le s <| infi_le _ <| Subset.refl _) (le_infi fun t => le_infi fun hi => hg hi)

theorem monotone_lift [Preorder‚Çì Œ≥] {f : Œ≥ ‚Üí Filter Œ±} {g : Œ≥ ‚Üí Set Œ± ‚Üí Filter Œ≤} (hf : Monotone f) (hg : Monotone g) :
    Monotone fun c => (f c).lift (g c) := fun a b h => lift_mono (hf h) (hg h)

theorem lift_ne_bot_iff (hm : Monotone g) : (ne_bot <| f.lift g) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, NeBot (g s) := by
  rw [Filter.lift, infi_subtype', infi_ne_bot_iff_of_directed', Subtype.forall']
  ¬∑ rintro ‚ü®s, hs‚ü© ‚ü®t, ht‚ü©
    exact ‚ü®‚ü®s ‚à© t, inter_mem hs ht‚ü©, hm (inter_subset_left s t), hm (inter_subset_right s t)‚ü©
    

@[simp]
theorem lift_const {f : Filter Œ±} {g : Filter Œ≤} : (f.lift fun x => g) = g :=
  le_antisymm‚Çì (lift_le univ_mem <| le_refl‚Çì g) (le_lift fun s hs => le_refl‚Çì g)

@[simp]
theorem lift_inf {f : Filter Œ±} {g h : Set Œ± ‚Üí Filter Œ≤} : (f.lift fun x => g x‚äìh x) = f.lift g‚äìf.lift h := by
  simp only [‚Üê Filter.lift, ‚Üê infi_inf_eq, ‚Üê eq_self_iff_true]

@[simp]
theorem lift_principal2 {f : Filter Œ±} : f.lift ùìü = f :=
  le_antisymm‚Çì (fun s hs => mem_lift hs (mem_principal_self s))
    (le_infi fun s =>
      le_infi fun hs => by
        simp only [‚Üê hs, ‚Üê le_principal_iff])

theorem lift_infi_le {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} : (infi f).lift g ‚â§ ‚®Ö i, (f i).lift g :=
  le_infi fun i => lift_mono (infi_le _ _) le_rfl

theorem lift_infi [Nonempty Œπ] {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} (hg : ‚àÄ s t, g (s ‚à© t) = g s‚äìg t) :
    (infi f).lift g = ‚®Ö i, (f i).lift g := by
  refine' lift_infi_le.antisymm fun s => _
  have H : ‚àÄ, ‚àÄ t ‚àà infi f, ‚àÄ, (‚®Ö i, (f i).lift g) ‚â§ g t := by
    intro t ht
    refine' infi_sets_induct ht _ fun i s t hs ht => _
    ¬∑ inhabit Œπ
      exact infi‚ÇÇ_le_of_le default univ (infi_le _ univ_mem)
      
    ¬∑ rw [hg]
      exact le_inf (infi‚ÇÇ_le_of_le i s <| infi_le _ hs) ht
      
  simp only [‚Üê mem_lift_sets (Monotone.of_map_inf hg), ‚Üê exists_imp_distrib]
  exact fun t ht hs => H t ht hs

theorem lift_infi_of_directed [Nonempty Œπ] {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} (hf : Directed (¬∑ ‚â• ¬∑) f)
    (hg : Monotone g) : (infi f).lift g = ‚®Ö i, (f i).lift g :=
  lift_infi_le.antisymm fun s => by
    simp only [‚Üê mem_lift_sets hg, ‚Üê exists_imp_distrib, ‚Üê mem_infi_of_directed hf]
    exact fun t i ht hs => mem_infi_of_mem i <| mem_lift ht hs

theorem lift_infi_of_map_univ {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Filter Œ≤} (hg : ‚àÄ s t, g (s ‚à© t) = g s‚äìg t)
    (hg' : g Univ = ‚ä§) : (infi f).lift g = ‚®Ö i, (f i).lift g := by
  cases is_empty_or_nonempty Œπ
  ¬∑ simp [‚Üê infi_of_empty, ‚Üê hg']
    
  ¬∑ exact lift_infi hg
    

end lift

section Lift'

/-- Specialize `lift` to functions `set Œ± ‚Üí set Œ≤`. This can be viewed as a generalization of `map`.
This is essentially a push-forward along a function mapping each set to a set. -/
protected def lift' (f : Filter Œ±) (h : Set Œ± ‚Üí Set Œ≤) :=
  f.lift (ùìü ‚àò h)

variable {f f‚ÇÅ f‚ÇÇ : Filter Œ±} {h h‚ÇÅ h‚ÇÇ : Set Œ± ‚Üí Set Œ≤}

@[simp]
theorem lift'_top (h : Set Œ± ‚Üí Set Œ≤) : (‚ä§ : Filter Œ±).lift' h = ùìü (h Univ) :=
  lift_top _

theorem mem_lift' {t : Set Œ±} (ht : t ‚àà f) : h t ‚àà f.lift' h :=
  le_principal_iff.mp <| show f.lift' h ‚â§ ùìü (h t) from infi_le_of_le t <| infi_le_of_le ht <| le_rfl

theorem tendsto_lift' {m : Œ≥ ‚Üí Œ≤} {l : Filter Œ≥} : Tendsto m l (f.lift' h) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, ‚àÄ·∂† a in l, m a ‚àà h s := by
  simp only [‚Üê Filter.lift', ‚Üê tendsto_lift, ‚Üê tendsto_principal]

theorem HasBasis.lift' {Œπ} {p : Œπ ‚Üí Prop} {s} (hf : f.HasBasis p s) (hh : Monotone h) :
    (f.lift' h).HasBasis p (h ‚àò s) := by
  refine' ‚ü®fun t => (hf.mem_lift_iff _ (monotone_principal.comp hh)).trans _‚ü©
  show ‚àÄ i, (ùìü (h (s i))).HasBasis (fun j : Unit => True) fun j : Unit => h (s i)
  exact fun i => has_basis_principal _
  simp only [‚Üê exists_const]

theorem mem_lift'_sets (hh : Monotone h) {s : Set Œ≤} : s ‚àà f.lift' h ‚Üî ‚àÉ t ‚àà f, h t ‚äÜ s :=
  mem_lift_sets <| monotone_principal.comp hh

theorem eventually_lift'_iff (hh : Monotone h) {p : Œ≤ ‚Üí Prop} :
    (‚àÄ·∂† y in f.lift' h, p y) ‚Üî ‚àÉ t ‚àà f, ‚àÄ, ‚àÄ y ‚àà h t, ‚àÄ, p y :=
  mem_lift'_sets hh

theorem lift'_le {f : Filter Œ±} {g : Set Œ± ‚Üí Set Œ≤} {h : Filter Œ≤} {s : Set Œ±} (hs : s ‚àà f) (hg : ùìü (g s) ‚â§ h) :
    f.lift' g ‚â§ h :=
  lift_le hs hg

theorem lift'_mono (hf : f‚ÇÅ ‚â§ f‚ÇÇ) (hh : h‚ÇÅ ‚â§ h‚ÇÇ) : f‚ÇÅ.lift' h‚ÇÅ ‚â§ f‚ÇÇ.lift' h‚ÇÇ :=
  (lift_mono hf) fun s => principal_mono.mpr <| hh s

theorem lift'_mono' (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h‚ÇÅ s ‚äÜ h‚ÇÇ s) : f.lift' h‚ÇÅ ‚â§ f.lift' h‚ÇÇ :=
  infi‚ÇÇ_mono fun s hs => principal_mono.mpr <| hh s hs

theorem lift'_cong (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h‚ÇÅ s = h‚ÇÇ s) : f.lift' h‚ÇÅ = f.lift' h‚ÇÇ :=
  le_antisymm‚Çì (lift'_mono' fun s hs => le_of_eq‚Çì <| hh s hs) (lift'_mono' fun s hs => le_of_eq‚Çì <| (hh s hs).symm)

theorem map_lift'_eq {m : Œ≤ ‚Üí Œ≥} (hh : Monotone h) : map m (f.lift' h) = f.lift' (Image m ‚àò h) :=
  calc
    map m (f.lift' h) = f.lift (map m ‚àò ùìü ‚àò h) := map_lift_eq <| monotone_principal.comp hh
    _ = f.lift' (Image m ‚àò h) := by
      simp only [‚Üê (¬∑ ‚àò ¬∑), ‚Üê Filter.lift', ‚Üê map_principal, ‚Üê eq_self_iff_true]
    

theorem map_lift'_eq2 {g : Set Œ≤ ‚Üí Set Œ≥} {m : Œ± ‚Üí Œ≤} (hg : Monotone g) : (map m f).lift' g = f.lift' (g ‚àò Image m) :=
  map_lift_eq2 <| monotone_principal.comp hg

theorem comap_lift'_eq {m : Œ≥ ‚Üí Œ≤} : comap m (f.lift' h) = f.lift' (Preimage m ‚àò h) := by
  simp only [‚Üê Filter.lift', ‚Üê comap_lift_eq, ‚Üê (¬∑ ‚àò ¬∑), ‚Üê comap_principal]

theorem comap_lift'_eq2 {m : Œ≤ ‚Üí Œ±} {g : Set Œ≤ ‚Üí Set Œ≥} (hg : Monotone g) :
    (comap m f).lift' g = f.lift' (g ‚àò Preimage m) :=
  comap_lift_eq2 <| monotone_principal.comp hg

theorem lift'_principal {s : Set Œ±} (hh : Monotone h) : (ùìü s).lift' h = ùìü (h s) :=
  lift_principal <| monotone_principal.comp hh

theorem lift'_pure {a : Œ±} (hh : Monotone h) : (pure a : Filter Œ±).lift' h = ùìü (h {a}) := by
  rw [‚Üê principal_singleton, lift'_principal hh]

theorem lift'_bot (hh : Monotone h) : (‚ä• : Filter Œ±).lift' h = ùìü (h ‚àÖ) := by
  rw [‚Üê principal_empty, lift'_principal hh]

theorem principal_le_lift' {t : Set Œ≤} (hh : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, t ‚äÜ h s) : ùìü t ‚â§ f.lift' h :=
  le_infi fun s => le_infi fun hs => principal_mono.mpr (hh s hs)

theorem monotone_lift' [Preorder‚Çì Œ≥] {f : Œ≥ ‚Üí Filter Œ±} {g : Œ≥ ‚Üí Set Œ± ‚Üí Set Œ≤} (hf : Monotone f) (hg : Monotone g) :
    Monotone fun c => (f c).lift' (g c) := fun a b h => lift'_mono (hf h) (hg h)

theorem lift_lift'_assoc {g : Set Œ± ‚Üí Set Œ≤} {h : Set Œ≤ ‚Üí Filter Œ≥} (hg : Monotone g) (hh : Monotone h) :
    (f.lift' g).lift h = f.lift fun s => h (g s) :=
  calc
    (f.lift' g).lift h = f.lift fun s => (ùìü (g s)).lift h := lift_assoc (monotone_principal.comp hg)
    _ = f.lift fun s => h (g s) := by
      simp only [‚Üê lift_principal, ‚Üê hh, ‚Üê eq_self_iff_true]
    

theorem lift'_lift'_assoc {g : Set Œ± ‚Üí Set Œ≤} {h : Set Œ≤ ‚Üí Set Œ≥} (hg : Monotone g) (hh : Monotone h) :
    (f.lift' g).lift' h = f.lift' fun s => h (g s) :=
  lift_lift'_assoc hg (monotone_principal.comp hh)

theorem lift'_lift_assoc {g : Set Œ± ‚Üí Filter Œ≤} {h : Set Œ≤ ‚Üí Set Œ≥} (hg : Monotone g) :
    (f.lift g).lift' h = f.lift fun s => (g s).lift' h :=
  lift_assoc hg

theorem lift_lift'_same_le_lift' {g : Set Œ± ‚Üí Set Œ± ‚Üí Set Œ≤} :
    (f.lift fun s => f.lift' (g s)) ‚â§ f.lift' fun s => g s s :=
  lift_lift_same_le_lift

theorem lift_lift'_same_eq_lift' {g : Set Œ± ‚Üí Set Œ± ‚Üí Set Œ≤} (hg‚ÇÅ : ‚àÄ s, Monotone fun t => g s t)
    (hg‚ÇÇ : ‚àÄ t, Monotone fun s => g s t) : (f.lift fun s => f.lift' (g s)) = f.lift' fun s => g s s :=
  lift_lift_same_eq_lift (fun s => monotone_principal.comp (hg‚ÇÅ s)) fun t => monotone_principal.comp (hg‚ÇÇ t)

theorem lift'_inf_principal_eq {h : Set Œ± ‚Üí Set Œ≤} {s : Set Œ≤} : f.lift' h‚äìùìü s = f.lift' fun t => h t ‚à© s := by
  simp only [‚Üê Filter.lift', ‚Üê Filter.lift, ‚Üê (¬∑ ‚àò ¬∑), inf_principal, ‚Üê infi_subtype', infi_inf]

theorem lift'_ne_bot_iff (hh : Monotone h) : NeBot (f.lift' h) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, (h s).Nonempty :=
  calc
    NeBot (f.lift' h) ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, NeBot (ùìü (h s)) := lift_ne_bot_iff (monotone_principal.comp hh)
    _ ‚Üî ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, (h s).Nonempty := by
      simp only [‚Üê principal_ne_bot_iff]
    

@[simp]
theorem lift'_id {f : Filter Œ±} : f.lift' id = f :=
  lift_principal2

theorem le_lift' {f : Filter Œ±} {h : Set Œ± ‚Üí Set Œ≤} {g : Filter Œ≤} (h_le : ‚àÄ, ‚àÄ s ‚àà f, ‚àÄ, h s ‚àà g) : g ‚â§ f.lift' h :=
  le_infi fun s =>
    le_infi fun hs => by
      simpa only [‚Üê h_le, ‚Üê le_principal_iff, ‚Üê Function.comp_app] using h_le s hs

theorem lift'_infi [Nonempty Œπ] {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Set Œ≤} (hg : ‚àÄ s t, g (s ‚à© t) = g s ‚à© g t) :
    (infi f).lift' g = ‚®Ö i, (f i).lift' g :=
  lift_infi fun s t => by
    rw [inf_principal, (¬∑ ‚àò ¬∑), ‚Üê hg]

theorem lift'_infi_of_map_univ {f : Œπ ‚Üí Filter Œ±} {g : Set Œ± ‚Üí Set Œ≤} (hg : ‚àÄ {s t}, g (s ‚à© t) = g s ‚à© g t)
    (hg' : g Univ = univ) : (infi f).lift' g = ‚®Ö i, (f i).lift' g :=
  lift_infi_of_map_univ
    (fun s t => by
      rw [inf_principal, (¬∑ ‚àò ¬∑), ‚Üê hg])
    (by
      rw [Function.comp_app, hg', principal_univ])

theorem lift'_inf (f g : Filter Œ±) {s : Set Œ± ‚Üí Set Œ≤} (hs : ‚àÄ t‚ÇÅ t‚ÇÇ, s (t‚ÇÅ ‚à© t‚ÇÇ) = s t‚ÇÅ ‚à© s t‚ÇÇ) :
    (f‚äìg).lift' s = f.lift' s‚äìg.lift' s := by
  have : (‚®Ö b : Bool, cond b f g).lift' s = ‚®Ö b : Bool, (cond b f g).lift' s := lift'_infi @hs
  simpa only [‚Üê infi_bool_eq]

theorem lift'_inf_le (f g : Filter Œ±) (s : Set Œ± ‚Üí Set Œ≤) : (f‚äìg).lift' s ‚â§ f.lift' s‚äìg.lift' s :=
  le_inf (lift'_mono inf_le_left le_rfl) (lift'_mono inf_le_right le_rfl)

theorem comap_eq_lift' {f : Filter Œ≤} {m : Œ± ‚Üí Œ≤} : comap m f = f.lift' (Preimage m) :=
  Filter.ext fun s => (mem_lift'_sets monotone_preimage).symm

end Lift'

section Prod

variable {f : Filter Œ±}

theorem prod_def {f : Filter Œ±} {g : Filter Œ≤} : f √ó·∂† g = f.lift fun s => g.lift' fun t => s √óÀ¢ t := by
  have : ‚àÄ s : Set Œ± t : Set Œ≤, ùìü (s √óÀ¢ t) = (ùìü s).comap Prod.fst‚äì(ùìü t).comap Prod.snd := by
    simp only [‚Üê principal_eq_iff_eq, ‚Üê comap_principal, ‚Üê inf_principal] <;> intros <;> rfl
  simp only [‚Üê Filter.lift', ‚Üê Function.comp, ‚Üê this, ‚Üê lift_inf, ‚Üê lift_const, ‚Üê lift_inf]
  rw [‚Üê comap_lift_eq, ‚Üê comap_lift_eq]
  simp only [‚Üê Filter.prod, ‚Üê lift_principal2]

theorem prod_same_eq : f √ó·∂† f = f.lift' fun t : Set Œ± => t √óÀ¢ t := by
  rw [prod_def] <;>
    exact
      lift_lift'_same_eq_lift' (fun s => Set.monotone_prod monotone_const monotone_id) fun t =>
        Set.monotone_prod monotone_id monotone_const

theorem mem_prod_same_iff {s : Set (Œ± √ó Œ±)} : s ‚àà f √ó·∂† f ‚Üî ‚àÉ t ‚àà f, t √óÀ¢ t ‚äÜ s := by
  rw [prod_same_eq, mem_lift'_sets] <;> exact Set.monotone_prod monotone_id monotone_id

theorem tendsto_prod_self_iff {f : Œ± √ó Œ± ‚Üí Œ≤} {x : Filter Œ±} {y : Filter Œ≤} :
    Filter.Tendsto f (x √ó·∂† x) y ‚Üî ‚àÄ, ‚àÄ W ‚àà y, ‚àÄ, ‚àÉ U ‚àà x, ‚àÄ x x' : Œ±, x ‚àà U ‚Üí x' ‚àà U ‚Üí f (x, x') ‚àà W := by
  simp only [‚Üê tendsto_def, ‚Üê mem_prod_same_iff, ‚Üê prod_sub_preimage_iff, ‚Üê exists_prop, ‚Üê iff_self‚Çì]

variable {Œ±‚ÇÅ : Type _} {Œ±‚ÇÇ : Type _} {Œ≤‚ÇÅ : Type _} {Œ≤‚ÇÇ : Type _}

theorem prod_lift_lift {f‚ÇÅ : Filter Œ±‚ÇÅ} {f‚ÇÇ : Filter Œ±‚ÇÇ} {g‚ÇÅ : Set Œ±‚ÇÅ ‚Üí Filter Œ≤‚ÇÅ} {g‚ÇÇ : Set Œ±‚ÇÇ ‚Üí Filter Œ≤‚ÇÇ}
    (hg‚ÇÅ : Monotone g‚ÇÅ) (hg‚ÇÇ : Monotone g‚ÇÇ) :
    f‚ÇÅ.lift g‚ÇÅ √ó·∂† f‚ÇÇ.lift g‚ÇÇ = f‚ÇÅ.lift fun s => f‚ÇÇ.lift fun t => g‚ÇÅ s √ó·∂† g‚ÇÇ t := by
  simp only [‚Üê prod_def]
  rw [lift_assoc]
  apply congr_arg
  funext x
  rw [lift_comm]
  apply congr_arg
  funext y
  rw [lift'_lift_assoc]
  exact hg‚ÇÇ
  exact hg‚ÇÅ

theorem prod_lift'_lift' {f‚ÇÅ : Filter Œ±‚ÇÅ} {f‚ÇÇ : Filter Œ±‚ÇÇ} {g‚ÇÅ : Set Œ±‚ÇÅ ‚Üí Set Œ≤‚ÇÅ} {g‚ÇÇ : Set Œ±‚ÇÇ ‚Üí Set Œ≤‚ÇÇ}
    (hg‚ÇÅ : Monotone g‚ÇÅ) (hg‚ÇÇ : Monotone g‚ÇÇ) :
    f‚ÇÅ.lift' g‚ÇÅ √ó·∂† f‚ÇÇ.lift' g‚ÇÇ = f‚ÇÅ.lift fun s => f‚ÇÇ.lift' fun t => g‚ÇÅ s √óÀ¢ g‚ÇÇ t := by
  rw [prod_def, lift_lift'_assoc]
  apply congr_arg
  funext x
  rw [lift'_lift'_assoc]
  exact hg‚ÇÇ
  exact Set.monotone_prod monotone_const monotone_id
  exact hg‚ÇÅ
  exact monotone_lift' monotone_const <| monotone_lam fun x => Set.monotone_prod monotone_id monotone_const

end Prod

end Filter

