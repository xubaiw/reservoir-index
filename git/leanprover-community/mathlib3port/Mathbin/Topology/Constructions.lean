/-
Copyright (c) 2017 Johannes H√∂lzl. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Johannes H√∂lzl, Mario Carneiro, Patrick Massot
-/
import Mathbin.Topology.Maps
import Mathbin.Topology.LocallyFinite
import Mathbin.Order.Filter.Pi
import Mathbin.Data.Fin.Tuple.Default

/-!
# Constructions of new topological spaces from old ones

This file constructs products, sums, subtypes and quotients of topological spaces
and sets up their basic theory, such as criteria for maps into or out of these
constructions to be continuous; descriptions of the open sets, neighborhood filters,
and generators of these constructions; and their behavior with respect to embeddings
and other specific classes of maps.

## Implementation note

The constructed topologies are defined using induced and coinduced topologies
along with the complete lattice structure on topologies. Their universal properties
(for example, a map `X ‚Üí Y √ó Z` is continuous if and only if both projections
`X ‚Üí Y`, `X ‚Üí Z` are) follow easily using order-theoretic descriptions of
continuity. With more work we can also extract descriptions of the open sets,
neighborhood filters and so on.

## Tags

product, sum, disjoint union, subspace, quotient space

-/


noncomputable section

open TopologicalSpace Set Filter

open Classical TopologicalSpace Filter

universe u v

variable {Œ± : Type u} {Œ≤ : Type v} {Œ≥ Œ¥ Œµ Œ∂ : Type _}

section Constructions

instance {p : Œ± ‚Üí Prop} [t : TopologicalSpace Œ±] : TopologicalSpace (Subtype p) :=
  induced coe t

instance {r : Œ± ‚Üí Œ± ‚Üí Prop} [t : TopologicalSpace Œ±] : TopologicalSpace (Quot r) :=
  coinduced (Quot.mk r) t

instance {s : Setoid‚Çì Œ±} [t : TopologicalSpace Œ±] : TopologicalSpace (Quotient‚Çì s) :=
  coinduced Quotient‚Çì.mk t

instance [t‚ÇÅ : TopologicalSpace Œ±] [t‚ÇÇ : TopologicalSpace Œ≤] : TopologicalSpace (Œ± √ó Œ≤) :=
  induced Prod.fst t‚ÇÅ‚äìinduced Prod.snd t‚ÇÇ

instance [t‚ÇÅ : TopologicalSpace Œ±] [t‚ÇÇ : TopologicalSpace Œ≤] : TopologicalSpace (Sum Œ± Œ≤) :=
  coinduced Sum.inl t‚ÇÅ‚äîcoinduced Sum.inr t‚ÇÇ

instance {Œ≤ : Œ± ‚Üí Type v} [t‚ÇÇ : ‚àÄ a, TopologicalSpace (Œ≤ a)] : TopologicalSpace (Sigma Œ≤) :=
  ‚®Ü a, coinduced (Sigma.mk a) (t‚ÇÇ a)

instance Pi.topologicalSpace {Œ≤ : Œ± ‚Üí Type v} [t‚ÇÇ : ‚àÄ a, TopologicalSpace (Œ≤ a)] : TopologicalSpace (‚àÄ a, Œ≤ a) :=
  ‚®Ö a, induced (fun f => f a) (t‚ÇÇ a)

instance ULift.topologicalSpace [t : TopologicalSpace Œ±] : TopologicalSpace (ULift.{v, u} Œ±) :=
  t.induced ULift.down

/-!
### `additive`, `multiplicative`

The topology on those type synonyms is inherited without change.
-/


section

variable [TopologicalSpace Œ±]

open Additive Multiplicative

instance : TopologicalSpace (Additive Œ±) :=
  ‚ÄπTopologicalSpace Œ±‚Ä∫

instance : TopologicalSpace (Multiplicative Œ±) :=
  ‚ÄπTopologicalSpace Œ±‚Ä∫

instance [DiscreteTopology Œ±] : DiscreteTopology (Additive Œ±) :=
  ‚ÄπDiscreteTopology Œ±‚Ä∫

instance [DiscreteTopology Œ±] : DiscreteTopology (Multiplicative Œ±) :=
  ‚ÄπDiscreteTopology Œ±‚Ä∫

theorem continuous_of_mul : Continuous (ofMul : Œ± ‚Üí Additive Œ±) :=
  continuous_id

theorem continuous_to_mul : Continuous (toMul : Additive Œ± ‚Üí Œ±) :=
  continuous_id

theorem continuous_of_add : Continuous (ofAdd : Œ± ‚Üí Multiplicative Œ±) :=
  continuous_id

theorem continuous_to_add : Continuous (toAdd : Multiplicative Œ± ‚Üí Œ±) :=
  continuous_id

theorem is_open_map_of_mul : IsOpenMap (ofMul : Œ± ‚Üí Additive Œ±) :=
  IsOpenMap.id

theorem is_open_map_to_mul : IsOpenMap (toMul : Additive Œ± ‚Üí Œ±) :=
  IsOpenMap.id

theorem is_open_map_of_add : IsOpenMap (ofAdd : Œ± ‚Üí Multiplicative Œ±) :=
  IsOpenMap.id

theorem is_open_map_to_add : IsOpenMap (toAdd : Multiplicative Œ± ‚Üí Œ±) :=
  IsOpenMap.id

theorem is_closed_map_of_mul : IsClosedMap (ofMul : Œ± ‚Üí Additive Œ±) :=
  IsClosedMap.id

theorem is_closed_map_to_mul : IsClosedMap (toMul : Additive Œ± ‚Üí Œ±) :=
  IsClosedMap.id

theorem is_closed_map_of_add : IsClosedMap (ofAdd : Œ± ‚Üí Multiplicative Œ±) :=
  IsClosedMap.id

theorem is_closed_map_to_add : IsClosedMap (toAdd : Multiplicative Œ± ‚Üí Œ±) :=
  IsClosedMap.id

attribute [local semireducible] nhds

theorem nhds_of_mul (a : Œ±) : ùìù (ofMul a) = map ofMul (ùìù a) :=
  rfl

theorem nhds_of_add (a : Œ±) : ùìù (ofAdd a) = map ofAdd (ùìù a) :=
  rfl

theorem nhds_to_mul (a : Additive Œ±) : ùìù (toMul a) = map toMul (ùìù a) :=
  rfl

theorem nhds_to_add (a : Multiplicative Œ±) : ùìù (toAdd a) = map toAdd (ùìù a) :=
  rfl

end

/-!
### Order dual

The topology on this type synonym is inherited without change.
-/


section

variable [TopologicalSpace Œ±]

open OrderDual

instance : TopologicalSpace Œ±·µí·µà :=
  ‚ÄπTopologicalSpace Œ±‚Ä∫

instance [DiscreteTopology Œ±] : DiscreteTopology Œ±·µí·µà :=
  ‚ÄπDiscreteTopology Œ±‚Ä∫

theorem continuous_to_dual : Continuous (toDual : Œ± ‚Üí Œ±·µí·µà) :=
  continuous_id

theorem continuous_of_dual : Continuous (ofDual : Œ±·µí·µà ‚Üí Œ±) :=
  continuous_id

theorem is_open_map_to_dual : IsOpenMap (toDual : Œ± ‚Üí Œ±·µí·µà) :=
  IsOpenMap.id

theorem is_open_map_of_dual : IsOpenMap (ofDual : Œ±·µí·µà ‚Üí Œ±) :=
  IsOpenMap.id

theorem is_closed_map_to_dual : IsClosedMap (toDual : Œ± ‚Üí Œ±·µí·µà) :=
  IsClosedMap.id

theorem is_closed_map_of_dual : IsClosedMap (ofDual : Œ±·µí·µà ‚Üí Œ±) :=
  IsClosedMap.id

attribute [local semireducible] nhds

theorem nhds_to_dual (a : Œ±) : ùìù (toDual a) = map toDual (ùìù a) :=
  rfl

theorem nhds_of_dual (a : Œ±) : ùìù (ofDual a) = map ofDual (ùìù a) :=
  rfl

end

theorem Quotient‚Çì.preimage_mem_nhds [TopologicalSpace Œ±] [s : Setoid‚Çì Œ±] {V : Set <| Quotient‚Çì s} {a : Œ±}
    (hs : V ‚àà ùìù (Quotient‚Çì.mk a)) : Quotient‚Çì.mk ‚Åª¬π' V ‚àà ùìù a :=
  preimage_nhds_coinduced hs

/-- The image of a dense set under `quotient.mk` is a dense set. -/
theorem Dense.quotient [Setoid‚Çì Œ±] [TopologicalSpace Œ±] {s : Set Œ±} (H : Dense s) : Dense (Quotient‚Çì.mk '' s) :=
  (surjective_quotient_mk Œ±).DenseRange.dense_image continuous_coinduced_rng H

/-- The composition of `quotient.mk` and a function with dense range has dense range. -/
theorem DenseRange.quotient [Setoid‚Çì Œ±] [TopologicalSpace Œ±] {f : Œ≤ ‚Üí Œ±} (hf : DenseRange f) :
    DenseRange (Quotient‚Çì.mk ‚àò f) :=
  (surjective_quotient_mk Œ±).DenseRange.comp hf continuous_coinduced_rng

instance {p : Œ± ‚Üí Prop} [TopologicalSpace Œ±] [DiscreteTopology Œ±] : DiscreteTopology (Subtype p) :=
  ‚ü®bot_unique fun s hs => ‚ü®coe '' s, is_open_discrete _, Set.preimage_image_eq _ Subtype.coe_injective‚ü©‚ü©

instance Sum.discrete_topology [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [hŒ± : DiscreteTopology Œ±]
    [hŒ≤ : DiscreteTopology Œ≤] : DiscreteTopology (Sum Œ± Œ≤) :=
  ‚ü®by
    unfold Sum.topologicalSpace <;> simp [‚Üê hŒ±.eq_bot, ‚Üê hŒ≤.eq_bot]‚ü©

instance Sigma.discrete_topology {Œ≤ : Œ± ‚Üí Type v} [‚àÄ a, TopologicalSpace (Œ≤ a)] [h : ‚àÄ a, DiscreteTopology (Œ≤ a)] :
    DiscreteTopology (Sigma Œ≤) :=
  ‚ü®by
    unfold Sigma.topologicalSpace
    simp [‚Üê fun a => (h a).eq_bot]‚ü©

section TopŒ±

variable [TopologicalSpace Œ±]

/-
The ùìù filter and the subspace topology.
-/
theorem mem_nhds_subtype (s : Set Œ±) (a : { x // x ‚àà s }) (t : Set { x // x ‚àà s }) :
    t ‚àà ùìù a ‚Üî ‚àÉ u ‚àà ùìù (a : Œ±), coe ‚Åª¬π' u ‚äÜ t :=
  mem_nhds_induced coe a t

theorem nhds_subtype (s : Set Œ±) (a : { x // x ‚àà s }) : ùìù a = comap coe (ùìù (a : Œ±)) :=
  nhds_induced coe a

end TopŒ±

/-- A type synonym equiped with the topology whose open sets are the empty set and the sets with
finite complements. -/
def CofiniteTopology (Œ± : Type _) :=
  Œ±

namespace CofiniteTopology

/-- The identity equivalence between `Œ±` and `cofinite_topology Œ±`. -/
def of : Œ± ‚âÉ CofiniteTopology Œ± :=
  Equiv‚Çì.refl Œ±

instance [Inhabited Œ±] : Inhabited (CofiniteTopology Œ±) where default := of default

instance : TopologicalSpace (CofiniteTopology Œ±) where
  IsOpen := fun s => s.Nonempty ‚Üí Set.Finite (s·∂ú)
  is_open_univ := by
    simp
  is_open_inter := fun s t => by
    rintro hs ht ‚ü®x, hxs, hxt‚ü©
    rw [compl_inter]
    exact (hs ‚ü®x, hxs‚ü©).union (ht ‚ü®x, hxt‚ü©)
  is_open_sUnion := by
    rintro s h ‚ü®x, t, hts, hzt‚ü©
    rw [Set.compl_sUnion]
    exact Set.Finite.sInter (mem_image_of_mem _ hts) (h t hts ‚ü®x, hzt‚ü©)

theorem is_open_iff {s : Set (CofiniteTopology Œ±)} : IsOpen s ‚Üî s.Nonempty ‚Üí s·∂ú.Finite :=
  Iff.rfl

theorem is_open_iff' {s : Set (CofiniteTopology Œ±)} : IsOpen s ‚Üî s = ‚àÖ ‚à® s·∂ú.Finite := by
  simp only [‚Üê is_open_iff, ne_empty_iff_nonempty, ‚Üê or_iff_not_imp_left]

theorem is_closed_iff {s : Set (CofiniteTopology Œ±)} : IsClosed s ‚Üî s = univ ‚à® s.Finite := by
  simp [is_open_compl_iff, ‚Üê is_open_iff']

theorem nhds_eq (a : CofiniteTopology Œ±) : ùìù a = pure a‚äîcofinite := by
  ext U
  rw [mem_nhds_iff]
  constructor
  ¬∑ rintro ‚ü®V, hVU, V_op, haV‚ü©
    exact mem_sup.mpr ‚ü®hVU haV, mem_of_superset (V_op ‚ü®_, haV‚ü©) hVU‚ü©
    
  ¬∑ rintro ‚ü®hU : a ‚àà U, hU' : U·∂ú.Finite‚ü©
    exact ‚ü®U, subset.rfl, fun h => hU', hU‚ü©
    

theorem mem_nhds_iff {a : CofiniteTopology Œ±} {s : Set (CofiniteTopology Œ±)} : s ‚àà ùìù a ‚Üî a ‚àà s ‚àß s·∂ú.Finite := by
  simp [‚Üê nhds_eq]

end CofiniteTopology

end Constructions

section Prod

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥] [TopologicalSpace Œ¥] [TopologicalSpace Œµ]
  [TopologicalSpace Œ∂]

@[continuity]
theorem continuous_fst : Continuous (@Prod.fst Œ± Œ≤) :=
  continuous_inf_dom_left continuous_induced_dom

/-- Postcomposing `f` with `prod.fst` is continuous -/
theorem Continuous.fst {f : Œ± ‚Üí Œ≤ √ó Œ≥} (hf : Continuous f) : Continuous fun a : Œ± => (f a).1 :=
  continuous_fst.comp hf

/-- Precomposing `f` with `prod.fst` is continuous -/
theorem Continuous.fst' {f : Œ± ‚Üí Œ≥} (hf : Continuous f) : Continuous fun x : Œ± √ó Œ≤ => f x.fst :=
  hf.comp continuous_fst

theorem continuous_at_fst {p : Œ± √ó Œ≤} : ContinuousAt Prod.fst p :=
  continuous_fst.ContinuousAt

/-- Postcomposing `f` with `prod.fst` is continuous at `x` -/
theorem ContinuousAt.fst {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : ContinuousAt f x) : ContinuousAt (fun a : Œ± => (f a).1) x :=
  continuous_at_fst.comp hf

/-- Precomposing `f` with `prod.fst` is continuous at `(x, y)` -/
theorem ContinuousAt.fst' {f : Œ± ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f x) :
    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.fst) (x, y) :=
  ContinuousAt.comp hf continuous_at_fst

/-- Precomposing `f` with `prod.fst` is continuous at `x : Œ± √ó Œ≤` -/
theorem ContinuousAt.fst'' {f : Œ± ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : ContinuousAt f x.fst) :
    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.fst) x :=
  hf.comp continuous_at_fst

@[continuity]
theorem continuous_snd : Continuous (@Prod.snd Œ± Œ≤) :=
  continuous_inf_dom_right continuous_induced_dom

/-- Postcomposing `f` with `prod.snd` is continuous -/
theorem Continuous.snd {f : Œ± ‚Üí Œ≤ √ó Œ≥} (hf : Continuous f) : Continuous fun a : Œ± => (f a).2 :=
  continuous_snd.comp hf

/-- Precomposing `f` with `prod.snd` is continuous -/
theorem Continuous.snd' {f : Œ≤ ‚Üí Œ≥} (hf : Continuous f) : Continuous fun x : Œ± √ó Œ≤ => f x.snd :=
  hf.comp continuous_snd

theorem continuous_at_snd {p : Œ± √ó Œ≤} : ContinuousAt Prod.snd p :=
  continuous_snd.ContinuousAt

/-- Postcomposing `f` with `prod.snd` is continuous at `x` -/
theorem ContinuousAt.snd {f : Œ± ‚Üí Œ≤ √ó Œ≥} {x : Œ±} (hf : ContinuousAt f x) : ContinuousAt (fun a : Œ± => (f a).2) x :=
  continuous_at_snd.comp hf

/-- Precomposing `f` with `prod.snd` is continuous at `(x, y)` -/
theorem ContinuousAt.snd' {f : Œ≤ ‚Üí Œ≥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f y) :
    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.snd) (x, y) :=
  ContinuousAt.comp hf continuous_at_snd

/-- Precomposing `f` with `prod.snd` is continuous at `x : Œ± √ó Œ≤` -/
theorem ContinuousAt.snd'' {f : Œ≤ ‚Üí Œ≥} {x : Œ± √ó Œ≤} (hf : ContinuousAt f x.snd) :
    ContinuousAt (fun x : Œ± √ó Œ≤ => f x.snd) x :=
  hf.comp continuous_at_snd

@[continuity]
theorem Continuous.prod_mk {f : Œ≥ ‚Üí Œ±} {g : Œ≥ ‚Üí Œ≤} (hf : Continuous f) (hg : Continuous g) :
    Continuous fun x => (f x, g x) :=
  continuous_inf_rng.2 ‚ü®continuous_induced_rng.2 hf, continuous_induced_rng.2 hg‚ü©

@[simp]
theorem continuous_prod_mk {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} : (Continuous fun x => (f x, g x)) ‚Üî Continuous f ‚àß Continuous g :=
  ‚ü®fun h => ‚ü®h.fst, h.snd‚ü©, fun h => h.1.prod_mk h.2‚ü©

@[continuity]
theorem Continuous.Prod.mk (a : Œ±) : Continuous fun b : Œ≤ => (a, b) :=
  continuous_const.prod_mk continuous_id'

@[continuity]
theorem Continuous.Prod.mk_left (b : Œ≤) : Continuous fun a : Œ± => (a, b) :=
  continuous_id'.prod_mk continuous_const

theorem Continuous.comp‚ÇÇ {g : Œ± √ó Œ≤ ‚Üí Œ≥} (hg : Continuous g) {e : Œ¥ ‚Üí Œ±} (he : Continuous e) {f : Œ¥ ‚Üí Œ≤}
    (hf : Continuous f) : Continuous fun x => g (e x, f x) :=
  hg.comp <| he.prod_mk hf

theorem Continuous.comp‚ÇÉ {g : Œ± √ó Œ≤ √ó Œ≥ ‚Üí Œµ} (hg : Continuous g) {e : Œ¥ ‚Üí Œ±} (he : Continuous e) {f : Œ¥ ‚Üí Œ≤}
    (hf : Continuous f) {k : Œ¥ ‚Üí Œ≥} (hk : Continuous k) : Continuous fun x => g (e x, f x, k x) :=
  hg.comp‚ÇÇ he <| hf.prod_mk hk

theorem Continuous.comp‚ÇÑ {g : Œ± √ó Œ≤ √ó Œ≥ √ó Œ∂ ‚Üí Œµ} (hg : Continuous g) {e : Œ¥ ‚Üí Œ±} (he : Continuous e) {f : Œ¥ ‚Üí Œ≤}
    (hf : Continuous f) {k : Œ¥ ‚Üí Œ≥} (hk : Continuous k) {l : Œ¥ ‚Üí Œ∂} (hl : Continuous l) :
    Continuous fun x => g (e x, f x, k x, l x) :=
  hg.comp‚ÇÉ he hf <| hk.prod_mk hl

theorem Continuous.prod_map {f : Œ≥ ‚Üí Œ±} {g : Œ¥ ‚Üí Œ≤} (hf : Continuous f) (hg : Continuous g) :
    Continuous fun x : Œ≥ √ó Œ¥ => (f x.1, g x.2) :=
  hf.fst'.prod_mk hg.snd'

/-- A version of `continuous_inf_dom_left` for binary functions -/
theorem continuous_inf_dom_left‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ta1 ta2 : TopologicalSpace Œ±} {tb1 tb2 : TopologicalSpace Œ≤}
    {tc1 : TopologicalSpace Œ≥}
    (h : by
      haveI := ta1 <;> haveI := tb1 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2) :
    by
    haveI := ta1‚äìta2 <;> haveI := tb1‚äìtb2 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2 := by
  have ha := @continuous_inf_dom_left _ _ id ta1 ta2 ta1 (@continuous_id _ (id _))
  have hb := @continuous_inf_dom_left _ _ id tb1 tb2 tb1 (@continuous_id _ (id _))
  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta1 tb1 (ta1‚äìta2) (tb1‚äìtb2) _ _ ha hb
  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id

/-- A version of `continuous_inf_dom_right` for binary functions -/
theorem continuous_inf_dom_right‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {ta1 ta2 : TopologicalSpace Œ±} {tb1 tb2 : TopologicalSpace Œ≤}
    {tc1 : TopologicalSpace Œ≥}
    (h : by
      haveI := ta2 <;> haveI := tb2 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2) :
    by
    haveI := ta1‚äìta2 <;> haveI := tb1‚äìtb2 <;> exact Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2 := by
  have ha := @continuous_inf_dom_right _ _ id ta1 ta2 ta2 (@continuous_id _ (id _))
  have hb := @continuous_inf_dom_right _ _ id tb1 tb2 tb2 (@continuous_id _ (id _))
  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta2 tb2 (ta1‚äìta2) (tb1‚äìtb2) _ _ ha hb
  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ h h_continuous_id

/-- A version of `continuous_Inf_dom` for binary functions -/
theorem continuous_Inf_dom‚ÇÇ {Œ± Œ≤ Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {tas : Set (TopologicalSpace Œ±)} {tbs : Set (TopologicalSpace Œ≤)}
    {ta : TopologicalSpace Œ±} {tb : TopologicalSpace Œ≤} {tc : TopologicalSpace Œ≥} (ha : ta ‚àà tas) (hb : tb ‚àà tbs)
    (hf : Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2) : by
    haveI := Inf tas <;> haveI := Inf tbs <;> exact @Continuous _ _ _ tc fun p : Œ± √ó Œ≤ => f p.1 p.2 := by
  let t : TopologicalSpace (Œ± √ó Œ≤) := Prod.topologicalSpace
  have ha := continuous_Inf_dom ha continuous_id
  have hb := continuous_Inf_dom hb continuous_id
  have h_continuous_id := @Continuous.prod_map _ _ _ _ ta tb (Inf tas) (Inf tbs) _ _ ha hb
  exact @Continuous.comp _ _ _ (id _) (id _) _ _ _ hf h_continuous_id

theorem Filter.Eventually.prod_inl_nhds {p : Œ± ‚Üí Prop} {a : Œ±} (h : ‚àÄ·∂† x in ùìù a, p x) (b : Œ≤) :
    ‚àÄ·∂† x in ùìù (a, b), p (x : Œ± √ó Œ≤).1 :=
  continuous_at_fst h

theorem Filter.Eventually.prod_inr_nhds {p : Œ≤ ‚Üí Prop} {b : Œ≤} (h : ‚àÄ·∂† x in ùìù b, p x) (a : Œ±) :
    ‚àÄ·∂† x in ùìù (a, b), p (x : Œ± √ó Œ≤).2 :=
  continuous_at_snd h

theorem Filter.Eventually.prod_mk_nhds {pa : Œ± ‚Üí Prop} {a} (ha : ‚àÄ·∂† x in ùìù a, pa x) {pb : Œ≤ ‚Üí Prop} {b}
    (hb : ‚àÄ·∂† y in ùìù b, pb y) : ‚àÄ·∂† p in ùìù (a, b), pa (p : Œ± √ó Œ≤).1 ‚àß pb p.2 :=
  (ha.prod_inl_nhds b).And (hb.prod_inr_nhds a)

theorem continuous_swap : Continuous (Prod.swap : Œ± √ó Œ≤ ‚Üí Œ≤ √ó Œ±) :=
  continuous_snd.prod_mk continuous_fst

theorem continuous_uncurry_left {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (a : Œ±) (h : Continuous (Function.uncurry f)) : Continuous (f a) :=
  show Continuous (Function.uncurry f ‚àò fun b => (a, b)) from
    h.comp
      (by
        continuity)

theorem continuous_uncurry_right {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (b : Œ≤) (h : Continuous (Function.uncurry f)) :
    Continuous fun a => f a b :=
  show Continuous (Function.uncurry f ‚àò fun a => (a, b)) from
    h.comp
      (by
        continuity)

theorem continuous_curry {g : Œ± √ó Œ≤ ‚Üí Œ≥} (a : Œ±) (h : Continuous g) : Continuous (Function.curry g a) :=
  show Continuous (g ‚àò fun b => (a, b)) from
    h.comp
      (by
        continuity)

theorem IsOpen.prod {s : Set Œ±} {t : Set Œ≤} (hs : IsOpen s) (ht : IsOpen t) : IsOpen (s √óÀ¢ t) :=
  (hs.Preimage continuous_fst).inter (ht.Preimage continuous_snd)

theorem nhds_prod_eq {a : Œ±} {b : Œ≤} : ùìù (a, b) = ùìù a √ó·∂† ùìù b := by
  rw [Filter.prod, Prod.topologicalSpace, nhds_inf, nhds_induced, nhds_induced]

/-- If a function `f x y` is such that `y ‚Ü¶ f x y` is continuous for all `x`, and `x` lives in a
discrete space, then `f` is continuous. -/
theorem continuous_uncurry_of_discrete_topology [DiscreteTopology Œ±] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (hf : ‚àÄ a, Continuous (f a)) :
    Continuous (Function.uncurry f) := by
  apply continuous_iff_continuous_at.2
  rintro ‚ü®a, x‚ü©
  change map _ _ ‚â§ _
  rw [nhds_prod_eq, nhds_discrete, Filter.map_pure_prod]
  exact (hf a).ContinuousAt

theorem mem_nhds_prod_iff {a : Œ±} {b : Œ≤} {s : Set (Œ± √ó Œ≤)} : s ‚àà ùìù (a, b) ‚Üî ‚àÉ u ‚àà ùìù a, ‚àÉ v ‚àà ùìù b, u √óÀ¢ v ‚äÜ s := by
  rw [nhds_prod_eq, mem_prod_iff]

theorem mem_nhds_prod_iff' {a : Œ±} {b : Œ≤} {s : Set (Œ± √ó Œ≤)} :
    s ‚àà ùìù (a, b) ‚Üî ‚àÉ (u : Set Œ±)(v : Set Œ≤), IsOpen u ‚àß a ‚àà u ‚àß IsOpen v ‚àß b ‚àà v ‚àß u √óÀ¢ v ‚äÜ s := by
  rw [mem_nhds_prod_iff]
  constructor
  ¬∑ rintro ‚ü®u, Hu, v, Hv, h‚ü©
    rcases mem_nhds_iff.1 Hu with ‚ü®u', u'u, u'_open, Hu'‚ü©
    rcases mem_nhds_iff.1 Hv with ‚ü®v', v'v, v'_open, Hv'‚ü©
    exact ‚ü®u', v', u'_open, Hu', v'_open, Hv', (Set.prod_mono u'u v'v).trans h‚ü©
    
  ¬∑ rintro ‚ü®u, v, u_open, au, v_open, bv, huv‚ü©
    exact ‚ü®u, u_open.mem_nhds au, v, v_open.mem_nhds bv, huv‚ü©
    

theorem _root_.prod.tendsto_iff {Œ±} (seq : Œ± ‚Üí Œ≤ √ó Œ≥) {f : Filter Œ±} (x : Œ≤ √ó Œ≥) :
    Tendsto seq f (ùìù x) ‚Üî Tendsto (fun n => (seq n).fst) f (ùìù x.fst) ‚àß Tendsto (fun n => (seq n).snd) f (ùìù x.snd) := by
  cases x
  rw [nhds_prod_eq, Filter.tendsto_prod_iff']

theorem Filter.HasBasis.prod_nhds {Œπa Œπb : Type _} {pa : Œπa ‚Üí Prop} {pb : Œπb ‚Üí Prop} {sa : Œπa ‚Üí Set Œ±} {sb : Œπb ‚Üí Set Œ≤}
    {a : Œ±} {b : Œ≤} (ha : (ùìù a).HasBasis pa sa) (hb : (ùìù b).HasBasis pb sb) :
    (ùìù (a, b)).HasBasis (fun i : Œπa √ó Œπb => pa i.1 ‚àß pb i.2) fun i => sa i.1 √óÀ¢ sb i.2 := by
  rw [nhds_prod_eq]
  exact ha.prod hb

theorem Filter.HasBasis.prod_nhds' {Œπa Œπb : Type _} {pa : Œπa ‚Üí Prop} {pb : Œπb ‚Üí Prop} {sa : Œπa ‚Üí Set Œ±}
    {sb : Œπb ‚Üí Set Œ≤} {ab : Œ± √ó Œ≤} (ha : (ùìù ab.1).HasBasis pa sa) (hb : (ùìù ab.2).HasBasis pb sb) :
    (ùìù ab).HasBasis (fun i : Œπa √ó Œπb => pa i.1 ‚àß pb i.2) fun i => sa i.1 √óÀ¢ sb i.2 := by
  cases ab
  exact ha.prod_nhds hb

instance [DiscreteTopology Œ±] [DiscreteTopology Œ≤] : DiscreteTopology (Œ± √ó Œ≤) :=
  ‚ü®eq_of_nhds_eq_nhds fun ‚ü®a, b‚ü© => by
      rw [nhds_prod_eq, nhds_discrete Œ±, nhds_discrete Œ≤, nhds_bot, Filter.prod_pure_pure]‚ü©

theorem prod_mem_nhds_iff {s : Set Œ±} {t : Set Œ≤} {a : Œ±} {b : Œ≤} : s √óÀ¢ t ‚àà ùìù (a, b) ‚Üî s ‚àà ùìù a ‚àß t ‚àà ùìù b := by
  rw [nhds_prod_eq, prod_mem_prod_iff]

theorem prod_mem_nhds {s : Set Œ±} {t : Set Œ≤} {a : Œ±} {b : Œ≤} (ha : s ‚àà ùìù a) (hb : t ‚àà ùìù b) : s √óÀ¢ t ‚àà ùìù (a, b) :=
  prod_mem_nhds_iff.2 ‚ü®ha, hb‚ü©

theorem Filter.Eventually.prod_nhds {p : Œ± ‚Üí Prop} {q : Œ≤ ‚Üí Prop} {a : Œ±} {b : Œ≤} (ha : ‚àÄ·∂† x in ùìù a, p x)
    (hb : ‚àÄ·∂† y in ùìù b, q y) : ‚àÄ·∂† z : Œ± √ó Œ≤ in ùìù (a, b), p z.1 ‚àß q z.2 :=
  prod_mem_nhds ha hb

theorem nhds_swap (a : Œ±) (b : Œ≤) : ùìù (a, b) = (ùìù (b, a)).map Prod.swap := by
  rw [nhds_prod_eq, Filter.prod_comm, nhds_prod_eq] <;> rfl

theorem Filter.Tendsto.prod_mk_nhds {Œ≥} {a : Œ±} {b : Œ≤} {f : Filter Œ≥} {ma : Œ≥ ‚Üí Œ±} {mb : Œ≥ ‚Üí Œ≤}
    (ha : Tendsto ma f (ùìù a)) (hb : Tendsto mb f (ùìù b)) : Tendsto (fun c => (ma c, mb c)) f (ùìù (a, b)) := by
  rw [nhds_prod_eq] <;> exact Filter.Tendsto.prod_mk ha hb

theorem Filter.Eventually.curry_nhds {p : Œ± √ó Œ≤ ‚Üí Prop} {x : Œ±} {y : Œ≤} (h : ‚àÄ·∂† x in ùìù (x, y), p x) :
    ‚àÄ·∂† x' in ùìù x, ‚àÄ·∂† y' in ùìù y, p (x', y') := by
  rw [nhds_prod_eq] at h
  exact h.curry

theorem ContinuousAt.prod {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≥} {x : Œ±} (hf : ContinuousAt f x) (hg : ContinuousAt g x) :
    ContinuousAt (fun x => (f x, g x)) x :=
  hf.prod_mk_nhds hg

theorem ContinuousAt.prod_map {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {p : Œ± √ó Œ≤} (hf : ContinuousAt f p.fst)
    (hg : ContinuousAt g p.snd) : ContinuousAt (fun p : Œ± √ó Œ≤ => (f p.1, g p.2)) p :=
  hf.fst''.Prod hg.snd''

theorem ContinuousAt.prod_map' {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ¥} {x : Œ±} {y : Œ≤} (hf : ContinuousAt f x) (hg : ContinuousAt g y) :
    ContinuousAt (fun p : Œ± √ó Œ≤ => (f p.1, g p.2)) (x, y) :=
  hf.fst'.Prod hg.snd'

theorem prod_generate_from_generate_from_eq {Œ± Œ≤ : Type _} {s : Set (Set Œ±)} {t : Set (Set Œ≤)} (hs : ‚ãÉ‚ÇÄs = univ)
    (ht : ‚ãÉ‚ÇÄt = univ) :
    @Prod.topologicalSpace Œ± Œ≤ (generateFrom s) (generateFrom t) = generateFrom { g | ‚àÉ u ‚àà s, ‚àÉ v ‚àà t, g = u √óÀ¢ v } :=
  let G := generateFrom { g | ‚àÉ u ‚àà s, ‚àÉ v ‚àà t, g = u √óÀ¢ v }
  le_antisymm‚Çì
    (le_generate_from fun g ‚ü®u, hu, v, hv, g_eq‚ü© =>
      g_eq.symm ‚ñ∏
        @IsOpen.prod _ _ (generateFrom s) (generateFrom t) _ _ (GenerateOpen.basic _ hu) (GenerateOpen.basic _ hv))
    (le_inf
      (coinduced_le_iff_le_induced.mp <|
        le_generate_from fun u hu =>
          have : (‚ãÉ v ‚àà t, u √óÀ¢ v) = Prod.fst ‚Åª¬π' u := by
            simp_rw [‚Üê prod_Union, ‚Üê sUnion_eq_bUnion, ht, prod_univ]
          show G.IsOpen (Prod.fst ‚Åª¬π' u) by
            rw [‚Üê this]
            exact is_open_Union fun v => is_open_Union fun hv => generate_open.basic _ ‚ü®_, hu, _, hv, rfl‚ü©)
      (coinduced_le_iff_le_induced.mp <|
        le_generate_from fun v hv =>
          have : (‚ãÉ u ‚àà s, u √óÀ¢ v) = Prod.snd ‚Åª¬π' v := by
            simp_rw [‚Üê Union_prod_const, ‚Üê sUnion_eq_bUnion, hs, univ_prod]
          show G.IsOpen (Prod.snd ‚Åª¬π' v) by
            rw [‚Üê this]
            exact is_open_Union fun u => is_open_Union fun hu => generate_open.basic _ ‚ü®_, hu, _, hv, rfl‚ü©))

theorem prod_eq_generate_from :
    Prod.topologicalSpace = generateFrom { g | ‚àÉ (s : Set Œ±)(t : Set Œ≤), IsOpen s ‚àß IsOpen t ‚àß g = s √óÀ¢ t } :=
  le_antisymm‚Çì (le_generate_from fun g ‚ü®s, t, hs, ht, g_eq‚ü© => g_eq.symm ‚ñ∏ hs.Prod ht)
    (le_inf
      (ball_image_of_ball fun t ht =>
        GenerateOpen.basic _
          ‚ü®t, Univ, by
            simpa [‚Üê Set.prod_eq] using ht‚ü©)
      (ball_image_of_ball fun t ht =>
        GenerateOpen.basic _
          ‚ü®Univ, t, by
            simpa [‚Üê Set.prod_eq] using ht‚ü©))

theorem is_open_prod_iff {s : Set (Œ± √ó Œ≤)} :
    IsOpen s ‚Üî ‚àÄ a b, (a, b) ‚àà s ‚Üí ‚àÉ (u : Set Œ±)(v : Set Œ≤), IsOpen u ‚àß IsOpen v ‚àß a ‚àà u ‚àß b ‚àà v ‚àß u √óÀ¢ v ‚äÜ s := by
  rw [is_open_iff_nhds]
  simp_rw [le_principal_iff, Prod.forall, ((nhds_basis_opens _).prod_nhds (nhds_basis_opens _)).mem_iff, Prod.exists,
    exists_prop]
  simp only [‚Üê and_assoc, ‚Üê And.left_comm]

/-- A product of induced topologies is induced by the product map -/
theorem prod_induced_induced {Œ± Œ≥ : Type _} (f : Œ± ‚Üí Œ≤) (g : Œ≥ ‚Üí Œ¥) :
    @Prod.topologicalSpace Œ± Œ≥ (induced f ‚Äπ_‚Ä∫) (induced g ‚Äπ_‚Ä∫) =
      induced (fun p => (f p.1, g p.2)) Prod.topologicalSpace :=
  by
  simp_rw [Prod.topologicalSpace, induced_inf, induced_compose]

theorem continuous_uncurry_of_discrete_topology_left [DiscreteTopology Œ±] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} (h : ‚àÄ a, Continuous (f a)) :
    Continuous (Function.uncurry f) :=
  continuous_iff_continuous_at.2 fun ‚ü®a, b‚ü© => by
    simp only [‚Üê ContinuousAt, ‚Üê nhds_prod_eq, ‚Üê nhds_discrete Œ±, ‚Üê pure_prod, ‚Üê tendsto_map'_iff, ‚Üê (¬∑ ‚àò ¬∑), ‚Üê
      Function.uncurry, ‚Üê (h a).Tendsto]

/-- Given a neighborhood `s` of `(x, x)`, then `(x, x)` has a square open neighborhood
  that is a subset of `s`. -/
theorem exists_nhds_square {s : Set (Œ± √ó Œ±)} {x : Œ±} (hx : s ‚àà ùìù (x, x)) : ‚àÉ U : Set Œ±, IsOpen U ‚àß x ‚àà U ‚àß U √óÀ¢ U ‚äÜ s :=
  by
  simpa [‚Üê nhds_prod_eq, ‚Üê (nhds_basis_opens x).prod_self.mem_iff, ‚Üê And.assoc, ‚Üê And.left_comm] using hx

/-- `prod.fst` maps neighborhood of `x : Œ± √ó Œ≤` within the section `prod.snd ‚Åª¬π' {x.2}`
to `ùìù x.1`. -/
theorem map_fst_nhds_within (x : Œ± √ó Œ≤) : map Prod.fst (ùìù[Prod.snd ‚Åª¬π' {x.2}] x) = ùìù x.1 := by
  refine' le_antisymm‚Çì (continuous_at_fst.mono_left inf_le_left) fun s hs => _
  rcases x with ‚ü®x, y‚ü©
  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs
  rcases hs with ‚ü®u, hu, v, hv, H‚ü©
  simp only [‚Üê prod_subset_iff, ‚Üê mem_singleton_iff, ‚Üê mem_set_of_eq, ‚Üê mem_preimage] at H
  exact mem_of_superset hu fun z hz => H _ hz _ (mem_of_mem_nhds hv) rfl

@[simp]
theorem map_fst_nhds (x : Œ± √ó Œ≤) : map Prod.fst (ùìù x) = ùìù x.1 :=
  le_antisymm‚Çì continuous_at_fst <| (map_fst_nhds_within x).symm.trans_le (map_mono inf_le_left)

/-- The first projection in a product of topological spaces sends open sets to open sets. -/
theorem is_open_map_fst : IsOpenMap (@Prod.fst Œ± Œ≤) :=
  is_open_map_iff_nhds_le.2 fun x => (map_fst_nhds x).Ge

/-- `prod.snd` maps neighborhood of `x : Œ± √ó Œ≤` within the section `prod.fst ‚Åª¬π' {x.1}`
to `ùìù x.2`. -/
theorem map_snd_nhds_within (x : Œ± √ó Œ≤) : map Prod.snd (ùìù[Prod.fst ‚Åª¬π' {x.1}] x) = ùìù x.2 := by
  refine' le_antisymm‚Çì (continuous_at_snd.mono_left inf_le_left) fun s hs => _
  rcases x with ‚ü®x, y‚ü©
  rw [mem_map, nhdsWithin, mem_inf_principal, mem_nhds_prod_iff] at hs
  rcases hs with ‚ü®u, hu, v, hv, H‚ü©
  simp only [‚Üê prod_subset_iff, ‚Üê mem_singleton_iff, ‚Üê mem_set_of_eq, ‚Üê mem_preimage] at H
  exact mem_of_superset hv fun z hz => H _ (mem_of_mem_nhds hu) _ hz rfl

@[simp]
theorem map_snd_nhds (x : Œ± √ó Œ≤) : map Prod.snd (ùìù x) = ùìù x.2 :=
  le_antisymm‚Çì continuous_at_snd <| (map_snd_nhds_within x).symm.trans_le (map_mono inf_le_left)

/-- The second projection in a product of topological spaces sends open sets to open sets. -/
theorem is_open_map_snd : IsOpenMap (@Prod.snd Œ± Œ≤) :=
  is_open_map_iff_nhds_le.2 fun x => (map_snd_nhds x).Ge

/-- A product set is open in a product space if and only if each factor is open, or one of them is
empty -/
theorem is_open_prod_iff' {s : Set Œ±} {t : Set Œ≤} : IsOpen (s √óÀ¢ t) ‚Üî IsOpen s ‚àß IsOpen t ‚à® s = ‚àÖ ‚à® t = ‚àÖ := by
  cases' (s √óÀ¢ t).eq_empty_or_nonempty with h h
  ¬∑ simp [‚Üê h, ‚Üê prod_eq_empty_iff.1 h]
    
  ¬∑ have st : s.nonempty ‚àß t.nonempty := prod_nonempty_iff.1 h
    constructor
    ¬∑ intro (H : IsOpen (s √óÀ¢ t))
      refine' Or.inl ‚ü®_, _‚ü©
      show IsOpen s
      ¬∑ rw [‚Üê fst_image_prod s st.2]
        exact is_open_map_fst _ H
        
      show IsOpen t
      ¬∑ rw [‚Üê snd_image_prod st.1 t]
        exact is_open_map_snd _ H
        
      
    ¬∑ intro H
      simp only [‚Üê st.1.ne_empty, ‚Üê st.2.ne_empty, ‚Üê not_false_iff, ‚Üê or_false‚Çì] at H
      exact H.1.Prod H.2
      
    

theorem closure_prod_eq {s : Set Œ±} {t : Set Œ≤} : Closure (s √óÀ¢ t) = Closure s √óÀ¢ Closure t :=
  Set.ext fun ‚ü®a, b‚ü© => by
    have : (ùìù a √ó·∂† ùìù b)‚äìùìü (s √óÀ¢ t) = ùìù a‚äìùìü s √ó·∂† ùìù b‚äìùìü t := by
      rw [‚Üê prod_inf_prod, prod_principal_principal]
    simp [‚Üê closure_eq_cluster_pts, ‚Üê ClusterPt, ‚Üê nhds_prod_eq, ‚Üê this] <;> exact prod_ne_bot

theorem interior_prod_eq (s : Set Œ±) (t : Set Œ≤) : Interior (s √óÀ¢ t) = Interior s √óÀ¢ Interior t :=
  Set.ext fun ‚ü®a, b‚ü© => by
    simp only [‚Üê mem_interior_iff_mem_nhds, ‚Üê mem_prod, ‚Üê prod_mem_nhds_iff]

theorem frontier_prod_eq (s : Set Œ±) (t : Set Œ≤) :
    Frontier (s √óÀ¢ t) = Closure s √óÀ¢ Frontier t ‚à™ Frontier s √óÀ¢ Closure t := by
  simp only [‚Üê Frontier, ‚Üê closure_prod_eq, ‚Üê interior_prod_eq, ‚Üê prod_diff_prod]

@[simp]
theorem frontier_prod_univ_eq (s : Set Œ±) : Frontier (s √óÀ¢ (Univ : Set Œ≤)) = Frontier s √óÀ¢ univ := by
  simp [‚Üê frontier_prod_eq]

@[simp]
theorem frontier_univ_prod_eq (s : Set Œ≤) : Frontier ((Univ : Set Œ±) √óÀ¢ s) = univ √óÀ¢ Frontier s := by
  simp [‚Üê frontier_prod_eq]

theorem map_mem_closure2 {s : Set Œ±} {t : Set Œ≤} {u : Set Œ≥} {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {a : Œ±} {b : Œ≤}
    (hf : Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2) (ha : a ‚àà Closure s) (hb : b ‚àà Closure t)
    (hu : ‚àÄ a b, a ‚àà s ‚Üí b ‚àà t ‚Üí f a b ‚àà u) : f a b ‚àà Closure u :=
  have : (a, b) ‚àà Closure (s √óÀ¢ t) := by
    rw [closure_prod_eq] <;> exact ‚ü®ha, hb‚ü©
  show (fun p : Œ± √ó Œ≤ => f p.1 p.2) (a, b) ‚àà Closure u from
    (map_mem_closure hf this) fun ‚ü®a, b‚ü© ‚ü®ha, hb‚ü© => hu a b ha hb

theorem IsClosed.prod {s‚ÇÅ : Set Œ±} {s‚ÇÇ : Set Œ≤} (h‚ÇÅ : IsClosed s‚ÇÅ) (h‚ÇÇ : IsClosed s‚ÇÇ) : IsClosed (s‚ÇÅ √óÀ¢ s‚ÇÇ) :=
  closure_eq_iff_is_closed.mp <| by
    simp only [‚Üê h‚ÇÅ.closure_eq, ‚Üê h‚ÇÇ.closure_eq, ‚Üê closure_prod_eq]

/-- The product of two dense sets is a dense set. -/
theorem Dense.prod {s : Set Œ±} {t : Set Œ≤} (hs : Dense s) (ht : Dense t) : Dense (s √óÀ¢ t) := fun x => by
  rw [closure_prod_eq]
  exact ‚ü®hs x.1, ht x.2‚ü©

/-- If `f` and `g` are maps with dense range, then `prod.map f g` has dense range. -/
theorem DenseRange.prod_map {Œπ : Type _} {Œ∫ : Type _} {f : Œπ ‚Üí Œ≤} {g : Œ∫ ‚Üí Œ≥} (hf : DenseRange f) (hg : DenseRange g) :
    DenseRange (Prod.map f g) := by
  simpa only [‚Üê DenseRange, ‚Üê prod_range_range_eq] using hf.prod hg

theorem Inducing.prod_mk {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : Inducing f) (hg : Inducing g) :
    Inducing fun x : Œ± √ó Œ≥ => (f x.1, g x.2) :=
  ‚ü®by
    rw [Prod.topologicalSpace, Prod.topologicalSpace, hf.induced, hg.induced, induced_compose, induced_compose,
      induced_inf, induced_compose, induced_compose]‚ü©

theorem Embedding.prod_mk {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : Embedding f) (hg : Embedding g) :
    Embedding fun x : Œ± √ó Œ≥ => (f x.1, g x.2) :=
  { hf.to_inducing.prod_mk hg.to_inducing with
    inj := fun ‚ü®x‚ÇÅ, x‚ÇÇ‚ü© ‚ü®y‚ÇÅ, y‚ÇÇ‚ü© => by
      simp <;> exact fun h‚ÇÅ h‚ÇÇ => ‚ü®hf.inj h‚ÇÅ, hg.inj h‚ÇÇ‚ü© }

protected theorem IsOpenMap.prod {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : IsOpenMap f) (hg : IsOpenMap g) :
    IsOpenMap fun p : Œ± √ó Œ≥ => (f p.1, g p.2) := by
  rw [is_open_map_iff_nhds_le]
  rintro ‚ü®a, b‚ü©
  rw [nhds_prod_eq, nhds_prod_eq, ‚Üê Filter.prod_map_map_eq]
  exact Filter.prod_mono (is_open_map_iff_nhds_le.1 hf a) (is_open_map_iff_nhds_le.1 hg b)

protected theorem OpenEmbedding.prod {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : OpenEmbedding f) (hg : OpenEmbedding g) :
    OpenEmbedding fun x : Œ± √ó Œ≥ => (f x.1, g x.2) :=
  open_embedding_of_embedding_open (hf.1.prod_mk hg.1) (hf.IsOpenMap.Prod hg.IsOpenMap)

theorem embedding_graph {f : Œ± ‚Üí Œ≤} (hf : Continuous f) : Embedding fun x => (x, f x) :=
  embedding_of_embedding_compose (continuous_id.prod_mk hf) continuous_fst embedding_id

end Prod

section Sum

open Sum

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥] [TopologicalSpace Œ¥]

@[continuity]
theorem continuous_inl : Continuous (@inl Œ± Œ≤) :=
  continuous_sup_rng_left continuous_coinduced_rng

@[continuity]
theorem continuous_inr : Continuous (@inr Œ± Œ≤) :=
  continuous_sup_rng_right continuous_coinduced_rng

@[continuity]
theorem Continuous.sum_elim {f : Œ± ‚Üí Œ≥} {g : Œ≤ ‚Üí Œ≥} (hf : Continuous f) (hg : Continuous g) :
    Continuous (Sum.elim f g) := by
  simp only [‚Üê continuous_sup_dom, ‚Üê continuous_coinduced_dom, ‚Üê Sum.elim_comp_inl, ‚Üê Sum.elim_comp_inr, ‚Üê true_and‚Çì, *]

@[continuity]
theorem Continuous.sum_map {f : Œ± ‚Üí Œ≤} {g : Œ≥ ‚Üí Œ¥} (hf : Continuous f) (hg : Continuous g) : Continuous (Sum.map f g) :=
  (continuous_inl.comp hf).sum_elim (continuous_inr.comp hg)

theorem is_open_sum_iff {s : Set (Sum Œ± Œ≤)} : IsOpen s ‚Üî IsOpen (inl ‚Åª¬π' s) ‚àß IsOpen (inr ‚Åª¬π' s) :=
  Iff.rfl

theorem is_open_map_sum {f : Sum Œ± Œ≤ ‚Üí Œ≥} (h‚ÇÅ : IsOpenMap fun a => f (inl a)) (h‚ÇÇ : IsOpenMap fun b => f (inr b)) :
    IsOpenMap f := by
  intro u hu
  rw [is_open_sum_iff] at hu
  cases' hu with hu‚ÇÅ hu‚ÇÇ
  have : u = inl '' (inl ‚Åª¬π' u) ‚à™ inr '' (inr ‚Åª¬π' u) := by
    ext (_ | _) <;> simp
  rw [this, Set.image_union, Set.image_image, Set.image_image]
  exact IsOpen.union (h‚ÇÅ _ hu‚ÇÅ) (h‚ÇÇ _ hu‚ÇÇ)

theorem embedding_inl : Embedding (@inl Œ± Œ≤) :=
  { induced := by
      unfold Sum.topologicalSpace
      apply le_antisymm‚Çì
      ¬∑ rw [‚Üê coinduced_le_iff_le_induced]
        exact le_sup_left
        
      ¬∑ intro u hu
        exists inl '' u
        change (IsOpen (inl ‚Åª¬π' (@inl Œ± Œ≤ '' u)) ‚àß IsOpen (inr ‚Åª¬π' (@inl Œ± Œ≤ '' u))) ‚àß inl ‚Åª¬π' (inl '' u) = u
        rw [preimage_image_eq u Sum.inl_injective, preimage_inr_image_inl]
        exact ‚ü®‚ü®hu, is_open_empty‚ü©, rfl‚ü©
        ,
    inj := fun _ _ => inl.inj_iff.mp }

theorem embedding_inr : Embedding (@inr Œ± Œ≤) :=
  { induced := by
      unfold Sum.topologicalSpace
      apply le_antisymm‚Çì
      ¬∑ rw [‚Üê coinduced_le_iff_le_induced]
        exact le_sup_right
        
      ¬∑ intro u hu
        exists inr '' u
        change (IsOpen (inl ‚Åª¬π' (@inr Œ± Œ≤ '' u)) ‚àß IsOpen (inr ‚Åª¬π' (@inr Œ± Œ≤ '' u))) ‚àß inr ‚Åª¬π' (inr '' u) = u
        rw [preimage_inl_image_inr, preimage_image_eq u Sum.inr_injective]
        exact ‚ü®‚ü®is_open_empty, hu‚ü©, rfl‚ü©
        ,
    inj := fun _ _ => inr.inj_iff.mp }

theorem is_open_range_inl : IsOpen (Range (inl : Œ± ‚Üí Sum Œ± Œ≤)) :=
  is_open_sum_iff.2 <| by
    simp

theorem is_open_range_inr : IsOpen (Range (inr : Œ≤ ‚Üí Sum Œ± Œ≤)) :=
  is_open_sum_iff.2 <| by
    simp

theorem is_closed_range_inl : IsClosed (Range (inl : Œ± ‚Üí Sum Œ± Œ≤)) := by
  rw [‚Üê is_open_compl_iff, compl_range_inl]
  exact is_open_range_inr

theorem is_closed_range_inr : IsClosed (Range (inr : Œ≤ ‚Üí Sum Œ± Œ≤)) := by
  rw [‚Üê is_open_compl_iff, compl_range_inr]
  exact is_open_range_inl

theorem open_embedding_inl : OpenEmbedding (inl : Œ± ‚Üí Sum Œ± Œ≤) :=
  { embedding_inl with open_range := is_open_range_inl }

theorem open_embedding_inr : OpenEmbedding (inr : Œ≤ ‚Üí Sum Œ± Œ≤) :=
  { embedding_inr with open_range := is_open_range_inr }

theorem closed_embedding_inl : ClosedEmbedding (inl : Œ± ‚Üí Sum Œ± Œ≤) :=
  { embedding_inl with closed_range := is_closed_range_inl }

theorem closed_embedding_inr : ClosedEmbedding (inr : Œ≤ ‚Üí Sum Œ± Œ≤) :=
  { embedding_inr with closed_range := is_closed_range_inr }

end Sum

section Subtype

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥] {p : Œ± ‚Üí Prop}

theorem inducing_coe {b : Set Œ≤} : Inducing (coe : b ‚Üí Œ≤) :=
  ‚ü®rfl‚ü©

theorem Inducing.of_cod_restrict {f : Œ± ‚Üí Œ≤} {b : Set Œ≤} (hb : ‚àÄ a, f a ‚àà b) (h : Inducing (b.codRestrict f hb)) :
    Inducing f :=
  inducing_coe.comp h

theorem embedding_subtype_coe : Embedding (coe : Subtype p ‚Üí Œ±) :=
  ‚ü®‚ü®rfl‚ü©, Subtype.coe_injective‚ü©

theorem closed_embedding_subtype_coe (h : IsClosed { a | p a }) : ClosedEmbedding (coe : Subtype p ‚Üí Œ±) :=
  ‚ü®embedding_subtype_coe, by
    rwa [Subtype.range_coe_subtype]‚ü©

@[continuity]
theorem continuous_subtype_val : Continuous (@Subtype.val Œ± p) :=
  continuous_induced_dom

theorem continuous_subtype_coe : Continuous (coe : Subtype p ‚Üí Œ±) :=
  continuous_subtype_val

theorem Continuous.subtype_coe {f : Œ≤ ‚Üí Subtype p} (hf : Continuous f) : Continuous fun x => (f x : Œ±) :=
  continuous_subtype_coe.comp hf

theorem IsOpen.open_embedding_subtype_coe {s : Set Œ±} (hs : IsOpen s) : OpenEmbedding (coe : s ‚Üí Œ±) :=
  { induced := rfl, inj := Subtype.coe_injective, open_range := (Subtype.range_coe : Range coe = s).symm ‚ñ∏ hs }

theorem IsOpen.is_open_map_subtype_coe {s : Set Œ±} (hs : IsOpen s) : IsOpenMap (coe : s ‚Üí Œ±) :=
  hs.open_embedding_subtype_coe.IsOpenMap

theorem IsOpenMap.restrict {f : Œ± ‚Üí Œ≤} (hf : IsOpenMap f) {s : Set Œ±} (hs : IsOpen s) : IsOpenMap (s.restrict f) :=
  hf.comp hs.is_open_map_subtype_coe

theorem IsClosed.closed_embedding_subtype_coe {s : Set Œ±} (hs : IsClosed s) :
    ClosedEmbedding (coe : { x // x ‚àà s } ‚Üí Œ±) :=
  { induced := rfl, inj := Subtype.coe_injective, closed_range := (Subtype.range_coe : Range coe = s).symm ‚ñ∏ hs }

@[continuity]
theorem continuous_subtype_mk {f : Œ≤ ‚Üí Œ±} (hp : ‚àÄ x, p (f x)) (h : Continuous f) :
    Continuous fun x => (‚ü®f x, hp x‚ü© : Subtype p) :=
  continuous_induced_rng.2 h

theorem continuous_inclusion {s t : Set Œ±} (h : s ‚äÜ t) : Continuous (inclusion h) :=
  continuous_subtype_mk _ continuous_subtype_coe

theorem continuous_at_subtype_coe {p : Œ± ‚Üí Prop} {a : Subtype p} : ContinuousAt (coe : Subtype p ‚Üí Œ±) a :=
  continuous_iff_continuous_at.mp continuous_subtype_coe _

theorem Subtype.dense_iff {s : Set Œ±} {t : Set s} : Dense t ‚Üî s ‚äÜ Closure (coe '' t) := by
  rw [inducing_coe.dense_iff, SetCoe.forall]
  rfl

theorem map_nhds_subtype_coe_eq {a : Œ±} (ha : p a) (h : { a | p a } ‚àà ùìù a) :
    map (coe : Subtype p ‚Üí Œ±) (ùìù ‚ü®a, ha‚ü©) = ùìù a :=
  map_nhds_induced_of_mem <| by
    simpa only [‚Üê Subtype.coe_mk, ‚Üê Subtype.range_coe] using h

theorem nhds_subtype_eq_comap {a : Œ±} {h : p a} : ùìù (‚ü®a, h‚ü© : Subtype p) = comap coe (ùìù a) :=
  nhds_induced _ _

theorem tendsto_subtype_rng {Œ≤ : Type _} {p : Œ± ‚Üí Prop} {b : Filter Œ≤} {f : Œ≤ ‚Üí Subtype p} :
    ‚àÄ {a : Subtype p}, Tendsto f b (ùìù a) ‚Üî Tendsto (fun x => (f x : Œ±)) b (ùìù (a : Œ±))
  | ‚ü®a, ha‚ü© => by
    rw [nhds_subtype_eq_comap, tendsto_comap_iff, Subtype.coe_mk]

theorem continuous_subtype_nhds_cover {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} {c : Œπ ‚Üí Œ± ‚Üí Prop}
    (c_cover : ‚àÄ x : Œ±, ‚àÉ i, { x | c i x } ‚àà ùìù x) (f_cont : ‚àÄ i, Continuous fun x : Subtype (c i) => f x) :
    Continuous f :=
  continuous_iff_continuous_at.mpr fun x =>
    let ‚ü®i, (c_sets : { x | c i x } ‚àà ùìù x)‚ü© := c_cover x
    let x' : Subtype (c i) := ‚ü®x, mem_of_mem_nhds c_sets‚ü©
    calc
      map f (ùìù x) = map f (map coe (ùìù x')) := congr_arg (map f) (map_nhds_subtype_coe_eq _ <| c_sets).symm
      _ = map (fun x : Subtype (c i) => f x) (ùìù x') := rfl
      _ ‚â§ ùìù (f x) := continuous_iff_continuous_at.mp (f_cont i) x'
      

theorem continuous_subtype_is_closed_cover {Œπ : Sort _} {f : Œ± ‚Üí Œ≤} (c : Œπ ‚Üí Œ± ‚Üí Prop)
    (h_lf : LocallyFinite fun i => { x | c i x }) (h_is_closed : ‚àÄ i, IsClosed { x | c i x })
    (h_cover : ‚àÄ x, ‚àÉ i, c i x) (f_cont : ‚àÄ i, Continuous fun x : Subtype (c i) => f x) : Continuous f :=
  continuous_iff_is_closed.mpr fun s hs => by
    have : ‚àÄ i, IsClosed ((coe : { x | c i x } ‚Üí Œ±) '' (f ‚àò coe ‚Åª¬π' s)) := fun i =>
      (closed_embedding_subtype_coe (h_is_closed _)).IsClosedMap _ (hs.Preimage (f_cont i))
    have : IsClosed (‚ãÉ i, (coe : { x | c i x } ‚Üí Œ±) '' (f ‚àò coe ‚Åª¬π' s)) :=
      LocallyFinite.is_closed_Union (h_lf.Subset fun i x ‚ü®‚ü®x', hx'‚ü©, _, HEq‚ü© => HEq ‚ñ∏ hx') this
    have : f ‚Åª¬π' s = ‚ãÉ i, (coe : { x | c i x } ‚Üí Œ±) '' (f ‚àò coe ‚Åª¬π' s) := by
      apply Set.ext
      have : ‚àÄ x : Œ±, f x ‚àà s ‚Üî ‚àÉ i : Œπ, c i x ‚àß f x ‚àà s := fun x =>
        ‚ü®fun hx =>
          let ‚ü®i, hi‚ü© := h_cover x
          ‚ü®i, hi, hx‚ü©,
          fun ‚ü®i, hi, hx‚ü© => hx‚ü©
      simpa [‚Üê And.comm, ‚Üê @And.left_comm (c _ _), exists_and_distrib_right]
    rwa [this]

theorem closure_subtype {x : { a // p a }} {s : Set { a // p a }} :
    x ‚àà Closure s ‚Üî (x : Œ±) ‚àà Closure ((coe : _ ‚Üí Œ±) '' s) :=
  closure_induced

theorem continuous_at_cod_restrict_iff {f : Œ± ‚Üí Œ≤} {t : Set Œ≤} (h1 : ‚àÄ x, f x ‚àà t) {x : Œ±} :
    ContinuousAt (codRestrict f t h1) x ‚Üî ContinuousAt f x := by
  simp_rw [inducing_coe.continuous_at_iff, Function.comp, coe_cod_restrict_apply]

alias continuous_at_cod_restrict_iff ‚Üî _ ContinuousAt.cod_restrict

theorem ContinuousAt.restrict {f : Œ± ‚Üí Œ≤} {s : Set Œ±} {t : Set Œ≤} (h1 : MapsTo f s t) {x : s} (h2 : ContinuousAt f x) :
    ContinuousAt (h1.restrict f s t) x :=
  (h2.comp continuous_at_subtype_coe).codRestrict _

theorem ContinuousAt.restrict_preimage {f : Œ± ‚Üí Œ≤} {s : Set Œ≤} {x : f ‚Åª¬π' s} (h : ContinuousAt f x) :
    ContinuousAt (s.restrictPreimage f) x :=
  h.restrict _

@[continuity]
theorem Continuous.cod_restrict {f : Œ± ‚Üí Œ≤} {s : Set Œ≤} (hf : Continuous f) (hs : ‚àÄ a, f a ‚àà s) :
    Continuous (s.codRestrict f hs) :=
  continuous_subtype_mk hs hf

theorem Inducing.cod_restrict {e : Œ± ‚Üí Œ≤} (he : Inducing e) {s : Set Œ≤} (hs : ‚àÄ x, e x ‚àà s) :
    Inducing (codRestrict e s hs) :=
  inducing_of_inducing_compose (he.Continuous.codRestrict hs) continuous_subtype_coe he

theorem Embedding.cod_restrict {e : Œ± ‚Üí Œ≤} (he : Embedding e) (s : Set Œ≤) (hs : ‚àÄ x, e x ‚àà s) :
    Embedding (codRestrict e s hs) :=
  embedding_of_embedding_compose (he.Continuous.codRestrict hs) continuous_subtype_coe he

end Subtype

section Quotient‚Çì

variable [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥]

variable {r : Œ± ‚Üí Œ± ‚Üí Prop} {s : Setoid‚Çì Œ±}

theorem quotient_map_quot_mk : QuotientMap (@Quot.mk Œ± r) :=
  ‚ü®Quot.exists_rep, rfl‚ü©

@[continuity]
theorem continuous_quot_mk : Continuous (@Quot.mk Œ± r) :=
  continuous_coinduced_rng

@[continuity]
theorem continuous_quot_lift {f : Œ± ‚Üí Œ≤} (hr : ‚àÄ a b, r a b ‚Üí f a = f b) (h : Continuous f) :
    Continuous (Quot.lift f hr : Quot r ‚Üí Œ≤) :=
  continuous_coinduced_dom.2 h

theorem quotient_map_quotient_mk : QuotientMap (@Quotient‚Çì.mk Œ± s) :=
  quotient_map_quot_mk

theorem continuous_quotient_mk : Continuous (@Quotient‚Çì.mk Œ± s) :=
  continuous_coinduced_rng

theorem Continuous.quotient_lift {f : Œ± ‚Üí Œ≤} (h : Continuous f) (hs : ‚àÄ a b, a ‚âà b ‚Üí f a = f b) :
    Continuous (Quotient‚Çì.lift f hs : Quotient‚Çì s ‚Üí Œ≤) :=
  continuous_coinduced_dom.2 h

theorem Continuous.quotient_lift_on' {f : Œ± ‚Üí Œ≤} (h : Continuous f) (hs : ‚àÄ a b, @Setoid‚Çì.R _ s a b ‚Üí f a = f b) :
    Continuous (fun x => Quotient‚Çì.liftOn' x f hs : Quotient‚Çì s ‚Üí Œ≤) :=
  h.quotient_lift hs

theorem Continuous.quotient_map' {t : Setoid‚Çì Œ≤} {f : Œ± ‚Üí Œ≤} (hf : Continuous f) (H : (s.R‚áít.R) f f) :
    Continuous (Quotient‚Çì.map' f H) :=
  (continuous_quotient_mk.comp hf).quotient_lift _

end Quotient‚Çì

section Pi

variable {Œπ : Type _} {œÄ : Œπ ‚Üí Type _}

@[continuity]
theorem continuous_pi [TopologicalSpace Œ±] [‚àÄ i, TopologicalSpace (œÄ i)] {f : Œ± ‚Üí ‚àÄ i : Œπ, œÄ i}
    (h : ‚àÄ i, Continuous fun a => f a i) : Continuous f :=
  continuous_infi_rng.2 fun i => continuous_induced_rng.2 <| h i

@[continuity]
theorem continuous_apply [‚àÄ i, TopologicalSpace (œÄ i)] (i : Œπ) : Continuous fun p : ‚àÄ i, œÄ i => p i :=
  continuous_infi_dom continuous_induced_dom

@[continuity]
theorem continuous_apply_apply {Œ∫ : Type _} {œÅ : Œ∫ ‚Üí Œπ ‚Üí Type _} [‚àÄ j i, TopologicalSpace (œÅ j i)] (j : Œ∫) (i : Œπ) :
    Continuous fun p : ‚àÄ j, ‚àÄ i, œÅ j i => p j i :=
  (continuous_apply i).comp (continuous_apply j)

theorem continuous_at_apply [‚àÄ i, TopologicalSpace (œÄ i)] (i : Œπ) (x : ‚àÄ i, œÄ i) :
    ContinuousAt (fun p : ‚àÄ i, œÄ i => p i) x :=
  (continuous_apply i).ContinuousAt

theorem Filter.Tendsto.apply [‚àÄ i, TopologicalSpace (œÄ i)] {l : Filter Œ±} {f : Œ± ‚Üí ‚àÄ i, œÄ i} {x : ‚àÄ i, œÄ i}
    (h : Tendsto f l (ùìù x)) (i : Œπ) : Tendsto (fun a => f a i) l (ùìù <| x i) :=
  (continuous_at_apply i _).Tendsto.comp h

theorem continuous_pi_iff [TopologicalSpace Œ±] [‚àÄ i, TopologicalSpace (œÄ i)] {f : Œ± ‚Üí ‚àÄ i, œÄ i} :
    Continuous f ‚Üî ‚àÄ i, Continuous fun y => f y i :=
  Iff.intro (fun h i => (continuous_apply i).comp h) continuous_pi

theorem nhds_pi [t : ‚àÄ i, TopologicalSpace (œÄ i)] {a : ‚àÄ i, œÄ i} : ùìù a = pi fun i => ùìù (a i) :=
  calc
    ùìù a = ‚®Ö i, @nhds _ (@TopologicalSpace.induced _ _ (fun x : ‚àÄ i, œÄ i => x i) (t i)) a := nhds_infi
    _ = ‚®Ö i, comap (fun x => x i) (ùìù (a i)) := by
      simp [‚Üê nhds_induced]
    

theorem tendsto_pi_nhds [t : ‚àÄ i, TopologicalSpace (œÄ i)] {f : Œ± ‚Üí ‚àÄ i, œÄ i} {g : ‚àÄ i, œÄ i} {u : Filter Œ±} :
    Tendsto f u (ùìù g) ‚Üî ‚àÄ x, Tendsto (fun i => f i x) u (ùìù (g x)) := by
  rw [nhds_pi, Filter.tendsto_pi]

theorem continuous_at_pi [‚àÄ i, TopologicalSpace (œÄ i)] [TopologicalSpace Œ±] {f : Œ± ‚Üí ‚àÄ i, œÄ i} {x : Œ±} :
    ContinuousAt f x ‚Üî ‚àÄ i, ContinuousAt (fun y => f y i) x :=
  tendsto_pi_nhds

theorem Filter.Tendsto.update [‚àÄ i, TopologicalSpace (œÄ i)] [DecidableEq Œπ] {l : Filter Œ±} {f : Œ± ‚Üí ‚àÄ i, œÄ i}
    {x : ‚àÄ i, œÄ i} (hf : Tendsto f l (ùìù x)) (i : Œπ) {g : Œ± ‚Üí œÄ i} {xi : œÄ i} (hg : Tendsto g l (ùìù xi)) :
    Tendsto (fun a => Function.update (f a) i (g a)) l (ùìù <| Function.update x i xi) :=
  tendsto_pi_nhds.2 fun j => by
    rcases em (j = i) with (rfl | hj) <;> simp [*, ‚Üê hf.apply]

theorem ContinuousAt.update [‚àÄ i, TopologicalSpace (œÄ i)] [TopologicalSpace Œ±] [DecidableEq Œπ] {f : Œ± ‚Üí ‚àÄ i, œÄ i}
    {a : Œ±} (hf : ContinuousAt f a) (i : Œπ) {g : Œ± ‚Üí œÄ i} (hg : ContinuousAt g a) :
    ContinuousAt (fun a => Function.update (f a) i (g a)) a :=
  hf.update i hg

theorem Continuous.update [‚àÄ i, TopologicalSpace (œÄ i)] [TopologicalSpace Œ±] [DecidableEq Œπ] {f : Œ± ‚Üí ‚àÄ i, œÄ i}
    (hf : Continuous f) (i : Œπ) {g : Œ± ‚Üí œÄ i} (hg : Continuous g) : Continuous fun a => Function.update (f a) i (g a) :=
  continuous_iff_continuous_at.2 fun x => hf.ContinuousAt.update i hg.ContinuousAt

/-- `function.update f i x` is continuous in `(f, x)`. -/
@[continuity]
theorem continuous_update [‚àÄ i, TopologicalSpace (œÄ i)] [DecidableEq Œπ] (i : Œπ) :
    Continuous fun f : (‚àÄ j, œÄ j) √ó œÄ i => Function.update f.1 i f.2 :=
  continuous_fst.update i continuous_snd

theorem Filter.Tendsto.fin_insert_nth {n} {œÄ : Fin‚Çì (n + 1) ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÄ i)] (i : Fin‚Çì (n + 1))
    {f : Œ± ‚Üí œÄ i} {l : Filter Œ±} {x : œÄ i} (hf : Tendsto f l (ùìù x)) {g : Œ± ‚Üí ‚àÄ j : Fin‚Çì n, œÄ (i.succAbove j)}
    {y : ‚àÄ j, œÄ (i.succAbove j)} (hg : Tendsto g l (ùìù y)) :
    Tendsto (fun a => i.insertNth (f a) (g a)) l (ùìù <| i.insertNth x y) :=
  tendsto_pi_nhds.2 fun j =>
    Fin‚Çì.succAboveCases i
      (by
        simpa)
      (by
        simpa using tendsto_pi_nhds.1 hg)
      j

theorem ContinuousAt.fin_insert_nth {n} {œÄ : Fin‚Çì (n + 1) ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÄ i)] [TopologicalSpace Œ±]
    (i : Fin‚Çì (n + 1)) {f : Œ± ‚Üí œÄ i} {a : Œ±} (hf : ContinuousAt f a) {g : Œ± ‚Üí ‚àÄ j : Fin‚Çì n, œÄ (i.succAbove j)}
    (hg : ContinuousAt g a) : ContinuousAt (fun a => i.insertNth (f a) (g a)) a :=
  hf.fin_insert_nth i hg

theorem Continuous.fin_insert_nth {n} {œÄ : Fin‚Çì (n + 1) ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÄ i)] [TopologicalSpace Œ±]
    (i : Fin‚Çì (n + 1)) {f : Œ± ‚Üí œÄ i} (hf : Continuous f) {g : Œ± ‚Üí ‚àÄ j : Fin‚Çì n, œÄ (i.succAbove j)} (hg : Continuous g) :
    Continuous fun a => i.insertNth (f a) (g a) :=
  continuous_iff_continuous_at.2 fun a => hf.ContinuousAt.fin_insert_nth i hg.ContinuousAt

theorem is_open_set_pi [‚àÄ a, TopologicalSpace (œÄ a)] {i : Set Œπ} {s : ‚àÄ a, Set (œÄ a)} (hi : i.Finite)
    (hs : ‚àÄ, ‚àÄ a ‚àà i, ‚àÄ, IsOpen (s a)) : IsOpen (pi i s) := by
  rw [pi_def] <;> exact (is_open_bInter hi) fun a ha => (hs _ ha).Preimage (continuous_apply _)

theorem is_closed_set_pi [‚àÄ a, TopologicalSpace (œÄ a)] {i : Set Œπ} {s : ‚àÄ a, Set (œÄ a)}
    (hs : ‚àÄ, ‚àÄ a ‚àà i, ‚àÄ, IsClosed (s a)) : IsClosed (pi i s) := by
  rw [pi_def] <;> exact is_closed_Inter fun a => is_closed_Inter fun ha => (hs _ ha).Preimage (continuous_apply _)

theorem mem_nhds_of_pi_mem_nhds {Œπ : Type _} {Œ± : Œπ ‚Üí Type _} [‚àÄ i : Œπ, TopologicalSpace (Œ± i)] {I : Set Œπ}
    {s : ‚àÄ i, Set (Œ± i)} (a : ‚àÄ i, Œ± i) (hs : I.pi s ‚àà ùìù a) {i : Œπ} (hi : i ‚àà I) : s i ‚àà ùìù (a i) := by
  rw [nhds_pi] at hs
  exact mem_of_pi_mem_pi hs hi

theorem set_pi_mem_nhds [‚àÄ a, TopologicalSpace (œÄ a)] {i : Set Œπ} {s : ‚àÄ a, Set (œÄ a)} {x : ‚àÄ a, œÄ a} (hi : i.Finite)
    (hs : ‚àÄ, ‚àÄ a ‚àà i, ‚àÄ, s a ‚àà ùìù (x a)) : pi i s ‚àà ùìù x := by
  rw [pi_def, bInter_mem hi]
  exact fun a ha => (continuous_apply a).ContinuousAt (hs a ha)

theorem set_pi_mem_nhds_iff {Œ± : Œπ ‚Üí Type _} [‚àÄ i : Œπ, TopologicalSpace (Œ± i)] {I : Set Œπ} (hI : I.Finite)
    {s : ‚àÄ i, Set (Œ± i)} (a : ‚àÄ i, Œ± i) : I.pi s ‚àà ùìù a ‚Üî ‚àÄ i : Œπ, i ‚àà I ‚Üí s i ‚àà ùìù (a i) := by
  rw [nhds_pi, pi_mem_pi_iff hI]
  infer_instance

theorem interior_pi_set {Œ± : Œπ ‚Üí Type _} [‚àÄ i, TopologicalSpace (Œ± i)] {I : Set Œπ} (hI : I.Finite)
    {s : ‚àÄ i, Set (Œ± i)} : Interior (pi I s) = I.pi fun i => Interior (s i) := by
  ext a
  simp only [‚Üê Set.mem_pi, ‚Üê mem_interior_iff_mem_nhds, ‚Üê set_pi_mem_nhds_iff hI]

theorem exists_finset_piecewise_mem_of_mem_nhds [DecidableEq Œπ] [‚àÄ i, TopologicalSpace (œÄ i)] {s : Set (‚àÄ a, œÄ a)}
    {x : ‚àÄ a, œÄ a} (hs : s ‚àà ùìù x) (y : ‚àÄ a, œÄ a) : ‚àÉ I : Finset Œπ, I.piecewise x y ‚àà s := by
  simp only [‚Üê nhds_pi, ‚Üê Filter.mem_pi'] at hs
  rcases hs with ‚ü®I, t, htx, hts‚ü©
  refine' ‚ü®I, hts fun i hi => _‚ü©
  simpa [‚Üê Finset.mem_coe.1 hi] using mem_of_mem_nhds (htx i)

theorem pi_eq_generate_from [‚àÄ a, TopologicalSpace (œÄ a)] :
    Pi.topologicalSpace =
      generateFrom { g | ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ), (‚àÄ, ‚àÄ a ‚àà i, ‚àÄ, IsOpen (s a)) ‚àß g = pi (‚Üëi) s } :=
  le_antisymm‚Çì (le_generate_from fun g ‚ü®s, i, hi, Eq‚ü© => Eq.symm ‚ñ∏ is_open_set_pi (Finset.finite_to_set _) hi)
    (le_infi fun a s ‚ü®t, ht, s_eq‚ü© =>
      GenerateOpen.basic _ <|
        ‚ü®Function.update (fun a => Univ) a t, {a}, by
          simpa using ht,
          s_eq ‚ñ∏ by
            ext f <;> simp [‚Üê Set.Pi]‚ü©)

theorem pi_generate_from_eq {g : ‚àÄ a, Set (Set (œÄ a))} :
    (@Pi.topologicalSpace Œπ œÄ fun a => generateFrom (g a)) =
      generateFrom { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ), (‚àÄ, ‚àÄ a ‚àà i, ‚àÄ, s a ‚àà g a) ‚àß t = pi (‚Üëi) s } :=
  by
  let G := { t | ‚àÉ (s : ‚àÄ a, Set (œÄ a))(i : Finset Œπ), (‚àÄ, ‚àÄ a ‚àà i, ‚àÄ, s a ‚àà g a) ‚àß t = pi (‚Üëi) s }
  rw [pi_eq_generate_from]
  refine' le_antisymm‚Çì (generate_from_mono _) (le_generate_from _)
  exact fun s ‚ü®t, i, ht, Eq‚ü© => ‚ü®t, i, fun a ha => generate_open.basic _ (ht a ha), Eq‚ü©
  ¬∑ rintro s ‚ü®t, i, hi, rfl‚ü©
    rw [pi_def]
    apply is_open_bInter (Finset.finite_to_set _)
    intro a ha
    show ((generate_from G).coinduced fun f : ‚àÄ a, œÄ a => f a).IsOpen (t a)
    refine' le_generate_from _ _ (hi a ha)
    exact fun s hs =>
      generate_open.basic _
        ‚ü®Function.update (fun a => univ) a s, {a}, by
          simp [‚Üê hs]‚ü©
    

theorem pi_generate_from_eq_finite {g : ‚àÄ a, Set (Set (œÄ a))} [Finite Œπ] (hg : ‚àÄ a, ‚ãÉ‚ÇÄg a = univ) :
    (@Pi.topologicalSpace Œπ œÄ fun a => generateFrom (g a)) =
      generateFrom { t | ‚àÉ s : ‚àÄ a, Set (œÄ a), (‚àÄ a, s a ‚àà g a) ‚àß t = pi Univ s } :=
  by
  cases nonempty_fintype Œπ
  rw [pi_generate_from_eq]
  refine' le_antisymm‚Çì (generate_from_mono _) (le_generate_from _)
  exact fun s ‚ü®t, ht, Eq‚ü© =>
    ‚ü®t, Finset.univ, by
      simp [‚Üê ht, ‚Üê Eq]‚ü©
  ¬∑ rintro s ‚ü®t, i, ht, rfl‚ü©
    apply is_open_iff_forall_mem_open.2 _
    intro f hf
    choose c hc using
      show ‚àÄ a, ‚àÉ s, s ‚àà g a ‚àß f a ‚àà s by
        intro a
        have : f a ‚àà ‚ãÉ‚ÇÄg a := by
          rw [hg]
          apply mem_univ
        simpa
    refine' ‚ü®pi univ fun a => if a ‚àà i then t a else (c : ‚àÄ a, Set (œÄ a)) a, _, _, _‚ü©
    ¬∑ simp [‚Üê pi_if]
      
    ¬∑ refine' generate_open.basic _ ‚ü®_, fun a => _, rfl‚ü©
      by_cases' a ‚àà i <;> simp_all [‚Üê Set.Pi]
      
    ¬∑ have : f ‚àà pi { a | a ‚àâ i } c := by
        simp_all [‚Üê Set.Pi]
      simpa [‚Üê pi_if, ‚Üê hf]
      
    

/-- Suppose `œÄ i` is a family of topological spaces indexed by `i : Œπ`, and `X` is a type
endowed with a family of maps `f i : X ‚Üí œÄ i` for every `i : Œπ`, hence inducing a
map `g : X ‚Üí Œ† i, œÄ i`. This lemma shows that infimum of the topologies on `X` induced by
the `f i` as `i : Œπ` varies is simply the topology on `X` induced by `g : X ‚Üí Œ† i, œÄ i`
where `Œ† i, œÄ i` is endowed with the usual product topology. -/
theorem inducing_infi_to_pi {X : Type _} [‚àÄ i, TopologicalSpace (œÄ i)] (f : ‚àÄ i, X ‚Üí œÄ i) :
    @Inducing X (‚àÄ i, œÄ i) (‚®Ö i, induced (f i) inferInstance) _ fun x i => f i x := by
  constructor
  erw [induced_infi]
  congr 1
  funext
  erw [induced_compose]

variable [Finite Œπ] [‚àÄ i, TopologicalSpace (œÄ i)] [‚àÄ i, DiscreteTopology (œÄ i)]

/-- A finite product of discrete spaces is discrete. -/
instance Pi.discrete_topology : DiscreteTopology (‚àÄ i, œÄ i) :=
  singletons_open_iff_discrete.mp fun x => by
    rw
      [show {x} = ‚ãÇ i, { y : ‚àÄ i, œÄ i | y i = x i } by
        ext
        simp only [‚Üê Function.funext_iff‚Çì, ‚Üê Set.mem_singleton_iff, ‚Üê Set.mem_Inter, ‚Üê Set.mem_set_of_eq]]
    exact is_open_Inter fun i => (continuous_apply i).is_open_preimage {x i} (is_open_discrete {x i})

end Pi

section Sigma

variable {Œπ : Type _} {œÉ : Œπ ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÉ i)]

@[continuity]
theorem continuous_sigma_mk {i : Œπ} : Continuous (@Sigma.mk Œπ œÉ i) :=
  continuous_supr_rng continuous_coinduced_rng

theorem is_open_sigma_iff {s : Set (Sigma œÉ)} : IsOpen s ‚Üî ‚àÄ i, IsOpen (Sigma.mk i ‚Åª¬π' s) := by
  simp only [‚Üê is_open_supr_iff, ‚Üê is_open_coinduced]

theorem is_closed_sigma_iff {s : Set (Sigma œÉ)} : IsClosed s ‚Üî ‚àÄ i, IsClosed (Sigma.mk i ‚Åª¬π' s) := by
  simp only [is_open_compl_iff, ‚Üê is_open_sigma_iff, ‚Üê preimage_compl]

theorem is_open_map_sigma_mk {i : Œπ} : IsOpenMap (@Sigma.mk Œπ œÉ i) := by
  intro s hs
  rw [is_open_sigma_iff]
  intro j
  rcases eq_or_ne i j with (rfl | hne)
  ¬∑ rwa [Set.preimage_image_eq _ sigma_mk_injective]
    
  ¬∑ convert is_open_empty
    apply Set.eq_empty_of_subset_empty
    rintro x ‚ü®y, _, hy‚ü©
    have : i = j := by
      cc
    contradiction
    

theorem is_open_range_sigma_mk {i : Œπ} : IsOpen (Set.Range (@Sigma.mk Œπ œÉ i)) :=
  is_open_map_sigma_mk.is_open_range

theorem is_closed_map_sigma_mk {i : Œπ} : IsClosedMap (@Sigma.mk Œπ œÉ i) := by
  intro s hs
  rw [is_closed_sigma_iff]
  intro j
  rcases eq_or_ne i j with (rfl | hne)
  ¬∑ rwa [Set.preimage_image_eq _ sigma_mk_injective]
    
  ¬∑ convert is_closed_empty
    apply Set.eq_empty_of_subset_empty
    rintro x ‚ü®y, _, hy‚ü©
    have : i = j := by
      cc
    contradiction
    

theorem is_closed_sigma_mk {i : Œπ} : IsClosed (Set.Range (@Sigma.mk Œπ œÉ i)) := by
  rw [‚Üê Set.image_univ]
  exact is_closed_map_sigma_mk _ is_closed_univ

theorem open_embedding_sigma_mk {i : Œπ} : OpenEmbedding (@Sigma.mk Œπ œÉ i) :=
  open_embedding_of_continuous_injective_open continuous_sigma_mk sigma_mk_injective is_open_map_sigma_mk

theorem closed_embedding_sigma_mk {i : Œπ} : ClosedEmbedding (@Sigma.mk Œπ œÉ i) :=
  closed_embedding_of_continuous_injective_closed continuous_sigma_mk sigma_mk_injective is_closed_map_sigma_mk

theorem embedding_sigma_mk {i : Œπ} : Embedding (@Sigma.mk Œπ œÉ i) :=
  closed_embedding_sigma_mk.1

theorem is_open_sigma_fst_preimage (s : Set Œπ) : IsOpen (Sigma.fst ‚Åª¬π' s : Set (Œ£a, œÉ a)) := by
  rw [‚Üê bUnion_of_singleton s, preimage_Union‚ÇÇ]
  simp only [range_sigma_mk]
  exact is_open_bUnion fun _ _ => is_open_range_sigma_mk

/-- A map out of a sum type is continuous if its restriction to each summand is. -/
@[continuity]
theorem continuous_sigma [TopologicalSpace Œ≤] {f : Sigma œÉ ‚Üí Œ≤} (h : ‚àÄ i, Continuous fun a => f ‚ü®i, a‚ü©) :
    Continuous f :=
  continuous_supr_dom.2 fun i => continuous_coinduced_dom.2 (h i)

@[continuity]
theorem continuous_sigma_map {Œ∫ : Type _} {œÑ : Œ∫ ‚Üí Type _} [‚àÄ k, TopologicalSpace (œÑ k)] {f‚ÇÅ : Œπ ‚Üí Œ∫}
    {f‚ÇÇ : ‚àÄ i, œÉ i ‚Üí œÑ (f‚ÇÅ i)} (hf : ‚àÄ i, Continuous (f‚ÇÇ i)) : Continuous (Sigma.map f‚ÇÅ f‚ÇÇ) :=
  continuous_sigma fun i => show Continuous fun a => Sigma.mk (f‚ÇÅ i) (f‚ÇÇ i a) from continuous_sigma_mk.comp (hf i)

theorem is_open_map_sigma [TopologicalSpace Œ≤] {f : Sigma œÉ ‚Üí Œ≤} (h : ‚àÄ i, IsOpenMap fun a => f ‚ü®i, a‚ü©) : IsOpenMap f :=
  by
  intro s hs
  rw [is_open_sigma_iff] at hs
  rw [‚Üê Union_image_preimage_sigma_mk_eq_self s, image_Union]
  apply is_open_Union
  intro i
  rw [image_image]
  exact h i _ (hs i)

/-- The sum of embeddings is an embedding. -/
theorem embedding_sigma_map {œÑ : Œπ ‚Üí Type _} [‚àÄ i, TopologicalSpace (œÑ i)] {f : ‚àÄ i, œÉ i ‚Üí œÑ i}
    (hf : ‚àÄ i, Embedding (f i)) : Embedding (Sigma.map id f) := by
  refine' ‚ü®‚ü®_‚ü©, function.injective_id.sigma_map fun i => (hf i).inj‚ü©
  refine' le_antisymm‚Çì (continuous_iff_le_induced.mp (continuous_sigma_map fun i => (hf i).Continuous)) _
  intro s hs
  replace hs := is_open_sigma_iff.mp hs
  have : ‚àÄ i, ‚àÉ t, IsOpen t ‚àß f i ‚Åª¬π' t = Sigma.mk i ‚Åª¬π' s := by
    intro i
    apply is_open_induced_iff.mp
    convert hs i
    exact (hf i).induced.symm
  choose t ht using this
  apply is_open_induced_iff.mpr
  refine' ‚ü®‚ãÉ i, Sigma.mk i '' t i, is_open_Union fun i => is_open_map_sigma_mk _ (ht i).1, _‚ü©
  ext ‚ü®i, x‚ü©
  change (Sigma.mk i (f i x) ‚àà ‚ãÉ i : Œπ, Sigma.mk i '' t i) ‚Üî x ‚àà Sigma.mk i ‚Åª¬π' s
  rw [‚Üê (ht i).2, mem_Union]
  constructor
  ¬∑ rintro ‚ü®j, hj‚ü©
    rw [mem_image] at hj
    rcases hj with ‚ü®y, hy‚ÇÅ, hy‚ÇÇ‚ü©
    rcases sigma.mk.inj_iff.mp hy‚ÇÇ with ‚ü®rfl, hy‚ü©
    replace hy := eq_of_heq hy
    subst y
    exact hy‚ÇÅ
    
  ¬∑ intro hx
    use i
    rw [mem_image]
    exact ‚ü®f i x, hx, rfl‚ü©
    

end Sigma

section ULift

@[continuity]
theorem continuous_ulift_down [TopologicalSpace Œ±] : Continuous (ULift.down : ULift.{v, u} Œ± ‚Üí Œ±) :=
  continuous_induced_dom

@[continuity]
theorem continuous_ulift_up [TopologicalSpace Œ±] : Continuous (ULift.up : Œ± ‚Üí ULift.{v, u} Œ±) :=
  continuous_induced_rng.2 continuous_id

end ULift

theorem mem_closure_of_continuous [TopologicalSpace Œ±] [TopologicalSpace Œ≤] {f : Œ± ‚Üí Œ≤} {a : Œ±} {s : Set Œ±} {t : Set Œ≤}
    (hf : Continuous f) (ha : a ‚àà Closure s) (h : MapsTo f s (Closure t)) : f a ‚àà Closure t :=
  calc
    f a ‚àà f '' Closure s := mem_image_of_mem _ ha
    _ ‚äÜ Closure (f '' s) := image_closure_subset_closure_image hf
    _ ‚äÜ Closure t := closure_minimal h.image_subset is_closed_closure
    

theorem mem_closure_of_continuous2 [TopologicalSpace Œ±] [TopologicalSpace Œ≤] [TopologicalSpace Œ≥] {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥}
    {a : Œ±} {b : Œ≤} {s : Set Œ±} {t : Set Œ≤} {u : Set Œ≥} (hf : Continuous fun p : Œ± √ó Œ≤ => f p.1 p.2)
    (ha : a ‚àà Closure s) (hb : b ‚àà Closure t) (h : ‚àÄ, ‚àÄ a ‚àà s, ‚àÄ, ‚àÄ, ‚àÄ b ‚àà t, ‚àÄ, f a b ‚àà Closure u) :
    f a b ‚àà Closure u :=
  have : (a, b) ‚àà Closure (s √óÀ¢ t) := by
    simp [‚Üê closure_prod_eq, ‚Üê ha, ‚Üê hb]
  show f (a, b).1 (a, b).2 ‚àà Closure u from
    (@mem_closure_of_continuous (Œ± √ó Œ≤) _ _ _ (fun p : Œ± √ó Œ≤ => f p.1 p.2) (a, b) _ u hf this) fun ‚ü®p‚ÇÅ, p‚ÇÇ‚ü© ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
      h p‚ÇÅ h‚ÇÅ p‚ÇÇ h‚ÇÇ

