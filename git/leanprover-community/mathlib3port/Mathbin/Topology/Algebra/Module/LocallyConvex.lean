/-
Copyright (c) 2022 Anatole Dedecker. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Anatole Dedecker
-/
import Mathbin.Analysis.Convex.Topology

/-!
# Locally convex topological modules

A `locally_convex_space` is a topological semimodule over an ordered semiring in which any point
admits a neighborhood basis made of convex sets, or equivalently, in which convex neighborhoods of
a point form a neighborhood basis at that point.

In a module, this is equivalent to `0` satisfying such properties.

## Main results

- `locally_convex_space_iff_zero` : in a module, local convexity at zero gives
  local convexity everywhere
- `seminorm.locally_convex_space` : a topology generated by a family of seminorms is locally convex
- `normed_space.locally_convex_space` : a normed space is locally convex

## TODO

- define a structure `locally_convex_filter_basis`, extending `module_filter_basis`, for filter
  bases generating a locally convex topology
- show that any locally convex topology is generated by a family of seminorms

-/


open TopologicalSpace Filter

open_locale TopologicalSpace

section Semimodule

/-- A `locally_convex_space` is a topological semimodule over an ordered semiring in which convex
neighborhoods of a point form a neighborhood basis at that point. -/
class LocallyConvexSpace (𝕜 E : Type _) [OrderedSemiring 𝕜] [AddCommMonoidₓ E] [Module 𝕜 E] [TopologicalSpace E] :
  Prop where
  convex_basis : ∀ x : E, (𝓝 x).HasBasis (fun s : Set E => s ∈ 𝓝 x ∧ Convex 𝕜 s) id

variable (𝕜 E : Type _) [OrderedSemiring 𝕜] [AddCommMonoidₓ E] [Module 𝕜 E] [TopologicalSpace E]

theorem locally_convex_space_iff :
    LocallyConvexSpace 𝕜 E ↔ ∀ x : E, (𝓝 x).HasBasis (fun s : Set E => s ∈ 𝓝 x ∧ Convex 𝕜 s) id :=
  ⟨@LocallyConvexSpace.convex_basis _ _ _ _ _ _, LocallyConvexSpace.mk⟩

theorem LocallyConvexSpace.of_bases {ι : Type _} (b : E → ι → Set E) (p : ι → Prop)
    (hbasis : ∀ x : E, (𝓝 x).HasBasis p (b x)) (hconvex : ∀ x i, p i → Convex 𝕜 (b x i)) : LocallyConvexSpace 𝕜 E :=
  ⟨fun x =>
    (hbasis x).to_has_basis (fun i hi => ⟨b x i, ⟨⟨(hbasis x).mem_of_mem hi, hconvex x i hi⟩, le_reflₓ (b x i)⟩⟩)
      fun s hs => ⟨(hbasis x).index s hs.1, ⟨(hbasis x).property_index hs.1, (hbasis x).set_index_subset hs.1⟩⟩⟩

theorem LocallyConvexSpace.convex_basis_zero [LocallyConvexSpace 𝕜 E] :
    (𝓝 0 : Filter E).HasBasis (fun s => s ∈ (𝓝 0 : Filter E) ∧ Convex 𝕜 s) id :=
  LocallyConvexSpace.convex_basis 0

theorem locally_convex_space_iff_exists_convex_subset :
    LocallyConvexSpace 𝕜 E ↔ ∀ x : E, ∀, ∀ U ∈ 𝓝 x, ∀, ∃ S ∈ 𝓝 x, Convex 𝕜 S ∧ S ⊆ U :=
  (locally_convex_space_iff 𝕜 E).trans (forall_congrₓ fun x => has_basis_self)

end Semimodule

section Module

variable (𝕜 E : Type _) [OrderedSemiring 𝕜] [AddCommGroupₓ E] [Module 𝕜 E] [TopologicalSpace E] [TopologicalAddGroup E]

theorem LocallyConvexSpace.of_basis_zero {ι : Type _} (b : ι → Set E) (p : ι → Prop) (hbasis : (𝓝 0).HasBasis p b)
    (hconvex : ∀ i, p i → Convex 𝕜 (b i)) : LocallyConvexSpace 𝕜 E := by
  refine'
    LocallyConvexSpace.of_bases 𝕜 E (fun i : ι => (· + ·) x '' b i) p (fun x => _) fun x i hi =>
      (hconvex i hi).translate x
  rw [← map_add_left_nhds_zero]
  exact hbasis.map _

theorem locally_convex_space_iff_zero :
    LocallyConvexSpace 𝕜 E ↔ (𝓝 0 : Filter E).HasBasis (fun s : Set E => s ∈ (𝓝 0 : Filter E) ∧ Convex 𝕜 s) id :=
  ⟨fun h => @LocallyConvexSpace.convex_basis _ _ _ _ _ _ h 0, fun h =>
    LocallyConvexSpace.of_basis_zero 𝕜 E _ _ h fun s => And.right⟩

theorem locally_convex_space_iff_exists_convex_subset_zero :
    LocallyConvexSpace 𝕜 E ↔ ∀, ∀ U ∈ (𝓝 0 : Filter E), ∀, ∃ S ∈ (𝓝 0 : Filter E), Convex 𝕜 S ∧ S ⊆ U :=
  (locally_convex_space_iff_zero 𝕜 E).trans has_basis_self

end Module

