/-
Copyright (c) 2021 Alex Kontorovich, Heather Macbeth. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Alex Kontorovich, Heather Macbeth
-/
import Mathbin.Topology.Algebra.Constructions
import Mathbin.Topology.Homeomorph
import Mathbin.GroupTheory.GroupAction.Basic

/-!
# Monoid actions continuous in the second variable

In this file we define class `has_continuous_const_smul`. We say `has_continuous_const_smul Œì T` if
`Œì` acts on `T` and for each `Œ≥`, the map `x ‚Ü¶ Œ≥ ‚Ä¢ x` is continuous. (This differs from
`has_continuous_smul`, which requires simultaneous continuity in both variables.)

## Main definitions

* `has_continuous_const_smul Œì T` : typeclass saying that the map `x ‚Ü¶ Œ≥ ‚Ä¢ x` is continuous on `T`;
* `properly_discontinuous_smul`: says that the scalar multiplication `(‚Ä¢) : Œì ‚Üí T ‚Üí T`
  is properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely
  many `Œ≥:Œì` move `K` to have nontrivial intersection with `L`.
* `homeomorph.smul`: scalar multiplication by an element of a group `Œì` acting on `T`
  is a homeomorphism of `T`.

## Main results

* `is_open_map_quotient_mk_mul` : The quotient map by a group action is open.
* `t2_space_of_properly_discontinuous_smul_of_t2_space` : The quotient by a discontinuous group
  action of a locally compact t2 space is t2.

## Tags

Hausdorff, discrete group, properly discontinuous, quotient space

-/


open TopologicalSpace Pointwise

open Filter Set

attribute [local instance] MulAction.orbitRel

/-- Class `has_continuous_const_smul Œì T` says that the scalar multiplication `(‚Ä¢) : Œì ‚Üí T ‚Üí T`
is continuous in the second argument. We use the same class for all kinds of multiplicative
actions, including (semi)modules and algebras.
-/
class HasContinuousConstSmul (Œì : Type _) (T : Type _) [TopologicalSpace T] [HasSmul Œì T] : Prop where
  continuous_const_smul : ‚àÄ Œ≥ : Œì, Continuous fun x : T => Œ≥ ‚Ä¢ x

/-- Class `has_continuous_const_vadd Œì T` says that the additive action `(+·µ•) : Œì ‚Üí T ‚Üí T`
is continuous in the second argument. We use the same class for all kinds of additive actions,
including (semi)modules and algebras.
-/
class HasContinuousConstVadd (Œì : Type _) (T : Type _) [TopologicalSpace T] [HasVadd Œì T] : Prop where
  continuous_const_vadd : ‚àÄ Œ≥ : Œì, Continuous fun x : T => Œ≥ +·µ• x

attribute [to_additive] HasContinuousConstSmul

export HasContinuousConstSmul (continuous_const_smul)

export HasContinuousConstVadd (continuous_const_vadd)

variable {M Œ± Œ≤ : Type _}

section HasSmul

variable [TopologicalSpace Œ±] [HasSmul M Œ±] [HasContinuousConstSmul M Œ±]

@[to_additive]
theorem Filter.Tendsto.const_smul {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {a : Œ±} (hf : Tendsto f l (ùìù a)) (c : M) :
    Tendsto (fun x => c ‚Ä¢ f x) l (ùìù (c ‚Ä¢ a)) :=
  ((continuous_const_smul _).Tendsto _).comp hf

variable [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí M} {g : Œ≤ ‚Üí Œ±} {b : Œ≤} {s : Set Œ≤}

@[to_additive]
theorem ContinuousWithinAt.const_smul (hg : ContinuousWithinAt g s b) (c : M) :
    ContinuousWithinAt (fun x => c ‚Ä¢ g x) s b :=
  hg.const_smul c

@[to_additive]
theorem ContinuousAt.const_smul (hg : ContinuousAt g b) (c : M) : ContinuousAt (fun x => c ‚Ä¢ g x) b :=
  hg.const_smul c

@[to_additive]
theorem ContinuousOn.const_smul (hg : ContinuousOn g s) (c : M) : ContinuousOn (fun x => c ‚Ä¢ g x) s := fun x hx =>
  (hg x hx).const_smul c

@[continuity, to_additive]
theorem Continuous.const_smul (hg : Continuous g) (c : M) : Continuous fun x => c ‚Ä¢ g x :=
  (continuous_const_smul _).comp hg

/-- If a scalar is central, then its right action is continuous when its left action is. -/
instance HasContinuousConstSmul.op [HasSmul M·µê·µí·µñ Œ±] [IsCentralScalar M Œ±] : HasContinuousConstSmul M·µê·µí·µñ Œ± :=
  ‚ü®MulOpposite.rec fun c => by
      simpa only [‚Üê op_smul_eq_smul] using continuous_const_smul c‚ü©

@[to_additive]
instance MulOpposite.has_continuous_const_smul : HasContinuousConstSmul M Œ±·µê·µí·µñ :=
  ‚ü®fun c => MulOpposite.continuous_op.comp <| MulOpposite.continuous_unop.const_smul c‚ü©

@[to_additive]
instance [HasSmul M Œ≤] [HasContinuousConstSmul M Œ≤] : HasContinuousConstSmul M (Œ± √ó Œ≤) :=
  ‚ü®fun _ => (continuous_fst.const_smul _).prod_mk (continuous_snd.const_smul _)‚ü©

@[to_additive]
instance {Œπ : Type _} {Œ≥ : Œπ ‚Üí Type _} [‚àÄ i, TopologicalSpace (Œ≥ i)] [‚àÄ i, HasSmul M (Œ≥ i)]
    [‚àÄ i, HasContinuousConstSmul M (Œ≥ i)] : HasContinuousConstSmul M (‚àÄ i, Œ≥ i) :=
  ‚ü®fun _ => continuous_pi fun i => (continuous_apply i).const_smul _‚ü©

end HasSmul

section Monoid‚Çì

variable [TopologicalSpace Œ±]

variable [Monoid‚Çì M] [MulAction M Œ±] [HasContinuousConstSmul M Œ±]

@[to_additive]
instance Units.has_continuous_const_smul :
    HasContinuousConstSmul MÀ£ Œ± where continuous_const_smul := fun m => (continuous_const_smul (m : M) : _)

@[to_additive]
theorem smul_closure_subset (c : M) (s : Set Œ±) : c ‚Ä¢ Closure s ‚äÜ Closure (c ‚Ä¢ s) :=
  ((Set.maps_to_image _ _).closure <| continuous_id.const_smul c).image_subset

@[to_additive]
theorem smul_closure_orbit_subset (c : M) (x : Œ±) : c ‚Ä¢ Closure (MulAction.Orbit M x) ‚äÜ Closure (MulAction.Orbit M x) :=
  (smul_closure_subset c _).trans <| closure_mono <| MulAction.smul_orbit_subset _ _

end Monoid‚Çì

section Group‚Çì

variable {G : Type _} [TopologicalSpace Œ±] [Group‚Çì G] [MulAction G Œ±] [HasContinuousConstSmul G Œ±]

@[to_additive]
theorem tendsto_const_smul_iff {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {a : Œ±} (c : G) :
    Tendsto (fun x => c ‚Ä¢ f x) l (ùìù <| c ‚Ä¢ a) ‚Üî Tendsto f l (ùìù a) :=
  ‚ü®fun h => by
    simpa only [‚Üê inv_smul_smul] using h.const_smul c‚Åª¬π, fun h => h.const_smul _‚ü©

variable [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} {s : Set Œ≤}

@[to_additive]
theorem continuous_within_at_const_smul_iff (c : G) :
    ContinuousWithinAt (fun x => c ‚Ä¢ f x) s b ‚Üî ContinuousWithinAt f s b :=
  tendsto_const_smul_iff c

@[to_additive]
theorem continuous_on_const_smul_iff (c : G) : ContinuousOn (fun x => c ‚Ä¢ f x) s ‚Üî ContinuousOn f s :=
  forall‚ÇÇ_congr‚Çì fun b hb => continuous_within_at_const_smul_iff c

@[to_additive]
theorem continuous_at_const_smul_iff (c : G) : ContinuousAt (fun x => c ‚Ä¢ f x) b ‚Üî ContinuousAt f b :=
  tendsto_const_smul_iff c

@[to_additive]
theorem continuous_const_smul_iff (c : G) : (Continuous fun x => c ‚Ä¢ f x) ‚Üî Continuous f := by
  simp only [‚Üê continuous_iff_continuous_at, ‚Üê continuous_at_const_smul_iff]

/-- The homeomorphism given by scalar multiplication by a given element of a group `Œì` acting on
  `T` is a homeomorphism from `T` to itself. -/
@[to_additive]
def Homeomorph.smul (Œ≥ : G) : Œ± ‚âÉ‚Çú Œ± where
  toEquiv := MulAction.toPerm Œ≥
  continuous_to_fun := continuous_const_smul Œ≥
  continuous_inv_fun := continuous_const_smul Œ≥‚Åª¬π

-- ./././Mathport/Syntax/Translate/Tactic/Basic.lean:51:50: missing argument
-- ./././Mathport/Syntax/Translate/Basic.lean:1780:43: in add_decl_doc #[[ident homeomorph.vadd]]: ./././Mathport/Syntax/Translate/Tactic/Basic.lean:54:35: expecting parse arg
@[to_additive]
theorem is_open_map_smul (c : G) : IsOpenMap fun x : Œ± => c ‚Ä¢ x :=
  (Homeomorph.smul c).IsOpenMap

@[to_additive]
theorem IsOpen.smul {s : Set Œ±} (hs : IsOpen s) (c : G) : IsOpen (c ‚Ä¢ s) :=
  is_open_map_smul c s hs

@[to_additive]
theorem is_closed_map_smul (c : G) : IsClosedMap fun x : Œ± => c ‚Ä¢ x :=
  (Homeomorph.smul c).IsClosedMap

@[to_additive]
theorem IsClosed.smul {s : Set Œ±} (hs : IsClosed s) (c : G) : IsClosed (c ‚Ä¢ s) :=
  is_closed_map_smul c s hs

@[to_additive]
theorem closure_smul (c : G) (s : Set Œ±) : Closure (c ‚Ä¢ s) = c ‚Ä¢ Closure s :=
  ((Homeomorph.smul c).image_closure s).symm

@[to_additive]
theorem interior_smul (c : G) (s : Set Œ±) : Interior (c ‚Ä¢ s) = c ‚Ä¢ Interior s :=
  ((Homeomorph.smul c).image_interior s).symm

end Group‚Çì

section GroupWithZero‚Çì

variable {G‚ÇÄ : Type _} [TopologicalSpace Œ±] [GroupWithZero‚Çì G‚ÇÄ] [MulAction G‚ÇÄ Œ±] [HasContinuousConstSmul G‚ÇÄ Œ±]

theorem tendsto_const_smul_iff‚ÇÄ {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {a : Œ±} {c : G‚ÇÄ} (hc : c ‚â† 0) :
    Tendsto (fun x => c ‚Ä¢ f x) l (ùìù <| c ‚Ä¢ a) ‚Üî Tendsto f l (ùìù a) :=
  tendsto_const_smul_iff (Units.mk0 c hc)

variable [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} {c : G‚ÇÄ} {s : Set Œ≤}

theorem continuous_within_at_const_smul_iff‚ÇÄ (hc : c ‚â† 0) :
    ContinuousWithinAt (fun x => c ‚Ä¢ f x) s b ‚Üî ContinuousWithinAt f s b :=
  tendsto_const_smul_iff (Units.mk0 c hc)

theorem continuous_on_const_smul_iff‚ÇÄ (hc : c ‚â† 0) : ContinuousOn (fun x => c ‚Ä¢ f x) s ‚Üî ContinuousOn f s :=
  continuous_on_const_smul_iff (Units.mk0 c hc)

theorem continuous_at_const_smul_iff‚ÇÄ (hc : c ‚â† 0) : ContinuousAt (fun x => c ‚Ä¢ f x) b ‚Üî ContinuousAt f b :=
  continuous_at_const_smul_iff (Units.mk0 c hc)

theorem continuous_const_smul_iff‚ÇÄ (hc : c ‚â† 0) : (Continuous fun x => c ‚Ä¢ f x) ‚Üî Continuous f :=
  continuous_const_smul_iff (Units.mk0 c hc)

/-- Scalar multiplication by a non-zero element of a group with zero acting on `Œ±` is a
homeomorphism from `Œ±` onto itself. -/
protected def Homeomorph.smulOfNeZero (c : G‚ÇÄ) (hc : c ‚â† 0) : Œ± ‚âÉ‚Çú Œ± :=
  Homeomorph.smul (Units.mk0 c hc)

theorem is_open_map_smul‚ÇÄ {c : G‚ÇÄ} (hc : c ‚â† 0) : IsOpenMap fun x : Œ± => c ‚Ä¢ x :=
  (Homeomorph.smulOfNeZero c hc).IsOpenMap

theorem IsOpen.smul‚ÇÄ {c : G‚ÇÄ} {s : Set Œ±} (hs : IsOpen s) (hc : c ‚â† 0) : IsOpen (c ‚Ä¢ s) :=
  is_open_map_smul‚ÇÄ hc s hs

theorem interior_smul‚ÇÄ {c : G‚ÇÄ} (hc : c ‚â† 0) (s : Set Œ±) : Interior (c ‚Ä¢ s) = c ‚Ä¢ Interior s :=
  ((Homeomorph.smulOfNeZero c hc).image_interior s).symm

theorem closure_smul‚ÇÄ {E} [Zero E] [MulActionWithZero G‚ÇÄ E] [TopologicalSpace E] [T1Space E]
    [HasContinuousConstSmul G‚ÇÄ E] (c : G‚ÇÄ) (s : Set E) : Closure (c ‚Ä¢ s) = c ‚Ä¢ Closure s := by
  rcases eq_or_ne c 0 with (rfl | hc)
  ¬∑ rcases eq_empty_or_nonempty s with (rfl | hs)
    ¬∑ simp
      
    ¬∑ rw [zero_smul_set hs, zero_smul_set hs.closure]
      exact closure_singleton
      
    
  ¬∑ exact ((Homeomorph.smulOfNeZero c hc).image_closure s).symm
    

/-- `smul` is a closed map in the second argument.

The lemma that `smul` is a closed map in the first argument (for a normed space over a complete
normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`. -/
theorem is_closed_map_smul_of_ne_zero {c : G‚ÇÄ} (hc : c ‚â† 0) : IsClosedMap fun x : Œ± => c ‚Ä¢ x :=
  (Homeomorph.smulOfNeZero c hc).IsClosedMap

theorem IsClosed.smul_of_ne_zero {c : G‚ÇÄ} {s : Set Œ±} (hs : IsClosed s) (hc : c ‚â† 0) : IsClosed (c ‚Ä¢ s) :=
  is_closed_map_smul_of_ne_zero hc s hs

/-- `smul` is a closed map in the second argument.

The lemma that `smul` is a closed map in the first argument (for a normed space over a complete
normed field) is `is_closed_map_smul_left` in `analysis.normed_space.finite_dimension`. -/
theorem is_closed_map_smul‚ÇÄ {ùïú M : Type _} [DivisionRing ùïú] [AddCommMonoid‚Çì M] [TopologicalSpace M] [T1Space M]
    [Module ùïú M] [HasContinuousConstSmul ùïú M] (c : ùïú) : IsClosedMap fun x : M => c ‚Ä¢ x := by
  rcases eq_or_ne c 0 with (rfl | hne)
  ¬∑ simp only [‚Üê zero_smul]
    exact is_closed_map_const
    
  ¬∑ exact (Homeomorph.smulOfNeZero c hne).IsClosedMap
    

theorem IsClosed.smul‚ÇÄ {ùïú M : Type _} [DivisionRing ùïú] [AddCommMonoid‚Çì M] [TopologicalSpace M] [T1Space M] [Module ùïú M]
    [HasContinuousConstSmul ùïú M] (c : ùïú) {s : Set M} (hs : IsClosed s) : IsClosed (c ‚Ä¢ s) :=
  is_closed_map_smul‚ÇÄ c s hs

end GroupWithZero‚Çì

namespace IsUnit

variable [Monoid‚Çì M] [TopologicalSpace Œ±] [MulAction M Œ±] [HasContinuousConstSmul M Œ±]

theorem tendsto_const_smul_iff {f : Œ≤ ‚Üí Œ±} {l : Filter Œ≤} {a : Œ±} {c : M} (hc : IsUnit c) :
    Tendsto (fun x => c ‚Ä¢ f x) l (ùìù <| c ‚Ä¢ a) ‚Üî Tendsto f l (ùìù a) :=
  let ‚ü®u, hu‚ü© := hc
  hu ‚ñ∏ tendsto_const_smul_iff u

variable [TopologicalSpace Œ≤] {f : Œ≤ ‚Üí Œ±} {b : Œ≤} {c : M} {s : Set Œ≤}

theorem continuous_within_at_const_smul_iff (hc : IsUnit c) :
    ContinuousWithinAt (fun x => c ‚Ä¢ f x) s b ‚Üî ContinuousWithinAt f s b :=
  let ‚ü®u, hu‚ü© := hc
  hu ‚ñ∏ continuous_within_at_const_smul_iff u

theorem continuous_on_const_smul_iff (hc : IsUnit c) : ContinuousOn (fun x => c ‚Ä¢ f x) s ‚Üî ContinuousOn f s :=
  let ‚ü®u, hu‚ü© := hc
  hu ‚ñ∏ continuous_on_const_smul_iff u

theorem continuous_at_const_smul_iff (hc : IsUnit c) : ContinuousAt (fun x => c ‚Ä¢ f x) b ‚Üî ContinuousAt f b :=
  let ‚ü®u, hu‚ü© := hc
  hu ‚ñ∏ continuous_at_const_smul_iff u

theorem continuous_const_smul_iff (hc : IsUnit c) : (Continuous fun x => c ‚Ä¢ f x) ‚Üî Continuous f :=
  let ‚ü®u, hu‚ü© := hc
  hu ‚ñ∏ continuous_const_smul_iff u

theorem is_open_map_smul (hc : IsUnit c) : IsOpenMap fun x : Œ± => c ‚Ä¢ x :=
  let ‚ü®u, hu‚ü© := hc
  hu ‚ñ∏ is_open_map_smul u

theorem is_closed_map_smul (hc : IsUnit c) : IsClosedMap fun x : Œ± => c ‚Ä¢ x :=
  let ‚ü®u, hu‚ü© := hc
  hu ‚ñ∏ is_closed_map_smul u

end IsUnit

/-- Class `properly_discontinuous_smul Œì T` says that the scalar multiplication `(‚Ä¢) : Œì ‚Üí T ‚Üí T`
is properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely many
`Œ≥:Œì` move `K` to have nontrivial intersection with `L`.
-/
class ProperlyDiscontinuousSmul (Œì : Type _) (T : Type _) [TopologicalSpace T] [HasSmul Œì T] : Prop where
  finite_disjoint_inter_image :
    ‚àÄ {K L : Set T}, IsCompact K ‚Üí IsCompact L ‚Üí Set.Finite { Œ≥ : Œì | (¬∑ ‚Ä¢ ¬∑) Œ≥ '' K ‚à© L ‚â† ‚àÖ }

/-- Class `properly_discontinuous_vadd Œì T` says that the additive action `(+·µ•) : Œì ‚Üí T ‚Üí T`
is properly discontinuous, that is, for any pair of compact sets `K, L` in `T`, only finitely many
`Œ≥:Œì` move `K` to have nontrivial intersection with `L`.
-/
class ProperlyDiscontinuousVadd (Œì : Type _) (T : Type _) [TopologicalSpace T] [HasVadd Œì T] : Prop where
  finite_disjoint_inter_image :
    ‚àÄ {K L : Set T}, IsCompact K ‚Üí IsCompact L ‚Üí Set.Finite { Œ≥ : Œì | (¬∑ +·µ• ¬∑) Œ≥ '' K ‚à© L ‚â† ‚àÖ }

attribute [to_additive] ProperlyDiscontinuousSmul

variable {Œì : Type _} [Group‚Çì Œì] {T : Type _} [TopologicalSpace T] [MulAction Œì T]

/-- A finite group action is always properly discontinuous
-/
@[to_additive]
instance (priority := 100) Fintype.properly_discontinuous_smul [Fintype Œì] :
    ProperlyDiscontinuousSmul Œì T where finite_disjoint_inter_image := fun _ _ _ _ => Set.to_finite _

export ProperlyDiscontinuousSmul (finite_disjoint_inter_image)

export ProperlyDiscontinuousVadd (finite_disjoint_inter_image)

/-- The quotient map by a group action is open. -/
@[to_additive]
theorem is_open_map_quotient_mk_mul [HasContinuousConstSmul Œì T] :
    IsOpenMap (Quotient‚Çì.mk : T ‚Üí Quotient‚Çì (MulAction.orbitRel Œì T)) := by
  intro U hU
  rw [is_open_coinduced, MulAction.quotient_preimage_image_eq_union_mul U]
  exact is_open_Union fun Œ≥ => (Homeomorph.smul Œ≥).IsOpenMap U hU

/-- The quotient by a discontinuous group action of a locally compact t2 space is t2. -/
@[to_additive]
instance (priority := 100) t2_space_of_properly_discontinuous_smul_of_t2_space [T2Space T] [LocallyCompactSpace T]
    [HasContinuousConstSmul Œì T] [ProperlyDiscontinuousSmul Œì T] : T2Space (Quotient‚Çì (MulAction.orbitRel Œì T)) := by
  set Q := Quotient‚Çì (MulAction.orbitRel Œì T)
  rw [t2_space_iff_nhds]
  let f : T ‚Üí Q := Quotient‚Çì.mk
  have f_op : IsOpenMap f := is_open_map_quotient_mk_mul
  rintro ‚ü®x‚ÇÄ‚ü© ‚ü®y‚ÇÄ‚ü© (hxy : f x‚ÇÄ ‚â† f y‚ÇÄ)
  show ‚àÉ U ‚àà ùìù (f x‚ÇÄ), ‚àÉ V ‚àà ùìù (f y‚ÇÄ), _
  have hx‚ÇÄy‚ÇÄ : x‚ÇÄ ‚â† y‚ÇÄ := ne_of_apply_ne _ hxy
  have hŒ≥x‚ÇÄy‚ÇÄ : ‚àÄ Œ≥ : Œì, Œ≥ ‚Ä¢ x‚ÇÄ ‚â† y‚ÇÄ := not_exists.mp (mt Quotient‚Çì.sound hxy.symm : _)
  obtain ‚ü®K‚ÇÄ, L‚ÇÄ, K‚ÇÄ_in, L‚ÇÄ_in, hK‚ÇÄ, hL‚ÇÄ, hK‚ÇÄL‚ÇÄ‚ü© := t2_separation_compact_nhds hx‚ÇÄy‚ÇÄ
  let bad_Œì_set := { Œ≥ : Œì | (¬∑ ‚Ä¢ ¬∑) Œ≥ '' K‚ÇÄ ‚à© L‚ÇÄ ‚â† ‚àÖ }
  have bad_Œì_finite : bad_Œì_set.finite := finite_disjoint_inter_image hK‚ÇÄ hL‚ÇÄ
  choose u v hu hv u_v_disjoint using fun Œ≥ => t2_separation_nhds (hŒ≥x‚ÇÄy‚ÇÄ Œ≥)
  let U‚ÇÄ‚ÇÄ := ‚ãÇ Œ≥ ‚àà bad_Œì_set, (¬∑ ‚Ä¢ ¬∑) Œ≥ ‚Åª¬π' u Œ≥
  let U‚ÇÄ := U‚ÇÄ‚ÇÄ ‚à© K‚ÇÄ
  let V‚ÇÄ‚ÇÄ := ‚ãÇ Œ≥ ‚àà bad_Œì_set, v Œ≥
  let V‚ÇÄ := V‚ÇÄ‚ÇÄ ‚à© L‚ÇÄ
  have U_nhds : f '' U‚ÇÄ ‚àà ùìù (f x‚ÇÄ) := by
    apply f_op.image_mem_nhds (inter_mem ((bInter_mem bad_Œì_finite).mpr fun Œ≥ hŒ≥ => _) K‚ÇÄ_in)
    exact (continuous_const_smul _).ContinuousAt (hu Œ≥)
  have V_nhds : f '' V‚ÇÄ ‚àà ùìù (f y‚ÇÄ) :=
    f_op.image_mem_nhds (inter_mem ((bInter_mem bad_Œì_finite).mpr fun Œ≥ hŒ≥ => hv Œ≥) L‚ÇÄ_in)
  refine' ‚ü®f '' U‚ÇÄ, U_nhds, f '' V‚ÇÄ, V_nhds, MulAction.disjoint_image_image_iff.2 _‚ü©
  rintro x ‚ü®x_in_U‚ÇÄ‚ÇÄ, x_in_K‚ÇÄ‚ü© Œ≥
  by_cases' H : Œ≥ ‚àà bad_Œì_set
  ¬∑ exact fun h => u_v_disjoint Œ≥ ‚ü®mem_Inter‚ÇÇ.mp x_in_U‚ÇÄ‚ÇÄ Œ≥ H, mem_Inter‚ÇÇ.mp h.1 Œ≥ H‚ü©
    
  ¬∑ rintro ‚ü®-, h'‚ü©
    simp only [‚Üê image_smul, ‚Üê not_not, ‚Üê mem_set_of_eq, ‚Üê Ne.def] at H
    exact eq_empty_iff_forall_not_mem.mp H (Œ≥ ‚Ä¢ x) ‚ü®mem_image_of_mem _ x_in_K‚ÇÄ, h'‚ü©
    

section nhds

section MulAction

variable {G‚ÇÄ : Type _} [GroupWithZero‚Çì G‚ÇÄ] [MulAction G‚ÇÄ Œ±] [TopologicalSpace Œ±] [HasContinuousConstSmul G‚ÇÄ Œ±]

/-- Scalar multiplication preserves neighborhoods. -/
theorem set_smul_mem_nhds_smul {c : G‚ÇÄ} {s : Set Œ±} {x : Œ±} (hs : s ‚àà ùìù x) (hc : c ‚â† 0) : c ‚Ä¢ s ‚àà ùìù (c ‚Ä¢ x : Œ±) := by
  rw [mem_nhds_iff] at hs‚ä¢
  obtain ‚ü®U, hs', hU, hU'‚ü© := hs
  exact ‚ü®c ‚Ä¢ U, Set.smul_set_mono hs', hU.smul‚ÇÄ hc, Set.smul_mem_smul_set hU'‚ü©

theorem set_smul_mem_nhds_smul_iff {c : G‚ÇÄ} {s : Set Œ±} {x : Œ±} (hc : c ‚â† 0) : c ‚Ä¢ s ‚àà ùìù (c ‚Ä¢ x : Œ±) ‚Üî s ‚àà ùìù x := by
  refine' ‚ü®fun h => _, fun h => set_smul_mem_nhds_smul h hc‚ü©
  rw [‚Üê inv_smul_smul‚ÇÄ hc x, ‚Üê inv_smul_smul‚ÇÄ hc s]
  exact set_smul_mem_nhds_smul h (inv_ne_zero hc)

end MulAction

section DistribMulAction

variable {G‚ÇÄ : Type _} [GroupWithZero‚Çì G‚ÇÄ] [AddMonoid‚Çì Œ±] [DistribMulAction G‚ÇÄ Œ±] [TopologicalSpace Œ±]
  [HasContinuousConstSmul G‚ÇÄ Œ±]

theorem set_smul_mem_nhds_zero_iff {s : Set Œ±} {c : G‚ÇÄ} (hc : c ‚â† 0) : c ‚Ä¢ s ‚àà ùìù (0 : Œ±) ‚Üî s ‚àà ùìù (0 : Œ±) := by
  refine' Iff.trans _ (set_smul_mem_nhds_smul_iff hc)
  rw [smul_zero]

end DistribMulAction

end nhds

