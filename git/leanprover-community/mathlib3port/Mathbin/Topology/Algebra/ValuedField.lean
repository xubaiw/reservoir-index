/-
Copyright (c) 2021 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot
-/
import Mathbin.Topology.Algebra.Valuation
import Mathbin.Topology.Algebra.WithZeroTopology
import Mathbin.Topology.Algebra.UniformField

/-!
# Valued fields and their completions

In this file we study the topology of a field `K` endowed with a valuation (in our application
to adic spaces, `K` will be the valuation field associated to some valuation on a ring, defined in
valuation.basic).

We already know from valuation.topology that one can build a topology on `K` which
makes it a topological ring.

The first goal is to show `K` is a topological *field*, ie inversion is continuous
at every non-zero element.

The next goal is to prove `K` is a *completable* topological field. This gives us
a completion `hat K` which is a topological field. We also prove that `K` is automatically
separated, so the map from `K` to `hat K` is injective.

Then we extend the valuation given on `K` to a valuation on `hat K`.
-/


open Filter Set

open TopologicalSpace

section DivisionRing

variable {K : Type _} [DivisionRing K] {Œì‚ÇÄ : Type _} [LinearOrderedCommGroupWithZero Œì‚ÇÄ]

section ValuationTopologicalDivisionRing

section InversionEstimate

variable (v : Valuation K Œì‚ÇÄ)

-- The following is the main technical lemma ensuring that inversion is continuous
-- in the topology induced by a valuation on a division ring (ie the next instance)
-- and the fact that a valued field is completable
-- [BouAC, VI.5.1 Lemme 1]
theorem Valuation.inversion_estimate {x y : K} {Œ≥ : Œì‚ÇÄÀ£} (y_ne : y ‚â† 0) (h : v (x - y) < min (Œ≥ * (v y * v y)) (v y)) :
    v (x‚Åª¬π - y‚Åª¬π) < Œ≥ := by
  have hyp1 : v (x - y) < Œ≥ * (v y * v y) := lt_of_lt_of_le‚Çì h (min_le_left‚Çì _ _)
  have hyp1' : v (x - y) * (v y * v y)‚Åª¬π < Œ≥ := mul_inv_lt_of_lt_mul‚ÇÄ hyp1
  have hyp2 : v (x - y) < v y := lt_of_lt_of_le‚Çì h (min_le_right‚Çì _ _)
  have key : v x = v y := Valuation.map_eq_of_sub_lt v hyp2
  have x_ne : x ‚â† 0 := by
    intro h
    apply y_ne
    rw [h, v.map_zero] at key
    exact v.zero_iff.1 key.symm
  have decomp : x‚Åª¬π - y‚Åª¬π = x‚Åª¬π * (y - x) * y‚Åª¬π := by
    rw [mul_sub_left_distrib, sub_mul, mul_assoc, show y * y‚Åª¬π = 1 from mul_inv_cancel y_ne,
      show x‚Åª¬π * x = 1 from inv_mul_cancel x_ne, mul_one‚Çì, one_mul‚Çì]
  calc v (x‚Åª¬π - y‚Åª¬π) = v (x‚Åª¬π * (y - x) * y‚Åª¬π) := by
      rw [decomp]_ = v x‚Åª¬π * (v <| y - x) * v y‚Åª¬π := by
      repeat'
        rw [Valuation.map_mul]_ = (v x)‚Åª¬π * (v <| y - x) * (v y)‚Åª¬π :=
      by
      rw [v.map_inv, v.map_inv]_ = (v <| y - x) * (v y * v y)‚Åª¬π := by
      rw [mul_assoc, mul_comm, key, mul_assoc, mul_inv_rev]_ = (v <| y - x) * (v y * v y)‚Åª¬π :=
      rfl _ = (v <| x - y) * (v y * v y)‚Åª¬π := by
      rw [Valuation.map_sub_swap]_ < Œ≥ := hyp1'

end InversionEstimate

open Valued

/-- The topology coming from a valuation on a division ring makes it a topological division ring
    [BouAC, VI.5.1 middle of Proposition 1] -/
instance (priority := 100) Valued.topological_division_ring [Valued K Œì‚ÇÄ] : TopologicalDivisionRing K :=
  { (by
      infer_instance : TopologicalRing K) with
    continuous_at_inv‚ÇÄ := by
      intro x x_ne s s_in
      cases' valued.mem_nhds.mp s_in with Œ≥ hs
      clear s_in
      rw [mem_map, Valued.mem_nhds]
      change ‚àÉ Œ≥ : Œì‚ÇÄÀ£, { y : K | (v (y - x) : Œì‚ÇÄ) < Œ≥ } ‚äÜ { x : K | x‚Åª¬π ‚àà s }
      have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne
      let Œ≥' := Units.mk0 _ vx_ne
      use min (Œ≥ * (Œ≥' * Œ≥')) Œ≥'
      intro y y_in
      apply hs
      simp only [mem_set_of_eq] at y_in
      rw [Units.min_coe, Units.coe_mul, Units.coe_mul] at y_in
      exact Valuation.inversion_estimate _ x_ne y_in }

/-- A valued division ring is separated. -/
instance (priority := 100) ValuedRing.separated [Valued K Œì‚ÇÄ] : SeparatedSpace K := by
  rw [separated_iff_t2]
  apply TopologicalAddGroup.t2_space_of_zero_sep
  intro x x_ne
  refine' ‚ü®{ k | v k < v x }, _, fun h => lt_irrefl‚Çì _ h‚ü©
  rw [Valued.mem_nhds]
  have vx_ne := (Valuation.ne_zero_iff <| v).mpr x_ne
  let Œ≥' := Units.mk0 _ vx_ne
  exact
    ‚ü®Œ≥', fun y hy => by
      simpa using hy‚ü©

section

attribute [local instance] LinearOrderedCommGroupWithZero.topologicalSpace

open Valued

-- ././Mathport/Syntax/Translate/Tactic/Basic.lean:30:4: unsupported: too many args: classical ... #[[]]
theorem Valued.continuous_valuation [Valued K Œì‚ÇÄ] : Continuous (v : K ‚Üí Œì‚ÇÄ) := by
  rw [continuous_iff_continuous_at]
  intro x
  classical
  by_cases' h : x = 0
  ¬∑ rw [h]
    change tendsto _ _ (ùìù (v (0 : K)))
    erw [Valuation.map_zero]
    rw [LinearOrderedCommGroupWithZero.tendsto_zero]
    intro Œ≥
    rw [Valued.mem_nhds_zero]
    use Œ≥, Set.Subset.refl _
    
  ¬∑ change tendsto _ _ _
    have v_ne : (v x : Œì‚ÇÄ) ‚â† 0 := (Valuation.ne_zero_iff _).mpr h
    rw [LinearOrderedCommGroupWithZero.tendsto_of_ne_zero v_ne]
    apply Valued.loc_const v_ne
    

end

end ValuationTopologicalDivisionRing

end DivisionRing

namespace Valued

open UniformSpace

variable {K : Type _} [Field K] {Œì‚ÇÄ : Type _} [LinearOrderedCommGroupWithZero Œì‚ÇÄ] [hv : Valued K Œì‚ÇÄ]

include hv

-- mathport name: ¬´exprhat¬ª
local notation "hat " => Completion

/-- A valued field is completable. -/
instance (priority := 100) completable : CompletableTopField K :=
  { ValuedRing.separated with
    nice := by
      rintro F hF h0
      have : ‚àÉ Œ≥‚ÇÄ : Œì‚ÇÄÀ£, ‚àÉ M ‚àà F, ‚àÄ, ‚àÄ x ‚àà M, ‚àÄ, (Œ≥‚ÇÄ : Œì‚ÇÄ) ‚â§ v x := by
        rcases filter.inf_eq_bot_iff.mp h0 with ‚ü®U, U_in, M, M_in, H‚ü©
        rcases valued.mem_nhds_zero.mp U_in with ‚ü®Œ≥‚ÇÄ, hU‚ü©
        exists Œ≥‚ÇÄ, M, M_in
        intro x xM
        apply le_of_not_lt‚Çì _
        intro hyp
        have : x ‚àà U ‚à© M := ‚ü®hU hyp, xM‚ü©
        rwa [H] at this
      rcases this with ‚ü®Œ≥‚ÇÄ, M‚ÇÄ, M‚ÇÄ_in, H‚ÇÄ‚ü©
      rw [Valued.cauchy_iff] at hF‚ä¢
      refine' ‚ü®hF.1.map _, _‚ü©
      replace hF := hF.2
      intro Œ≥
      rcases hF (min (Œ≥ * Œ≥‚ÇÄ * Œ≥‚ÇÄ) Œ≥‚ÇÄ) with ‚ü®M‚ÇÅ, M‚ÇÅ_in, H‚ÇÅ‚ü©
      clear hF
      use (fun x : K => x‚Åª¬π) '' (M‚ÇÄ ‚à© M‚ÇÅ)
      constructor
      ¬∑ rw [mem_map]
        apply mem_of_superset (Filter.inter_mem M‚ÇÄ_in M‚ÇÅ_in)
        exact subset_preimage_image _ _
        
      ¬∑ rintro _ ‚ü®x, ‚ü®x_in‚ÇÄ, x_in‚ÇÅ‚ü©, rfl‚ü© _ ‚ü®y, ‚ü®y_in‚ÇÄ, y_in‚ÇÅ‚ü©, rfl‚ü©
        simp only [mem_set_of_eq]
        specialize H‚ÇÅ x x_in‚ÇÅ y y_in‚ÇÅ
        replace x_in‚ÇÄ := H‚ÇÄ x x_in‚ÇÄ
        replace y_in‚ÇÄ := H‚ÇÄ y y_in‚ÇÄ
        clear H‚ÇÄ
        apply Valuation.inversion_estimate
        ¬∑ have : (v x : Œì‚ÇÄ) ‚â† 0 := by
            intro h
            rw [h] at x_in‚ÇÄ
            simpa using x_in‚ÇÄ
          exact (Valuation.ne_zero_iff _).mp this
          
        ¬∑ refine' lt_of_lt_of_le‚Çì H‚ÇÅ _
          rw [Units.min_coe]
          apply min_le_min _ x_in‚ÇÄ
          rw [mul_assoc]
          have : ((Œ≥‚ÇÄ * Œ≥‚ÇÄ : Œì‚ÇÄÀ£) : Œì‚ÇÄ) ‚â§ v x * v x :=
            calc
              ‚ÜëŒ≥‚ÇÄ * ‚ÜëŒ≥‚ÇÄ ‚â§ ‚ÜëŒ≥‚ÇÄ * v x := mul_le_mul_left' x_in‚ÇÄ ‚ÜëŒ≥‚ÇÄ
              _ ‚â§ _ := mul_le_mul_right' x_in‚ÇÄ (v x)
              
          rw [Units.coe_mul]
          exact mul_le_mul_left' this Œ≥
          
         }

attribute [local instance] LinearOrderedCommGroupWithZero.topologicalSpace

/-- The extension of the valuation of a valued field to the completion of the field. -/
noncomputable def extension : hat K ‚Üí Œì‚ÇÄ :=
  Completion.dense_inducing_coe.extend (v : K ‚Üí Œì‚ÇÄ)

-- ././Mathport/Syntax/Translate/Basic.lean:597:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª V')
theorem continuous_extension : Continuous (Valued.extension : hat K ‚Üí Œì‚ÇÄ) := by
  refine' completion.dense_inducing_coe.continuous_extend _
  intro x‚ÇÄ
  by_cases' h : x‚ÇÄ = coe 0
  ¬∑ refine' ‚ü®0, _‚ü©
    erw [h, ‚Üê completion.dense_inducing_coe.to_inducing.nhds_eq_comap] <;>
      try
        infer_instance
    rw [LinearOrderedCommGroupWithZero.tendsto_zero]
    intro Œ≥‚ÇÄ
    rw [Valued.mem_nhds]
    exact
      ‚ü®Œ≥‚ÇÄ, by
        simp ‚ü©
    
  ¬∑ have preimage_one : v ‚Åª¬π' {(1 : Œì‚ÇÄ)} ‚àà ùìù (1 : K) := by
      have : (v (1 : K) : Œì‚ÇÄ) ‚â† 0 := by
        rw [Valuation.map_one]
        exact zero_ne_one.symm
      convert Valued.loc_const this
      ext x
      rw [Valuation.map_one, mem_preimage, mem_singleton_iff, mem_set_of_eq]
    obtain ‚ü®V, V_in, hV‚ü© : ‚àÉ V ‚àà ùìù (1 : hat K), ‚àÄ x : K, (x : hat K) ‚àà V ‚Üí (v x : Œì‚ÇÄ) = 1 := by
      rwa [completion.dense_inducing_coe.nhds_eq_comap, mem_comap] at preimage_one
    have : ‚àÉ V' ‚àà ùìù (1 : hat K), (0 : hat K) ‚àâ V' ‚àß ‚àÄ x y _ : x ‚àà V' _ : y ‚àà V', x * y‚Åª¬π ‚àà V := by
      have : tendsto (fun p : hat K √ó hat K => p.1 * p.2‚Åª¬π) ((ùìù 1).Prod (ùìù 1)) (ùìù 1) := by
        rw [‚Üê nhds_prod_eq]
        conv => congr skip skip rw [‚Üê one_mul‚Çì (1 : hat K)]
        refine' tendsto.mul continuous_fst.continuous_at (tendsto.comp _ continuous_snd.continuous_at)
        convert continuous_at_inv‚ÇÄ (zero_ne_one.symm : 1 ‚â† (0 : hat K))
        exact inv_one.symm
      rcases tendsto_prod_self_iff.mp this V V_in with ‚ü®U, U_in, hU‚ü©
      let hatKstar := ({0}·∂ú : Set <| hat K)
      have : hatKstar ‚àà ùìù (1 : hat K) := compl_singleton_mem_nhds zero_ne_one.symm
      use U ‚à© hatKstar, Filter.inter_mem U_in this
      constructor
      ¬∑ rintro ‚ü®h, h'‚ü©
        rw [mem_compl_singleton_iff] at h'
        exact h' rfl
        
      ¬∑ rintro x ‚ü®hx, _‚ü© y ‚ü®hy, _‚ü©
        apply hU <;> assumption
        
    rcases this with ‚ü®V', V'_in, zeroV', hV'‚ü©
    have nhds_right : (fun x => x * x‚ÇÄ) '' V' ‚àà ùìù x‚ÇÄ := by
      have l : Function.LeftInverse (fun x : hat K => x * x‚ÇÄ‚Åª¬π) fun x : hat K => x * x‚ÇÄ := by
        intro x
        simp only [mul_assoc, mul_inv_cancel h, mul_one‚Çì]
      have r : Function.RightInverse (fun x : hat K => x * x‚ÇÄ‚Åª¬π) fun x : hat K => x * x‚ÇÄ := by
        intro x
        simp only [mul_assoc, inv_mul_cancel h, mul_one‚Çì]
      have c : Continuous fun x : hat K => x * x‚ÇÄ‚Åª¬π := continuous_id.mul continuous_const
      rw [image_eq_preimage_of_inverse l r]
      rw [‚Üê mul_inv_cancel h] at V'_in
      exact c.continuous_at V'_in
    have : ‚àÉ z‚ÇÄ : K, ‚àÉ y‚ÇÄ ‚àà V', coe z‚ÇÄ = y‚ÇÄ * x‚ÇÄ ‚àß z‚ÇÄ ‚â† 0 := by
      rcases completion.dense_range_coe.mem_nhds nhds_right with ‚ü®z‚ÇÄ, y‚ÇÄ, y‚ÇÄ_in, H : y‚ÇÄ * x‚ÇÄ = z‚ÇÄ‚ü©
      refine' ‚ü®z‚ÇÄ, y‚ÇÄ, y‚ÇÄ_in, ‚ü®H.symm, _‚ü©‚ü©
      rintro rfl
      exact mul_ne_zero (ne_of_mem_of_not_mem y‚ÇÄ_in zeroV') h H
    rcases this with ‚ü®z‚ÇÄ, y‚ÇÄ, y‚ÇÄ_in, hz‚ÇÄ, z‚ÇÄ_ne‚ü©
    have vz‚ÇÄ_ne : (v z‚ÇÄ : Œì‚ÇÄ) ‚â† 0 := by
      rwa [Valuation.ne_zero_iff]
    refine' ‚ü®v z‚ÇÄ, _‚ü©
    rw [LinearOrderedCommGroupWithZero.tendsto_of_ne_zero vz‚ÇÄ_ne, mem_comap]
    use (fun x => x * x‚ÇÄ) '' V', nhds_right
    intro x x_in
    rcases mem_preimage.1 x_in with ‚ü®y, y_in, hy‚ü©
    clear x_in
    change y * x‚ÇÄ = coe x at hy
    have : (v (x * z‚ÇÄ‚Åª¬π) : Œì‚ÇÄ) = 1 := by
      apply hV
      have : ((z‚ÇÄ‚Åª¬π : K) : hat K) = z‚ÇÄ‚Åª¬π := RingHom.map_inv (completion.coe_ring_hom : K ‚Üí+* hat K) z‚ÇÄ
      rw [completion.coe_mul, this, ‚Üê hy, hz‚ÇÄ, mul_inv, mul_comm y‚ÇÄ‚Åª¬π, ‚Üê mul_assoc, mul_assoc y, mul_inv_cancel h,
        mul_one‚Çì]
      solve_by_elim
    calc v x = v (x * z‚ÇÄ‚Åª¬π * z‚ÇÄ) := by
        rw [mul_assoc, inv_mul_cancel z‚ÇÄ_ne, mul_one‚Çì]_ = v (x * z‚ÇÄ‚Åª¬π) * v z‚ÇÄ := Valuation.map_mul _ _ _ _ = v z‚ÇÄ := by
        rw [this, one_mul‚Çì]
    

@[simp, norm_cast]
theorem extension_extends (x : K) : extension (x : hat K) = v x := by
  have : T2Space Œì‚ÇÄ := RegularSpace.t2_space _
  refine' completion.dense_inducing_coe.extend_eq_of_tendsto _
  rw [‚Üê completion.dense_inducing_coe.nhds_eq_comap]
  exact valued.continuous_valuation.continuous_at

/-- the extension of a valuation on a division ring to its completion. -/
noncomputable def extensionValuation : Valuation (hat K) Œì‚ÇÄ where
  toFun := Valued.extension
  map_zero' := by
    rw [‚Üê v.map_zero, ‚Üê Valued.extension_extends (0 : K)]
    rfl
  map_one' := by
    rw [‚Üê completion.coe_one, Valued.extension_extends (1 : K)]
    exact Valuation.map_one _
  map_mul' := fun x y => by
    apply completion.induction_on‚ÇÇ x y
    ¬∑ have c1 : Continuous fun x : hat K √ó hat K => Valued.extension (x.1 * x.2) :=
        valued.continuous_extension.comp (continuous_fst.mul continuous_snd)
      have c2 : Continuous fun x : hat K √ó hat K => Valued.extension x.1 * Valued.extension x.2 :=
        (valued.continuous_extension.comp continuous_fst).mul (valued.continuous_extension.comp continuous_snd)
      exact is_closed_eq c1 c2
      
    ¬∑ intro x y
      norm_cast
      exact Valuation.map_mul _ _ _
      
  map_add_le_max' := fun x y => by
    rw [le_max_iff]
    apply completion.induction_on‚ÇÇ x y
    ¬∑ have cont : Continuous (Valued.extension : hat K ‚Üí Œì‚ÇÄ) := Valued.continuous_extension
      exact
        (is_closed_le (cont.comp continuous_add) <| cont.comp continuous_fst).union
          (is_closed_le (cont.comp continuous_add) <| cont.comp continuous_snd)
      
    ¬∑ intro x y
      dsimp'
      norm_cast
      rw [‚Üê le_max_iff]
      exact v.map_add x y
      

-- Bourbaki CA VI ¬ß5 no.3 Proposition 5 (d)
theorem closure_coe_completion_v_lt {Œ≥ : Œì‚ÇÄÀ£} :
    Closure (coe '' { x : K | v x < (Œ≥ : Œì‚ÇÄ) }) = { x : hat K | extensionValuation x < (Œ≥ : Œì‚ÇÄ) } := by
  ext x
  let Œ≥‚ÇÄ := extension_valuation x
  suffices Œ≥‚ÇÄ ‚â† 0 ‚Üí (x ‚àà Closure (coe '' { x : K | v x < (Œ≥ : Œì‚ÇÄ) }) ‚Üî Œ≥‚ÇÄ < (Œ≥ : Œì‚ÇÄ)) by
    cases eq_or_ne Œ≥‚ÇÄ 0
    ¬∑ simp only [h, (Valuation.zero_iff _).mp h, mem_set_of_eq, Valuation.map_zero, Units.zero_lt, iff_true‚Çì]
      apply subset_closure
      exact
        ‚ü®0, by
          simpa only [mem_set_of_eq, Valuation.map_zero, Units.zero_lt, true_and‚Çì] ‚ü©
      
    ¬∑ exact this h
      
  intro h
  have hŒ≥‚ÇÄ : extension ‚Åª¬π' {Œ≥‚ÇÄ} ‚àà ùìù x :=
    continuous_extension.continuous_at.preimage_mem_nhds
      (LinearOrderedCommGroupWithZero.singleton_mem_nhds_of_ne_zero h)
  rw [mem_closure_iff_nhds']
  refine' ‚ü®fun hx => _, fun hx s hs => _‚ü©
  ¬∑ obtain ‚ü®‚ü®-, y, hy‚ÇÅ : v y < (Œ≥ : Œì‚ÇÄ), rfl‚ü©, hy‚ÇÇ‚ü© := hx _ hŒ≥‚ÇÄ
    replace hy‚ÇÇ : v y = Œ≥‚ÇÄ
    ¬∑ simpa using hy‚ÇÇ
      
    rwa [‚Üê hy‚ÇÇ]
    
  ¬∑ obtain ‚ü®y, hy‚ÇÅ, hy‚ÇÇ : ‚Üëy ‚àà s‚ü© := completion.dense_range_coe.mem_nhds (inter_mem hŒ≥‚ÇÄ hs)
    replace hy‚ÇÅ : v y = Œ≥‚ÇÄ
    ¬∑ simpa using hy‚ÇÅ
      
    rw [‚Üê hy‚ÇÅ] at hx
    exact ‚ü®‚ü®y, ‚ü®y, hx, rfl‚ü©‚ü©, hy‚ÇÇ‚ü©
    

noncomputable instance valuedCompletion : Valued (hat K) Œì‚ÇÄ where
  V := extensionValuation
  is_topological_valuation := fun s => by
    suffices has_basis (ùìù (0 : hat K)) (fun _ => True) fun Œ≥ : Œì‚ÇÄÀ£ => { x | extension_valuation x < Œ≥ } by
      rw [this.mem_iff]
      exact
        exists_congr fun Œ≥ => by
          simp
    simp_rw [‚Üê closure_coe_completion_v_lt]
    exact (has_basis_nhds_zero K Œì‚ÇÄ).has_basis_of_dense_inducing completion.dense_inducing_coe

end Valued

