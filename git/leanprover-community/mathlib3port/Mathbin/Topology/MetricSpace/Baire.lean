/-
Copyright (c) 2019 Sébastien Gouëzel. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Sébastien Gouëzel
-/
import Mathbin.Analysis.SpecificLimits.Basic
import Mathbin.Order.Filter.CountableInter
import Mathbin.Topology.GDelta

/-!
# Baire theorem

In a complete metric space, a countable intersection of dense open subsets is dense.

The good concept underlying the theorem is that of a Gδ set, i.e., a countable intersection
of open sets. Then Baire theorem can also be formulated as the fact that a countable
intersection of dense Gδ sets is a dense Gδ set. We prove Baire theorem, giving several different
formulations that can be handy. We also prove the important consequence that, if the space is
covered by a countable union of closed sets, then the union of their interiors is dense.

We also define the filter `residual α` generated by dense `Gδ` sets and prove that this filter
has the countable intersection property.
-/


noncomputable section

open Classical TopologicalSpace Filter Ennreal

open Filter Encodable Set TopologicalSpace

variable {α : Type _} {β : Type _} {γ : Type _} {ι : Type _}

section BaireTheorem

open Emetric Ennreal

/-- The property `baire_space α` means that the topological space `α` has the Baire property:
any countable intersection of open dense subsets is dense.
Formulated here when the source space is ℕ (and subsumed below by `dense_Inter_of_open` working
with any encodable source space).-/
class BaireSpace (α : Type _) [TopologicalSpace α] : Prop where
  baire_property : ∀ f : ℕ → Set α, (∀ n, IsOpen (f n)) → (∀ n, Dense (f n)) → Dense (⋂ n, f n)

/-- Baire theorems asserts that various topological spaces have the Baire property.
Two versions of these theorems are given.
The first states that complete pseudo_emetric spaces are Baire. -/
instance (priority := 100) baire_category_theorem_emetric_complete [PseudoEmetricSpace α] [CompleteSpace α] :
    BaireSpace α := by
  refine' ⟨fun f ho hd => _⟩
  let B : ℕ → ℝ≥0∞ := fun n => 1 / 2 ^ n
  have Bpos : ∀ n, 0 < B n := by
    intro n
    simp only [B, one_div, one_mulₓ, Ennreal.inv_pos]
    exact pow_ne_top two_ne_top
  /- Translate the density assumption into two functions `center` and `radius` associating
    to any n, x, δ, δpos a center and a positive radius such that
    `closed_ball center radius` is included both in `f n` and in `closed_ball x δ`.
    We can also require `radius ≤ (1/2)^(n+1)`, to ensure we get a Cauchy sequence later. -/
  have : ∀ n x δ, δ ≠ 0 → ∃ y r, 0 < r ∧ r ≤ B (n + 1) ∧ closed_ball y r ⊆ closed_ball x δ ∩ f n := by
    intro n x δ δpos
    have : x ∈ Closure (f n) := hd n x
    rcases Emetric.mem_closure_iff.1 this (δ / 2) (Ennreal.half_pos δpos) with ⟨y, ys, xy⟩
    rw [edist_comm] at xy
    obtain ⟨r, rpos, hr⟩ : ∃ r > 0, closed_ball y r ⊆ f n :=
      nhds_basis_closed_eball.mem_iff.1 (is_open_iff_mem_nhds.1 (ho n) y ys)
    refine' ⟨y, min (min (δ / 2) r) (B (n + 1)), _, _, fun z hz => ⟨_, _⟩⟩
    show 0 < min (min (δ / 2) r) (B (n + 1))
    exact lt_minₓ (lt_minₓ (Ennreal.half_pos δpos) rpos) (Bpos (n + 1))
    show min (min (δ / 2) r) (B (n + 1)) ≤ B (n + 1)
    exact min_le_rightₓ _ _
    show z ∈ closed_ball x δ
    exact
      calc
        edist z x ≤ edist z y + edist y x := edist_triangle _ _ _
        _ ≤ min (min (δ / 2) r) (B (n + 1)) + δ / 2 := add_le_add hz (le_of_ltₓ xy)
        _ ≤ δ / 2 + δ / 2 := add_le_add (le_transₓ (min_le_leftₓ _ _) (min_le_leftₓ _ _)) le_rfl
        _ = δ := Ennreal.add_halves δ
        
    show z ∈ f n
    exact
      hr
        (calc
          edist z y ≤ min (min (δ / 2) r) (B (n + 1)) := hz
          _ ≤ r := le_transₓ (min_le_leftₓ _ _) (min_le_rightₓ _ _)
          )
  choose! center radius Hpos HB Hball using this
  refine' fun x => (mem_closure_iff_nhds_basis nhds_basis_closed_eball).2 fun ε εpos => _
  /- `ε` is positive. We have to find a point in the ball of radius `ε` around `x` belonging to all
    `f n`. For this, we construct inductively a sequence `F n = (c n, r n)` such that the closed ball
    `closed_ball (c n) (r n)` is included in the previous ball and in `f n`, and such that
    `r n` is small enough to ensure that `c n` is a Cauchy sequence. Then `c n` converges to a
    limit which belongs to all the `f n`. -/
  let F : ℕ → α × ℝ≥0∞ := fun n =>
    Nat.recOn n (Prod.mk x (min ε (B 0))) fun n p => Prod.mk (center n p.1 p.2) (radius n p.1 p.2)
  let c : ℕ → α := fun n => (F n).1
  let r : ℕ → ℝ≥0∞ := fun n => (F n).2
  have rpos : ∀ n, 0 < r n := by
    intro n
    induction' n with n hn
    exact lt_minₓ εpos (Bpos 0)
    exact Hpos n (c n) (r n) hn.ne'
  have r0 : ∀ n, r n ≠ 0 := fun n => (rpos n).ne'
  have rB : ∀ n, r n ≤ B n := by
    intro n
    induction' n with n hn
    exact min_le_rightₓ _ _
    exact HB n (c n) (r n) (r0 n)
  have incl : ∀ n, closed_ball (c (n + 1)) (r (n + 1)) ⊆ closed_ball (c n) (r n) ∩ f n := fun n =>
    Hball n (c n) (r n) (r0 n)
  have cdist : ∀ n, edist (c n) (c (n + 1)) ≤ B n := by
    intro n
    rw [edist_comm]
    have A : c (n + 1) ∈ closed_ball (c (n + 1)) (r (n + 1)) := mem_closed_ball_self
    have I :=
      calc
        closed_ball (c (n + 1)) (r (n + 1)) ⊆ closed_ball (c n) (r n) := subset.trans (incl n) (inter_subset_left _ _)
        _ ⊆ closed_ball (c n) (B n) := closed_ball_subset_closed_ball (rB n)
        
    exact I A
  have : CauchySeq c := cauchy_seq_of_edist_le_geometric_two _ one_ne_top cdist
  -- as the sequence `c n` is Cauchy in a complete space, it converges to a limit `y`.
  rcases cauchy_seq_tendsto_of_complete this with ⟨y, ylim⟩
  -- this point `y` will be the desired point. We will check that it belongs to all
  -- `f n` and to `ball x ε`.
  use y
  simp only [exists_prop, Set.mem_Inter]
  have I : ∀ n, ∀, ∀ m ≥ n, ∀, closed_ball (c m) (r m) ⊆ closed_ball (c n) (r n) := by
    intro n
    refine' Nat.le_induction _ fun m hnm h => _
    · exact subset.refl _
      
    · exact subset.trans (incl m) (subset.trans (inter_subset_left _ _) h)
      
  have yball : ∀ n, y ∈ closed_ball (c n) (r n) := by
    intro n
    refine' is_closed_ball.mem_of_tendsto ylim _
    refine' (Filter.eventually_ge_at_top n).mono fun m hm => _
    exact I n m hm mem_closed_ball_self
  constructor
  show ∀ n, y ∈ f n
  · intro n
    have : closed_ball (c (n + 1)) (r (n + 1)) ⊆ f n := subset.trans (incl n) (inter_subset_right _ _)
    exact this (yball (n + 1))
    
  show edist y x ≤ ε
  exact le_transₓ (yball 0) (min_le_leftₓ _ _)

/-- The second theorem states that locally compact spaces are Baire. -/
instance (priority := 100) baire_category_theorem_locally_compact [TopologicalSpace α] [T2Space α]
    [LocallyCompactSpace α] : BaireSpace α := by
  constructor
  intro f ho hd
  /- To prove that an intersection of open dense subsets is dense, prove that its intersection
    with any open neighbourhood `U` is dense. Define recursively a decreasing sequence `K` of
    compact neighbourhoods: start with some compact neighbourhood inside `U`, then at each step,
    take its interior, intersect with `f n`, then choose a compact neighbourhood inside the
    intersection.-/
  apply dense_iff_inter_open.2
  intro U U_open U_nonempty
  rcases exists_positive_compacts_subset U_open U_nonempty with ⟨K₀, hK₀⟩
  have : ∀ n K : positive_compacts α, ∃ K' : positive_compacts α, ↑K' ⊆ f n ∩ Interior K := by
    refine' fun n K => exists_positive_compacts_subset ((ho n).inter is_open_interior) _
    rw [inter_comm]
    exact (hd n).inter_open_nonempty _ is_open_interior K.interior_nonempty
  choose K_next hK_next
  let K : ℕ → positive_compacts α := fun n => Nat.recOn n K₀ K_next
  -- This is a decreasing sequence of positive compacts contained in suitable open sets `f n`.
  have hK_decreasing : ∀ n : ℕ, ↑(K (n + 1)) ⊆ f n ∩ K n := fun n =>
    (hK_next n (K n)).trans <| inter_subset_inter_right _ interior_subset
  -- Prove that ̀`⋂ n : ℕ, K n` is inside `U ∩ ⋂ n : ℕ, (f n)`.
  have hK_subset : (⋂ n, K n : Set α) ⊆ U ∩ ⋂ n, f n := by
    intro x hx
    simp only [mem_inter_eq, mem_Inter] at hx⊢
    exact ⟨hK₀ <| hx 0, fun n => (hK_decreasing n (hx (n + 1))).1⟩
  /- Prove that `⋂ n : ℕ, K n` is not empty, as an intersection of a decreasing sequence
    of nonempty compact subsets.-/
  have hK_nonempty : (⋂ n, K n : Set α).Nonempty :=
    IsCompact.nonempty_Inter_of_sequence_nonempty_compact_closed _
      (fun n => (hK_decreasing n).trans (inter_subset_right _ _)) (fun n => (K n).Nonempty) (K 0).compact fun n =>
      (K n).compact.IsClosed
  exact hK_nonempty.mono hK_subset

variable [TopologicalSpace α] [BaireSpace α]

/-- Definition of a Baire space. -/
theorem dense_Inter_of_open_nat {f : ℕ → Set α} (ho : ∀ n, IsOpen (f n)) (hd : ∀ n, Dense (f n)) : Dense (⋂ n, f n) :=
  BaireSpace.baire_property f ho hd

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with ⋂₀. -/
theorem dense_sInter_of_open {S : Set (Set α)} (ho : ∀, ∀ s ∈ S, ∀, IsOpen s) (hS : Countable S)
    (hd : ∀, ∀ s ∈ S, ∀, Dense s) : Dense (⋂₀ S) := by
  cases' S.eq_empty_or_nonempty with h h
  · simp [h]
    
  · rcases hS.exists_surjective h with ⟨f, hf⟩
    have F : ∀ n, f n ∈ S := fun n => by
      rw [hf] <;> exact mem_range_self _
    rw [hf, sInter_range]
    exact dense_Inter_of_open_nat (fun n => ho _ (F n)) fun n => hd _ (F n)
    

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_open {S : Set β} {f : β → Set α} (ho : ∀, ∀ s ∈ S, ∀, IsOpen (f s)) (hS : Countable S)
    (hd : ∀, ∀ s ∈ S, ∀, Dense (f s)) : Dense (⋂ s ∈ S, f s) := by
  rw [← sInter_image]
  apply dense_sInter_of_open
  · rwa [ball_image_iff]
    
  · exact hS.image _
    
  · rwa [ball_image_iff]
    

/-- Baire theorem: a countable intersection of dense open sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_open [Encodable β] {f : β → Set α} (ho : ∀ s, IsOpen (f s)) (hd : ∀ s, Dense (f s)) :
    Dense (⋂ s, f s) := by
  rw [← sInter_range]
  apply dense_sInter_of_open
  · rwa [forall_range_iff]
    
  · exact countable_range _
    
  · rwa [forall_range_iff]
    

/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with ⋂₀. -/
theorem dense_sInter_of_Gδ {S : Set (Set α)} (ho : ∀, ∀ s ∈ S, ∀, IsGδ s) (hS : Countable S)
    (hd : ∀, ∀ s ∈ S, ∀, Dense s) : Dense (⋂₀ S) := by
  -- the result follows from the result for a countable intersection of dense open sets,
  -- by rewriting each set as a countable intersection of open sets, which are of course dense.
  choose T hTo hTc hsT using ho
  have : ⋂₀ S = ⋂₀ ⋃ s ∈ S, T s ‹_› := by
    -- := (sInter_bUnion (λs hs, (hT s hs).2.2)).symm,
    simp only [sInter_Union, (hsT _ _).symm, ← sInter_eq_bInter]
  rw [this]
  refine' dense_sInter_of_open _ (hS.bUnion hTc) _ <;> simp only [mem_Union] <;> rintro t ⟨s, hs, tTs⟩
  show IsOpen t
  exact hTo s hs t tTs
  show Dense t
  · intro x
    have := hd s hs x
    rw [hsT s hs] at this
    exact closure_mono (sInter_subset_of_mem tTs) this
    

/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with
an index set which is an encodable type. -/
theorem dense_Inter_of_Gδ [Encodable β] {f : β → Set α} (ho : ∀ s, IsGδ (f s)) (hd : ∀ s, Dense (f s)) :
    Dense (⋂ s, f s) := by
  rw [← sInter_range]
  exact dense_sInter_of_Gδ (forall_range_iff.2 ‹_›) (countable_range _) (forall_range_iff.2 ‹_›)

/-- Baire theorem: a countable intersection of dense Gδ sets is dense. Formulated here with
an index set which is a countable set in any type. -/
theorem dense_bInter_of_Gδ {S : Set β} {f : ∀, ∀ x ∈ S, ∀, Set α} (ho : ∀, ∀ s ∈ S, ∀, IsGδ (f s ‹_›))
    (hS : Countable S) (hd : ∀, ∀ s ∈ S, ∀, Dense (f s ‹_›)) : Dense (⋂ s ∈ S, f s ‹_›) := by
  rw [bInter_eq_Inter]
  have := hS.to_encodable
  exact dense_Inter_of_Gδ (fun s => ho s s.2) fun s => hd s s.2

/-- Baire theorem: the intersection of two dense Gδ sets is dense. -/
theorem Dense.inter_of_Gδ {s t : Set α} (hs : IsGδ s) (ht : IsGδ t) (hsc : Dense s) (htc : Dense t) : Dense (s ∩ t) :=
  by
  rw [inter_eq_Inter]
  apply dense_Inter_of_Gδ <;> simp [Bool.forall_bool, *]

/-- A property holds on a residual (comeagre) set if and only if it holds on some dense `Gδ` set. -/
theorem eventually_residual {p : α → Prop} :
    (∀ᶠ x in residual α, p x) ↔ ∃ t : Set α, IsGδ t ∧ Dense t ∧ ∀, ∀ x ∈ t, ∀, p x :=
  calc
    (∀ᶠ x in residual α, p x) ↔ ∀ᶠ x in ⨅ (t : Set α) (ht : IsGδ t ∧ Dense t), 𝓟 t, p x := by
      simp only [residual, infi_and]
    _ ↔ ∃ (t : Set α)(ht : IsGδ t ∧ Dense t), ∀ᶠ x in 𝓟 t, p x :=
      mem_binfi_of_directed
        (fun t₁ h₁ t₂ h₂ =>
          ⟨t₁ ∩ t₂, ⟨h₁.1.inter h₂.1, Dense.inter_of_Gδ h₁.1 h₂.1 h₁.2 h₂.2⟩, by
            simp ⟩)
        ⟨Univ, is_Gδ_univ, dense_univ⟩
    _ ↔ _ := by
      simp [and_assoc]
    

-- ././Mathport/Syntax/Translate/Basic.lean:597:2: warning: expanding binder collection (t «expr ⊆ » s)
/-- A set is residual (comeagre) if and only if it includes a dense `Gδ` set. -/
theorem mem_residual {s : Set α} : s ∈ residual α ↔ ∃ (t : _)(_ : t ⊆ s), IsGδ t ∧ Dense t :=
  (@eventually_residual α _ _ fun x => x ∈ s).trans <|
    exists_congr fun t => by
      rw [exists_prop, and_comm (t ⊆ s), subset_def, and_assoc]

theorem dense_of_mem_residual {s : Set α} (hs : s ∈ residual α) : Dense s :=
  let ⟨t, hts, _, hd⟩ := mem_residual.1 hs
  hd.mono hts

instance : CountableInterFilter (residual α) :=
  ⟨by
    intro S hSc hS
    simp only [mem_residual] at *
    choose T hTs hT using hS
    refine' ⟨⋂ s ∈ S, T s ‹_›, _, _, _⟩
    · rw [sInter_eq_bInter]
      exact Inter₂_mono hTs
      
    · exact is_Gδ_bInter hSc fun s hs => (hT s hs).1
      
    · exact dense_bInter_of_Gδ (fun s hs => (hT s hs).1) hSc fun s hs => (hT s hs).2
      ⟩

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is a countable set in any type. -/
theorem dense_bUnion_interior_of_closed {S : Set β} {f : β → Set α} (hc : ∀, ∀ s ∈ S, ∀, IsClosed (f s))
    (hS : Countable S) (hU : (⋃ s ∈ S, f s) = univ) : Dense (⋃ s ∈ S, Interior (f s)) := by
  let g := fun s => Frontier (f s)ᶜ
  have : Dense (⋂ s ∈ S, g s) := by
    refine' dense_bInter_of_open (fun s hs => _) hS fun s hs => _
    show IsOpen (g s)
    exact is_open_compl_iff.2 is_closed_frontier
    show Dense (g s)
    · intro x
      simp [interior_frontier (hc s hs)]
      
  refine' this.mono _
  show (⋂ s ∈ S, g s) ⊆ ⋃ s ∈ S, Interior (f s)
  intro x hx
  have : x ∈ ⋃ s ∈ S, f s := by
    have := mem_univ x
    rwa [← hU] at this
  rcases mem_Union₂.1 this with ⟨s, hs, xs⟩
  have : x ∈ g s := mem_Inter₂.1 hx s hs
  have : x ∈ Interior (f s) := by
    have : x ∈ f s \ Frontier (f s) := mem_inter xs this
    simpa [Frontier, xs, (hc s hs).closure_eq] using this
  exact mem_Union₂.2 ⟨s, ⟨hs, this⟩⟩

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with `⋃₀`. -/
theorem dense_sUnion_interior_of_closed {S : Set (Set α)} (hc : ∀, ∀ s ∈ S, ∀, IsClosed s) (hS : Countable S)
    (hU : ⋃₀S = univ) : Dense (⋃ s ∈ S, Interior s) := by
  rw [sUnion_eq_bUnion] at hU <;> exact dense_bUnion_interior_of_closed hc hS hU

/-- Baire theorem: if countably many closed sets cover the whole space, then their interiors
are dense. Formulated here with an index set which is an encodable type. -/
theorem dense_Union_interior_of_closed [Encodable β] {f : β → Set α} (hc : ∀ s, IsClosed (f s))
    (hU : (⋃ s, f s) = univ) : Dense (⋃ s, Interior (f s)) := by
  rw [← bUnion_univ]
  apply dense_bUnion_interior_of_closed
  · simp [hc]
    
  · apply countable_encodable
    
  · rwa [← bUnion_univ] at hU
    

/-- One of the most useful consequences of Baire theorem: if a countable union of closed sets
covers the space, then one of the sets has nonempty interior. -/
theorem nonempty_interior_of_Union_of_closed [Nonempty α] [Encodable β] {f : β → Set α} (hc : ∀ s, IsClosed (f s))
    (hU : (⋃ s, f s) = univ) : ∃ s, (Interior <| f s).Nonempty := by
  by_contra h
  simp only [not_exists, not_nonempty_iff_eq_empty] at h
  have :=
    calc
      ∅ = Closure (⋃ s, Interior (f s)) := by
        simp [h]
      _ = univ := (dense_Union_interior_of_closed hc hU).closure_eq
      
  exact univ_nonempty.ne_empty this.symm

end BaireTheorem

