/-
Copyright (c) 2020 Patrick Massot. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Patrick Massot
-/
import Mathbin.Topology.Algebra.Order.ProjIcc
import Mathbin.Topology.ContinuousFunction.Basic
import Mathbin.Topology.UnitInterval

/-!
# Path connectedness

## Main definitions

In the file the unit interval `[0, 1]` in `‚Ñù` is denoted by `I`, and `X` is a topological space.

* `path (x y : X)` is the type of paths from `x` to `y`, i.e., continuous maps from `I` to `X`
  mapping `0` to `x` and `1` to `y`.
* `path.map` is the image of a path under a continuous map.
* `joined (x y : X)` means there is a path between `x` and `y`.
* `joined.some_path (h : joined x y)` selects some path between two points `x` and `y`.
* `path_component (x : X)` is the set of points joined to `x`.
* `path_connected_space X` is a predicate class asserting that `X` is non-empty and every two
  points of `X` are joined.

Then there are corresponding relative notions for `F : set X`.

* `joined_in F (x y : X)` means there is a path `Œ≥` joining `x` to `y` with values in `F`.
* `joined_in.some_path (h : joined_in F x y)` selects a path from `x` to `y` inside `F`.
* `path_component_in F (x : X)` is the set of points joined to `x` in `F`.
* `is_path_connected F` asserts that `F` is non-empty and every two
  points of `F` are joined in `F`.
* `loc_path_connected_space X` is a predicate class asserting that `X` is locally path-connected:
  each point has a basis of path-connected neighborhoods (we do *not* ask these to be open).

##¬†Main theorems

* `joined` and `joined_in F` are transitive relations.

One can link the absolute and relative version in two directions, using `(univ : set X)` or the
subtype `‚Ü•F`.

* `path_connected_space_iff_univ : path_connected_space X ‚Üî is_path_connected (univ : set X)`
* `is_path_connected_iff_path_connected_space : is_path_connected F ‚Üî path_connected_space ‚Ü•F`

For locally path connected spaces, we have
* `path_connected_space_iff_connected_space : path_connected_space X ‚Üî connected_space X`
* `is_connected_iff_is_path_connected (U_op : is_open U) : is_path_connected U ‚Üî is_connected U`

## Implementation notes

By default, all paths have `I` as their source and `X` as their target, but there is an
operation `set.Icc_extend` that will extend any continuous map `Œ≥ : I ‚Üí X` into a continuous map
`Icc_extend zero_le_one Œ≥ : ‚Ñù ‚Üí X` that is constant before `0` and after `1`.

This is used to define `path.extend` that turns `Œ≥ : path x y` into a continuous map
`Œ≥.extend : ‚Ñù ‚Üí X` whose restriction to `I` is the original `Œ≥`, and is equal to `x`
on `(-‚àû, 0]` and to `y` on `[1, +‚àû)`.
-/


noncomputable section

open Classical TopologicalSpace Filter UnitInterval

open Filter Set Function UnitInterval

variable {X Y : Type _} [TopologicalSpace X] [TopologicalSpace Y] {x y z : X} {Œπ : Type _}

/-! ### Paths -/


/-- Continuous path connecting two points `x` and `y` in a topological space -/
@[nolint has_inhabited_instance]
structure Path (x y : X) extends C(I, X) where
  source' : to_fun 0 = x
  target' : to_fun 1 = y

instance : CoeFun (Path x y) fun _ => I ‚Üí X :=
  ‚ü®fun p => p.toFun‚ü©

@[ext]
protected theorem Path.ext : ‚àÄ {Œ≥‚ÇÅ Œ≥‚ÇÇ : Path x y}, (Œ≥‚ÇÅ : I ‚Üí X) = Œ≥‚ÇÇ ‚Üí Œ≥‚ÇÅ = Œ≥‚ÇÇ
  | ‚ü®‚ü®x, h11‚ü©, h12, h13‚ü©, ‚ü®‚ü®x, h21‚ü©, h22, h23‚ü©, rfl => rfl

namespace Path

@[simp]
theorem coe_mk (f : I ‚Üí X) h‚ÇÅ h‚ÇÇ h‚ÇÉ : ‚áë(mk ‚ü®f, h‚ÇÅ‚ü© h‚ÇÇ h‚ÇÉ : Path x y) = f :=
  rfl

variable (Œ≥ : Path x y)

@[continuity]
protected theorem continuous : Continuous Œ≥ :=
  Œ≥.continuous_to_fun

@[simp]
protected theorem source : Œ≥ 0 = x :=
  Œ≥.source'

@[simp]
protected theorem target : Œ≥ 1 = y :=
  Œ≥.target'

/-- See Note [custom simps projection]. We need to specify this projection explicitly in this case,
because it is a composition of multiple projections. -/
def Simps.apply : I ‚Üí X :=
  Œ≥

initialize_simps_projections Path (to_continuous_map_to_fun ‚Üí simps.apply, -toContinuousMap)

@[simp]
theorem coe_to_continuous_map : ‚áëŒ≥.toContinuousMap = Œ≥ :=
  rfl

/-- Any function `œÜ : Œ† (a : Œ±), path (x a) (y a)` can be seen as a function `Œ± √ó I ‚Üí X`. -/
instance hasUncurryPath {X Œ± : Type _} [TopologicalSpace X] {x y : Œ± ‚Üí X} :
    HasUncurry (‚àÄ a : Œ±, Path (x a) (y a)) (Œ± √ó I) X :=
  ‚ü®fun œÜ p => œÜ p.1 p.2‚ü©

/-- The constant path from a point to itself -/
@[refl, simps]
def refl (x : X) : Path x x where
  toFun := fun t => x
  continuous_to_fun := continuous_const
  source' := rfl
  target' := rfl

@[simp]
theorem refl_range {a : X} : Range (Path.refl a) = {a} := by
  simp [‚Üê Path.refl, ‚Üê CoeFun.coe, ‚Üê coeFn]

/-- The reverse of a path from `x` to `y`, as a path from `y` to `x` -/
@[symm, simps]
def symm (Œ≥ : Path x y) : Path y x where
  toFun := Œ≥ ‚àò œÉ
  continuous_to_fun := by
    continuity
  source' := by
    simpa [-Path.target] using Œ≥.target
  target' := by
    simpa [-Path.source] using Œ≥.source

@[simp]
theorem symm_symm {Œ≥ : Path x y} : Œ≥.symm.symm = Œ≥ := by
  ext
  simp

@[simp]
theorem refl_symm {a : X} : (Path.refl a).symm = Path.refl a := by
  ext
  rfl

@[simp]
theorem symm_range {a b : X} (Œ≥ : Path a b) : Range Œ≥.symm = Range Œ≥ := by
  ext x
  simp only [‚Üê mem_range, ‚Üê Path.symm, ‚Üê CoeFun.coe, ‚Üê coeFn, ‚Üê UnitInterval.symm, ‚Üê SetCoe.exists, ‚Üê comp_app, ‚Üê
    Subtype.coe_mk, ‚Üê Subtype.val_eq_coe]
  constructor <;> rintro ‚ü®y, hy, hxy‚ü© <;> refine' ‚ü®1 - y, mem_iff_one_sub_mem.mp hy, _‚ü© <;> convert hxy
  simp

/-- A continuous map extending a path to `‚Ñù`, constant before `0` and after `1`. -/
def extend : ‚Ñù ‚Üí X :=
  iccExtend zero_le_one Œ≥

/-- See Note [continuity lemma statement]. -/
theorem _root_.continuous.path_extend {Œ≥ : Y ‚Üí Path x y} {f : Y ‚Üí ‚Ñù} (hŒ≥ : Continuous ‚ÜøŒ≥) (hf : Continuous f) :
    Continuous fun t => (Œ≥ t).extend (f t) :=
  Continuous.Icc_extend hŒ≥ hf

/-- A useful special case of `continuous.path_extend`. -/
@[continuity]
theorem continuous_extend : Continuous Œ≥.extend :=
  Œ≥.Continuous.Icc_extend'

theorem _root_.filter.tendsto.path_extend {X Y : Type _} [TopologicalSpace X] [TopologicalSpace Y] {l r : Y ‚Üí X} {y : Y}
    {l‚ÇÅ : Filter ‚Ñù} {l‚ÇÇ : Filter X} {Œ≥ : ‚àÄ y, Path (l y) (r y)}
    (hŒ≥ : Tendsto (‚ÜøŒ≥) (ùìù y √ó·∂† l‚ÇÅ.map (projIcc 0 1 zero_le_one)) l‚ÇÇ) :
    Tendsto (‚Üøfun x => (Œ≥ x).extend) (ùìù y √ó·∂† l‚ÇÅ) l‚ÇÇ :=
  Filter.Tendsto.Icc_extend _ hŒ≥

theorem _root_.continuous_at.path_extend {g : Y ‚Üí ‚Ñù} {l r : Y ‚Üí X} (Œ≥ : ‚àÄ y, Path (l y) (r y)) {y : Y}
    (hŒ≥ : ContinuousAt (‚ÜøŒ≥) (y, projIcc 0 1 zero_le_one (g y))) (hg : ContinuousAt g y) :
    ContinuousAt (fun i => (Œ≥ i).extend (g i)) y :=
  hŒ≥.iccExtend (fun x => Œ≥ x) hg

@[simp]
theorem extend_extends {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) {t : ‚Ñù} (ht : t ‚àà (Icc 0 1 : Set ‚Ñù)) :
    Œ≥.extend t = Œ≥ ‚ü®t, ht‚ü© :=
  Icc_extend_of_mem _ Œ≥ ht

theorem extend_zero : Œ≥.extend 0 = x := by
  simp

theorem extend_one : Œ≥.extend 1 = y := by
  simp

@[simp]
theorem extend_extends' {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) (t : (Icc 0 1 : Set ‚Ñù)) :
    Œ≥.extend t = Œ≥ t :=
  Icc_extend_coe _ Œ≥ t

@[simp]
theorem extend_range {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) : Range Œ≥.extend = Range Œ≥ :=
  Icc_extend_range _ Œ≥

theorem extend_of_le_zero {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) {t : ‚Ñù} (ht : t ‚â§ 0) :
    Œ≥.extend t = a :=
  (Icc_extend_of_le_left _ _ ht).trans Œ≥.source

theorem extend_of_one_le {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) {t : ‚Ñù} (ht : 1 ‚â§ t) :
    Œ≥.extend t = b :=
  (Icc_extend_of_right_le _ _ ht).trans Œ≥.target

@[simp]
theorem refl_extend {X : Type _} [TopologicalSpace X] {a : X} : (Path.refl a).extend = fun _ => a :=
  rfl

/-- The path obtained from a map defined on `‚Ñù` by restriction to the unit interval. -/
def ofLine {f : ‚Ñù ‚Üí X} (hf : ContinuousOn f I) (h‚ÇÄ : f 0 = x) (h‚ÇÅ : f 1 = y) : Path x y where
  toFun := f ‚àò coe
  continuous_to_fun := hf.comp_continuous continuous_subtype_coe Subtype.prop
  source' := h‚ÇÄ
  target' := h‚ÇÅ

theorem of_line_mem {f : ‚Ñù ‚Üí X} (hf : ContinuousOn f I) (h‚ÇÄ : f 0 = x) (h‚ÇÅ : f 1 = y) :
    ‚àÄ t, ofLine hf h‚ÇÄ h‚ÇÅ t ‚àà f '' I := fun ‚ü®t, t_in‚ü© => ‚ü®t, t_in, rfl‚ü©

attribute [local simp] Iic_def

/-- Concatenation of two paths from `x` to `y` and from `y` to `z`, putting the first
path on `[0, 1/2]` and the second one on `[1/2, 1]`. -/
@[trans]
def trans (Œ≥ : Path x y) (Œ≥' : Path y z) : Path x z where
  toFun := (fun t : ‚Ñù => if t ‚â§ 1 / 2 then Œ≥.extend (2 * t) else Œ≥'.extend (2 * t - 1)) ‚àò coe
  continuous_to_fun := by
    refine'
      (Continuous.if_le _ _ continuous_id continuous_const
            (by
              norm_num)).comp
        continuous_subtype_coe
    -- TODO: the following are provable by `continuity` but it is too slow
    exacts[Œ≥.continuous_extend.comp (continuous_const.mul continuous_id),
      Œ≥'.continuous_extend.comp ((continuous_const.mul continuous_id).sub continuous_const)]
  source' := by
    norm_num
  target' := by
    norm_num

theorem trans_apply (Œ≥ : Path x y) (Œ≥' : Path y z) (t : I) :
    (Œ≥.trans Œ≥') t =
      if h : (t : ‚Ñù) ‚â§ 1 / 2 then Œ≥ ‚ü®2 * t, (mul_pos_mem_iff zero_lt_two).2 ‚ü®t.2.1, h‚ü©‚ü©
      else Œ≥' ‚ü®2 * t - 1, two_mul_sub_one_mem_iff.2 ‚ü®(not_le‚Çì.1 h).le, t.2.2‚ü©‚ü© :=
  show ite _ _ _ = _ by
    split_ifs <;> rw [extend_extends]

@[simp]
theorem trans_symm (Œ≥ : Path x y) (Œ≥' : Path y z) : (Œ≥.trans Œ≥').symm = Œ≥'.symm.trans Œ≥.symm := by
  ext t
  simp only [‚Üê trans_apply, one_div, ‚Üê symm_apply, ‚Üê not_le‚Çì, ‚Üê comp_app]
  split_ifs with h h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ <;> rw [coe_symm_eq] at h
  ¬∑ have ht : (t : ‚Ñù) = 1 / 2 := by
      linarith [UnitInterval.nonneg t, UnitInterval.le_one t]
    norm_num [‚Üê ht]
    
  ¬∑ refine' congr_arg _ (Subtype.ext _)
    norm_num [‚Üê sub_sub_eq_add_sub, ‚Üê mul_sub]
    
  ¬∑ refine' congr_arg _ (Subtype.ext _)
    have h : 2 - 2 * (t : ‚Ñù) - 1 = 1 - 2 * t := by
      linarith
    norm_num [‚Üê mul_sub, ‚Üê h]
    
  ¬∑ exfalso
    linarith [UnitInterval.nonneg t, UnitInterval.le_one t]
    

@[simp]
theorem refl_trans_refl {X : Type _} [TopologicalSpace X] {a : X} : (Path.refl a).trans (Path.refl a) = Path.refl a :=
  by
  ext
  simp only [‚Üê Path.trans, ‚Üê if_t_t, ‚Üê one_div, ‚Üê Path.refl_extend]
  rfl

theorem trans_range {X : Type _} [TopologicalSpace X] {a b c : X} (Œ≥‚ÇÅ : Path a b) (Œ≥‚ÇÇ : Path b c) :
    Range (Œ≥‚ÇÅ.trans Œ≥‚ÇÇ) = Range Œ≥‚ÇÅ ‚à™ Range Œ≥‚ÇÇ := by
  rw [Path.trans]
  apply eq_of_subset_of_subset
  ¬∑ rintro x ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©
    by_cases' h : t ‚â§ 1 / 2
    ¬∑ left
      use 2 * t,
        ‚ü®by
          linarith, by
          linarith‚ü©
      rw [‚Üê Œ≥‚ÇÅ.extend_extends]
      unfold_coes  at hxt
      simp only [‚Üê h, ‚Üê comp_app, ‚Üê if_true] at hxt
      exact hxt
      
    ¬∑ right
      use 2 * t - 1,
        ‚ü®by
          linarith, by
          linarith‚ü©
      rw [‚Üê Œ≥‚ÇÇ.extend_extends]
      unfold_coes  at hxt
      simp only [‚Üê h, ‚Üê comp_app, ‚Üê if_false] at hxt
      exact hxt
      
    
  ¬∑ rintro x (‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü© | ‚ü®‚ü®t, ht0, ht1‚ü©, hxt‚ü©)
    ¬∑ use
        ‚ü®t / 2,
          ‚ü®by
            linarith, by
            linarith‚ü©‚ü©
      unfold_coes
      have : t / 2 ‚â§ 1 / 2 := by
        linarith
      simp only [‚Üê this, ‚Üê comp_app, ‚Üê if_true]
      ring_nf
      rwa [Œ≥‚ÇÅ.extend_extends]
      
    ¬∑ by_cases' h : t = 0
      ¬∑ use
          ‚ü®1 / 2,
            ‚ü®by
              linarith, by
              linarith‚ü©‚ü©
        unfold_coes
        simp only [‚Üê h, ‚Üê comp_app, ‚Üê if_true, ‚Üê le_refl‚Çì, ‚Üê mul_one_div_cancel (@two_ne_zero ‚Ñù _ _)]
        rw [Œ≥‚ÇÅ.extend_one]
        rwa [‚Üê Œ≥‚ÇÇ.extend_extends, h, Œ≥‚ÇÇ.extend_zero] at hxt
        
      ¬∑ use
          ‚ü®(t + 1) / 2,
            ‚ü®by
              linarith, by
              linarith‚ü©‚ü©
        unfold_coes
        change t ‚â† 0 at h
        have ht0 := lt_of_le_of_ne‚Çì ht0 h.symm
        have : ¬¨(t + 1) / 2 ‚â§ 1 / 2 := by
          rw [not_le‚Çì]
          linarith
        simp only [‚Üê comp_app, ‚Üê if_false, ‚Üê this]
        ring_nf
        rwa [Œ≥‚ÇÇ.extend_extends]
        
      
    

/-- Image of a path from `x` to `y` by a continuous map -/
def map (Œ≥ : Path x y) {Y : Type _} [TopologicalSpace Y] {f : X ‚Üí Y} (h : Continuous f) : Path (f x) (f y) where
  toFun := f ‚àò Œ≥
  continuous_to_fun := by
    continuity
  source' := by
    simp
  target' := by
    simp

@[simp]
theorem map_coe (Œ≥ : Path x y) {Y : Type _} [TopologicalSpace Y] {f : X ‚Üí Y} (h : Continuous f) :
    (Œ≥.map h : I ‚Üí Y) = f ‚àò Œ≥ := by
  ext t
  rfl

@[simp]
theorem map_symm (Œ≥ : Path x y) {Y : Type _} [TopologicalSpace Y] {f : X ‚Üí Y} (h : Continuous f) :
    (Œ≥.map h).symm = Œ≥.symm.map h :=
  rfl

@[simp]
theorem map_trans (Œ≥ : Path x y) (Œ≥' : Path y z) {Y : Type _} [TopologicalSpace Y] {f : X ‚Üí Y} (h : Continuous f) :
    (Œ≥.trans Œ≥').map h = (Œ≥.map h).trans (Œ≥'.map h) := by
  ext t
  rw [trans_apply, map_coe, comp_app, trans_apply]
  split_ifs <;> rfl

@[simp]
theorem map_id (Œ≥ : Path x y) : Œ≥.map continuous_id = Œ≥ := by
  ext
  rfl

@[simp]
theorem map_map (Œ≥ : Path x y) {Y : Type _} [TopologicalSpace Y] {Z : Type _} [TopologicalSpace Z] {f : X ‚Üí Y}
    (hf : Continuous f) {g : Y ‚Üí Z} (hg : Continuous g) : (Œ≥.map hf).map hg = Œ≥.map (hg.comp hf) := by
  ext
  rfl

/-- Casting a path from `x` to `y` to a path from `x'` to `y'` when `x' = x` and `y' = y` -/
def cast (Œ≥ : Path x y) {x' y'} (hx : x' = x) (hy : y' = y) : Path x' y' where
  toFun := Œ≥
  continuous_to_fun := Œ≥.Continuous
  source' := by
    simp [‚Üê hx]
  target' := by
    simp [‚Üê hy]

@[simp]
theorem symm_cast {X : Type _} [TopologicalSpace X] {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : X} (Œ≥ : Path a‚ÇÇ b‚ÇÇ) (ha : a‚ÇÅ = a‚ÇÇ) (hb : b‚ÇÅ = b‚ÇÇ) :
    (Œ≥.cast ha hb).symm = Œ≥.symm.cast hb ha :=
  rfl

@[simp]
theorem trans_cast {X : Type _} [TopologicalSpace X] {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ c‚ÇÅ c‚ÇÇ : X} (Œ≥ : Path a‚ÇÇ b‚ÇÇ) (Œ≥' : Path b‚ÇÇ c‚ÇÇ)
    (ha : a‚ÇÅ = a‚ÇÇ) (hb : b‚ÇÅ = b‚ÇÇ) (hc : c‚ÇÅ = c‚ÇÇ) : (Œ≥.cast ha hb).trans (Œ≥'.cast hb hc) = (Œ≥.trans Œ≥').cast ha hc :=
  rfl

@[simp]
theorem cast_coe (Œ≥ : Path x y) {x' y'} (hx : x' = x) (hy : y' = y) : (Œ≥.cast hx hy : I ‚Üí X) = Œ≥ :=
  rfl

@[continuity]
theorem symm_continuous_family {X Œπ : Type _} [TopologicalSpace X] [TopologicalSpace Œπ] {a b : Œπ ‚Üí X}
    (Œ≥ : ‚àÄ t : Œπ, Path (a t) (b t)) (h : Continuous ‚ÜøŒ≥) : Continuous ‚Üøfun t => (Œ≥ t).symm :=
  h.comp (continuous_id.prod_map continuous_symm)

@[continuity]
theorem continuous_uncurry_extend_of_continuous_family {X Œπ : Type _} [TopologicalSpace X] [TopologicalSpace Œπ]
    {a b : Œπ ‚Üí X} (Œ≥ : ‚àÄ t : Œπ, Path (a t) (b t)) (h : Continuous ‚ÜøŒ≥) : Continuous ‚Üøfun t => (Œ≥ t).extend :=
  h.comp (continuous_id.prod_map continuous_proj_Icc)

@[continuity]
theorem trans_continuous_family {X Œπ : Type _} [TopologicalSpace X] [TopologicalSpace Œπ] {a b c : Œπ ‚Üí X}
    (Œ≥‚ÇÅ : ‚àÄ t : Œπ, Path (a t) (b t)) (h‚ÇÅ : Continuous ‚ÜøŒ≥‚ÇÅ) (Œ≥‚ÇÇ : ‚àÄ t : Œπ, Path (b t) (c t)) (h‚ÇÇ : Continuous ‚ÜøŒ≥‚ÇÇ) :
    Continuous ‚Üøfun t => (Œ≥‚ÇÅ t).trans (Œ≥‚ÇÇ t) := by
  have h‚ÇÅ' := Path.continuous_uncurry_extend_of_continuous_family Œ≥‚ÇÅ h‚ÇÅ
  have h‚ÇÇ' := Path.continuous_uncurry_extend_of_continuous_family Œ≥‚ÇÇ h‚ÇÇ
  simp only [‚Üê has_uncurry.uncurry, ‚Üê CoeFun.coe, ‚Üê coeFn, ‚Üê Path.trans, ‚Üê (¬∑ ‚àò ¬∑)]
  refine' Continuous.if_le _ _ (continuous_subtype_coe.comp continuous_snd) continuous_const _
  ¬∑ change Continuous ((fun p : Œπ √ó ‚Ñù => (Œ≥‚ÇÅ p.1).extend p.2) ‚àò Prod.map id (fun x => 2 * x : I ‚Üí ‚Ñù))
    exact h‚ÇÅ'.comp (continuous_id.prod_map <| continuous_const.mul continuous_subtype_coe)
    
  ¬∑ change Continuous ((fun p : Œπ √ó ‚Ñù => (Œ≥‚ÇÇ p.1).extend p.2) ‚àò Prod.map id (fun x => 2 * x - 1 : I ‚Üí ‚Ñù))
    exact h‚ÇÇ'.comp (continuous_id.prod_map <| (continuous_const.mul continuous_subtype_coe).sub continuous_const)
    
  ¬∑ rintro st hst
    simp [‚Üê hst, ‚Üê mul_inv_cancel (@two_ne_zero ‚Ñù _ _)]
    

/-! #### Product of paths -/


section Prod

variable {a‚ÇÅ a‚ÇÇ a‚ÇÉ : X} {b‚ÇÅ b‚ÇÇ b‚ÇÉ : Y}

/-- Given a path in `X` and a path in `Y`, we can take their pointwise product to get a path in
`X √ó Y`. -/
protected def prod (Œ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ) (Œ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ) : Path (a‚ÇÅ, b‚ÇÅ) (a‚ÇÇ, b‚ÇÇ) where
  toContinuousMap := ContinuousMap.prodMk Œ≥‚ÇÅ.toContinuousMap Œ≥‚ÇÇ.toContinuousMap
  source' := by
    simp
  target' := by
    simp

@[simp]
theorem prod_coe_fn (Œ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ) (Œ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ) : coeFn (Œ≥‚ÇÅ.Prod Œ≥‚ÇÇ) = fun t => (Œ≥‚ÇÅ t, Œ≥‚ÇÇ t) :=
  rfl

/-- Path composition commutes with products -/
theorem trans_prod_eq_prod_trans (Œ≥‚ÇÅ : Path a‚ÇÅ a‚ÇÇ) (Œ¥‚ÇÅ : Path a‚ÇÇ a‚ÇÉ) (Œ≥‚ÇÇ : Path b‚ÇÅ b‚ÇÇ) (Œ¥‚ÇÇ : Path b‚ÇÇ b‚ÇÉ) :
    (Œ≥‚ÇÅ.Prod Œ≥‚ÇÇ).trans (Œ¥‚ÇÅ.Prod Œ¥‚ÇÇ) = (Œ≥‚ÇÅ.trans Œ¥‚ÇÅ).Prod (Œ≥‚ÇÇ.trans Œ¥‚ÇÇ) := by
  ext t <;>
    unfold Path.trans <;> simp only [‚Üê Path.coe_mk, ‚Üê Path.prod_coe_fn, ‚Üê Function.comp_app] <;> split_ifs <;> rfl

end Prod

section Pi

variable {œá : Œπ ‚Üí Type _} [‚àÄ i, TopologicalSpace (œá i)] {as bs cs : ‚àÄ i, œá i}

/-- Given a family of paths, one in each X·µ¢, we take their pointwise product to get a path in
Œ† i, X·µ¢. -/
protected def pi (Œ≥ : ‚àÄ i, Path (as i) (bs i)) : Path as bs where
  toContinuousMap := ContinuousMap.pi fun i => (Œ≥ i).toContinuousMap
  source' := by
    simp
  target' := by
    simp

@[simp]
theorem pi_coe_fn (Œ≥ : ‚àÄ i, Path (as i) (bs i)) : coeFn (Path.pi Œ≥) = fun t i => Œ≥ i t :=
  rfl

/-- Path composition commutes with products -/
theorem trans_pi_eq_pi_trans (Œ≥‚ÇÄ : ‚àÄ i, Path (as i) (bs i)) (Œ≥‚ÇÅ : ‚àÄ i, Path (bs i) (cs i)) :
    (Path.pi Œ≥‚ÇÄ).trans (Path.pi Œ≥‚ÇÅ) = Path.pi fun i => (Œ≥‚ÇÄ i).trans (Œ≥‚ÇÅ i) := by
  ext t i
  unfold Path.trans
  simp only [‚Üê Path.coe_mk, ‚Üê Function.comp_app, ‚Üê pi_coe_fn]
  split_ifs <;> rfl

end Pi

/-! #### Pointwise multiplication/addition of two paths in a topological (additive) group -/


/-- Pointwise multiplication of paths in a topological group. The additive version is probably more
useful. -/
@[to_additive "Pointwise addition of paths in a topological additive group."]
protected def mul [Mul X] [HasContinuousMul X] {a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X} (Œ≥‚ÇÅ : Path a‚ÇÅ b‚ÇÅ) (Œ≥‚ÇÇ : Path a‚ÇÇ b‚ÇÇ) :
    Path (a‚ÇÅ * a‚ÇÇ) (b‚ÇÅ * b‚ÇÇ) :=
  (Œ≥‚ÇÅ.Prod Œ≥‚ÇÇ).map continuous_mul

@[to_additive]
protected theorem mul_apply [Mul X] [HasContinuousMul X] {a‚ÇÅ b‚ÇÅ a‚ÇÇ b‚ÇÇ : X} (Œ≥‚ÇÅ : Path a‚ÇÅ b‚ÇÅ) (Œ≥‚ÇÇ : Path a‚ÇÇ b‚ÇÇ)
    (t : UnitInterval) : (Œ≥‚ÇÅ.mul Œ≥‚ÇÇ) t = Œ≥‚ÇÅ t * Œ≥‚ÇÇ t :=
  rfl

/-! #### Truncating a path -/


/-- `Œ≥.truncate t‚ÇÄ t‚ÇÅ` is the path which follows the path `Œ≥` on the
  time interval `[t‚ÇÄ, t‚ÇÅ]` and stays still otherwise. -/
def truncate {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) (t‚ÇÄ t‚ÇÅ : ‚Ñù) :
    Path (Œ≥.extend <| min t‚ÇÄ t‚ÇÅ) (Œ≥.extend t‚ÇÅ) where
  toFun := fun s => Œ≥.extend (min (max s t‚ÇÄ) t‚ÇÅ)
  continuous_to_fun := Œ≥.continuous_extend.comp ((continuous_subtype_coe.max continuous_const).min continuous_const)
  source' := by
    simp only [‚Üê min_def, ‚Üê max_def]
    norm_cast
    split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ
    ¬∑ simp [‚Üê Œ≥.extend_of_le_zero h‚ÇÅ]
      
    ¬∑ congr
      linarith
      
    ¬∑ have h‚ÇÑ : t‚ÇÅ ‚â§ 0 :=
        le_of_lt‚Çì
          (by
            simpa using h‚ÇÇ)
      simp [‚Üê Œ≥.extend_of_le_zero h‚ÇÑ, ‚Üê Œ≥.extend_of_le_zero h‚ÇÅ]
      
    all_goals
      rfl
  target' := by
    simp only [‚Üê min_def, ‚Üê max_def]
    norm_cast
    split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÉ
    ¬∑ simp [‚Üê Œ≥.extend_of_one_le h‚ÇÇ]
      
    ¬∑ rfl
      
    ¬∑ have h‚ÇÑ : 1 ‚â§ t‚ÇÄ :=
        le_of_lt‚Çì
          (by
            simpa using h‚ÇÅ)
      simp [‚Üê Œ≥.extend_of_one_le h‚ÇÑ, ‚Üê Œ≥.extend_of_one_le (h‚ÇÑ.trans h‚ÇÉ)]
      
    ¬∑ rfl
      

/-- `Œ≥.truncate_of_le t‚ÇÄ t‚ÇÅ h`, where `h : t‚ÇÄ ‚â§ t‚ÇÅ` is `Œ≥.truncate t‚ÇÄ t‚ÇÅ`
  casted as a path from `Œ≥.extend t‚ÇÄ` to `Œ≥.extend t‚ÇÅ`. -/
def truncateOfLe {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) {t‚ÇÄ t‚ÇÅ : ‚Ñù} (h : t‚ÇÄ ‚â§ t‚ÇÅ) :
    Path (Œ≥.extend t‚ÇÄ) (Œ≥.extend t‚ÇÅ) :=
  (Œ≥.truncate t‚ÇÄ t‚ÇÅ).cast
    (by
      rw [min_eq_left‚Çì h])
    rfl

theorem truncate_range {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) {t‚ÇÄ t‚ÇÅ : ‚Ñù} :
    Range (Œ≥.truncate t‚ÇÄ t‚ÇÅ) ‚äÜ Range Œ≥ := by
  rw [‚Üê Œ≥.extend_range]
  simp only [‚Üê range_subset_iff, ‚Üê SetCoe.exists, ‚Üê SetCoe.forall]
  intro x hx
  simp only [‚Üê CoeFun.coe, ‚Üê coeFn, ‚Üê Path.truncate, ‚Üê mem_range_self]

/-- For a path `Œ≥`, `Œ≥.truncate` gives a "continuous family of paths", by which we
  mean the uncurried function which maps `(t‚ÇÄ, t‚ÇÅ, s)` to `Œ≥.truncate t‚ÇÄ t‚ÇÅ s` is continuous. -/
@[continuity]
theorem truncate_continuous_family {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) :
    Continuous (fun x => Œ≥.truncate x.1 x.2.1 x.2.2 : ‚Ñù √ó ‚Ñù √ó I ‚Üí X) :=
  Œ≥.continuous_extend.comp
    (((continuous_subtype_coe.comp (continuous_snd.comp continuous_snd)).max continuous_fst).min
      (continuous_fst.comp continuous_snd))

/- TODO : When `continuity` gets quicker, change the proof back to :
    `begin`
      `simp only [has_coe_to_fun.coe, coe_fn, path.truncate],`
      `continuity,`
      `exact continuous_subtype_coe`
    `end` -/
@[continuity]
theorem truncate_const_continuous_family {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) (t : ‚Ñù) :
    Continuous ‚Üø(Œ≥.truncate t) := by
  have key : Continuous (fun x => (t, x) : ‚Ñù √ó I ‚Üí ‚Ñù √ó ‚Ñù √ó I) := continuous_const.prod_mk continuous_id
  convert Œ≥.truncate_continuous_family.comp key

@[simp]
theorem truncate_self {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) (t : ‚Ñù) :
    Œ≥.truncate t t =
      (Path.refl <| Œ≥.extend t).cast
        (by
          rw [min_self‚Çì])
        rfl :=
  by
  ext x
  rw [cast_coe]
  simp only [‚Üê truncate, ‚Üê CoeFun.coe, ‚Üê coeFn, ‚Üê refl, ‚Üê min_def, ‚Üê max_def]
  split_ifs with h‚ÇÅ h‚ÇÇ <;> congr
  exact le_antisymm‚Çì ‚Äπ_‚Ä∫ ‚Äπ_‚Ä∫

@[simp]
theorem truncate_zero_zero {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) :
    Œ≥.truncate 0 0 =
      (Path.refl a).cast
        (by
          rw [min_self‚Çì, Œ≥.extend_zero])
        Œ≥.extend_zero :=
  by
  convert Œ≥.truncate_self 0 <;> exact Œ≥.extend_zero.symm

@[simp]
theorem truncate_one_one {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) :
    Œ≥.truncate 1 1 =
      (Path.refl b).cast
        (by
          rw [min_self‚Çì, Œ≥.extend_one])
        Œ≥.extend_one :=
  by
  convert Œ≥.truncate_self 1 <;> exact Œ≥.extend_one.symm

@[simp]
theorem truncate_zero_one {X : Type _} [TopologicalSpace X] {a b : X} (Œ≥ : Path a b) :
    Œ≥.truncate 0 1 =
      Œ≥.cast
        (by
          simp [‚Üê zero_le_one, ‚Üê extend_zero])
        (by
          simp ) :=
  by
  ext x
  rw [cast_coe]
  have : ‚Üëx ‚àà (Icc 0 1 : Set ‚Ñù) := x.2
  rw [truncate, coe_mk, max_eq_left‚Çì this.1, min_eq_left‚Çì this.2, extend_extends']

/-! #### Reparametrising a path -/


/-- Given a path `Œ≥` and a function `f : I ‚Üí I` where `f 0 = 0` and `f 1 = 1`, `Œ≥.reparam f` is the
path defined by `Œ≥ ‚àò f`.
-/
def reparam (Œ≥ : Path x y) (f : I ‚Üí I) (hfcont : Continuous f) (hf‚ÇÄ : f 0 = 0) (hf‚ÇÅ : f 1 = 1) : Path x y where
  toFun := Œ≥ ‚àò f
  continuous_to_fun := by
    continuity
  source' := by
    simp [‚Üê hf‚ÇÄ]
  target' := by
    simp [‚Üê hf‚ÇÅ]

@[simp]
theorem coe_to_fun (Œ≥ : Path x y) {f : I ‚Üí I} (hfcont : Continuous f) (hf‚ÇÄ : f 0 = 0) (hf‚ÇÅ : f 1 = 1) :
    ‚áë(Œ≥.reparam f hfcont hf‚ÇÄ hf‚ÇÅ) = Œ≥ ‚àò f :=
  rfl

@[simp]
theorem reparam_id (Œ≥ : Path x y) : Œ≥.reparam id continuous_id rfl rfl = Œ≥ := by
  ext
  rfl

theorem range_reparam (Œ≥ : Path x y) {f : I ‚Üí I} (hfcont : Continuous f) (hf‚ÇÄ : f 0 = 0) (hf‚ÇÅ : f 1 = 1) :
    Range ‚áë(Œ≥.reparam f hfcont hf‚ÇÄ hf‚ÇÅ) = Range Œ≥ := by
  change range (Œ≥ ‚àò f) = range Œ≥
  have : range f = univ := by
    rw [range_iff_surjective]
    intro t
    have h‚ÇÅ : Continuous (Icc_extend (zero_le_one' ‚Ñù) f) := by
      continuity
    have := intermediate_value_Icc (zero_le_one' ‚Ñù) h‚ÇÅ.continuous_on
    ¬∑ rw [Icc_extend_left, Icc_extend_right] at this
      change Icc (f 0) (f 1) ‚äÜ _ at this
      rw [hf‚ÇÄ, hf‚ÇÅ] at this
      rcases this t.2 with ‚ü®w, hw‚ÇÅ, hw‚ÇÇ‚ü©
      rw [Icc_extend_of_mem _ _ hw‚ÇÅ] at hw‚ÇÇ
      use ‚ü®w, hw‚ÇÅ‚ü©, hw‚ÇÇ
      
  rw [range_comp, this, image_univ]

theorem refl_reparam {f : I ‚Üí I} (hfcont : Continuous f) (hf‚ÇÄ : f 0 = 0) (hf‚ÇÅ : f 1 = 1) :
    (refl x).reparam f hfcont hf‚ÇÄ hf‚ÇÅ = refl x := by
  ext
  simp

end Path

/-! ### Being joined by a path -/


/-- The relation "being joined by a path". This is an equivalence relation. -/
def Joined (x y : X) : Prop :=
  Nonempty (Path x y)

@[refl]
theorem Joined.refl (x : X) : Joined x x :=
  ‚ü®Path.refl x‚ü©

/-- When two points are joined, choose some path from `x` to `y`. -/
def Joined.somePath (h : Joined x y) : Path x y :=
  Nonempty.some h

@[symm]
theorem Joined.symm {x y : X} (h : Joined x y) : Joined y x :=
  ‚ü®h.somePath.symm‚ü©

@[trans]
theorem Joined.trans {x y z : X} (hxy : Joined x y) (hyz : Joined y z) : Joined x z :=
  ‚ü®hxy.somePath.trans hyz.somePath‚ü©

variable (X)

/-- The setoid corresponding the equivalence relation of being joined by a continuous path. -/
def pathSetoid : Setoid‚Çì X where
  R := Joined
  iseqv := mk_equivalence _ Joined.refl (fun x y => Joined.symm) fun x y z => Joined.trans

/-- The quotient type of points of a topological space modulo being joined by a continuous path. -/
def ZerothHomotopy :=
  Quotient‚Çì (pathSetoid X)

instance : Inhabited (ZerothHomotopy ‚Ñù) :=
  ‚ü®@Quotient‚Çì.mk ‚Ñù (pathSetoid ‚Ñù) 0‚ü©

variable {X}

/-! ### Being joined by a path inside a set -/


/-- The relation "being joined by a path in `F`". Not quite an equivalence relation since it's not
reflexive for points that do not belong to `F`. -/
def JoinedIn (F : Set X) (x y : X) : Prop :=
  ‚àÉ Œ≥ : Path x y, ‚àÄ t, Œ≥ t ‚àà F

variable {F : Set X}

theorem JoinedIn.mem (h : JoinedIn F x y) : x ‚àà F ‚àß y ‚àà F := by
  rcases h with ‚ü®Œ≥, Œ≥_in‚ü©
  have : Œ≥ 0 ‚àà F ‚àß Œ≥ 1 ‚àà F := by
    constructor <;> apply Œ≥_in
  simpa using this

theorem JoinedIn.source_mem (h : JoinedIn F x y) : x ‚àà F :=
  h.Mem.1

theorem JoinedIn.target_mem (h : JoinedIn F x y) : y ‚àà F :=
  h.Mem.2

/-- When `x` and `y` are joined in `F`, choose a path from `x` to `y` inside `F` -/
def JoinedIn.somePath (h : JoinedIn F x y) : Path x y :=
  Classical.some h

theorem JoinedIn.some_path_mem (h : JoinedIn F x y) (t : I) : h.somePath t ‚àà F :=
  Classical.some_spec h t

/-- If `x` and `y` are joined in the set `F`, then they are joined in the subtype `F`. -/
theorem JoinedIn.joined_subtype (h : JoinedIn F x y) : Joined (‚ü®x, h.source_mem‚ü© : F) (‚ü®y, h.target_mem‚ü© : F) :=
  ‚ü®{ toFun := fun t => ‚ü®h.somePath t, h.some_path_mem t‚ü©,
      continuous_to_fun := by
        continuity,
      source' := by
        simp ,
      target' := by
        simp }‚ü©

theorem JoinedIn.of_line {f : ‚Ñù ‚Üí X} (hf : ContinuousOn f I) (h‚ÇÄ : f 0 = x) (h‚ÇÅ : f 1 = y) (hF : f '' I ‚äÜ F) :
    JoinedIn F x y :=
  ‚ü®Path.ofLine hf h‚ÇÄ h‚ÇÅ, fun t => hF <| Path.of_line_mem hf h‚ÇÄ h‚ÇÅ t‚ü©

theorem JoinedIn.joined (h : JoinedIn F x y) : Joined x y :=
  ‚ü®h.somePath‚ü©

theorem joined_in_iff_joined (x_in : x ‚àà F) (y_in : y ‚àà F) : JoinedIn F x y ‚Üî Joined (‚ü®x, x_in‚ü© : F) (‚ü®y, y_in‚ü© : F) :=
  ‚ü®fun h => h.joined_subtype, fun h =>
    ‚ü®h.somePath.map continuous_subtype_coe, by
      simp ‚ü©‚ü©

@[simp]
theorem joined_in_univ : JoinedIn Univ x y ‚Üî Joined x y := by
  simp [‚Üê JoinedIn, ‚Üê Joined, ‚Üê exists_true_iff_nonempty]

theorem JoinedIn.mono {U V : Set X} (h : JoinedIn U x y) (hUV : U ‚äÜ V) : JoinedIn V x y :=
  ‚ü®h.somePath, fun t => hUV (h.some_path_mem t)‚ü©

theorem JoinedIn.refl (h : x ‚àà F) : JoinedIn F x x :=
  ‚ü®Path.refl x, fun t => h‚ü©

@[symm]
theorem JoinedIn.symm (h : JoinedIn F x y) : JoinedIn F y x := by
  cases' h.mem with hx hy
  simp_all [‚Üê joined_in_iff_joined]
  exact h.symm

theorem JoinedIn.trans (hxy : JoinedIn F x y) (hyz : JoinedIn F y z) : JoinedIn F x z := by
  cases' hxy.mem with hx hy
  cases' hyz.mem with hx hy
  simp_all [‚Üê joined_in_iff_joined]
  exact hxy.trans hyz

/-! ### Path component -/


/-- The path component of `x` is the set of points that can be joined to `x`. -/
def PathComponent (x : X) :=
  { y | Joined x y }

@[simp]
theorem mem_path_component_self (x : X) : x ‚àà PathComponent x :=
  Joined.refl x

@[simp]
theorem PathComponent.nonempty (x : X) : (PathComponent x).Nonempty :=
  ‚ü®x, mem_path_component_self x‚ü©

theorem mem_path_component_of_mem (h : x ‚àà PathComponent y) : y ‚àà PathComponent x :=
  Joined.symm h

theorem path_component_symm : x ‚àà PathComponent y ‚Üî y ‚àà PathComponent x :=
  ‚ü®fun h => mem_path_component_of_mem h, fun h => mem_path_component_of_mem h‚ü©

theorem path_component_congr (h : x ‚àà PathComponent y) : PathComponent x = PathComponent y := by
  ext z
  constructor
  ¬∑ intro h'
    rw [path_component_symm]
    exact (h.trans h').symm
    
  ¬∑ intro h'
    rw [path_component_symm] at h'‚ä¢
    exact h'.trans h
    

theorem path_component_subset_component (x : X) : PathComponent x ‚äÜ ConnectedComponent x := fun y h =>
  (is_connected_range h.somePath.Continuous).subset_connected_component
    ‚ü®0, by
      simp ‚ü©
    ‚ü®1, by
      simp ‚ü©

/-- The path component of `x` in `F` is the set of points that can be joined to `x` in `F`. -/
def PathComponentIn (x : X) (F : Set X) :=
  { y | JoinedIn F x y }

@[simp]
theorem path_component_in_univ (x : X) : PathComponentIn x Univ = PathComponent x := by
  simp [‚Üê PathComponentIn, ‚Üê PathComponent, ‚Üê JoinedIn, ‚Üê Joined, ‚Üê exists_true_iff_nonempty]

theorem Joined.mem_path_component (hyz : Joined y z) (hxy : y ‚àà PathComponent x) : z ‚àà PathComponent x :=
  hxy.trans hyz

/-! ### Path connected sets -/


/-- A set `F` is path connected if it contains a point that can be joined to all other in `F`. -/
def IsPathConnected (F : Set X) : Prop :=
  ‚àÉ x ‚àà F, ‚àÄ {y}, y ‚àà F ‚Üí JoinedIn F x y

theorem is_path_connected_iff_eq : IsPathConnected F ‚Üî ‚àÉ x ‚àà F, PathComponentIn x F = F := by
  constructor <;> rintro ‚ü®x, x_in, h‚ü© <;> use x, x_in
  ¬∑ ext y
    exact ‚ü®fun hy => hy.Mem.2, h‚ü©
    
  ¬∑ intro y y_in
    rwa [‚Üê h] at y_in
    

-- ./././Mathport/Syntax/Translate/Basic.lean:701:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª F)
theorem IsPathConnected.joined_in (h : IsPathConnected F) : ‚àÄ x y _ : x ‚àà F _ : y ‚àà F, JoinedIn F x y :=
  fun x x_in x y_in =>
  let ‚ü®b, b_in, hb‚ü© := h
  (hb x_in).symm.trans (hb y_in)

-- ./././Mathport/Syntax/Translate/Basic.lean:701:2: warning: expanding binder collection (x y ¬´expr ‚àà ¬ª F)
theorem is_path_connected_iff : IsPathConnected F ‚Üî F.Nonempty ‚àß ‚àÄ x y _ : x ‚àà F _ : y ‚àà F, JoinedIn F x y :=
  ‚ü®fun h =>
    ‚ü®let ‚ü®b, b_in, hb‚ü© := h
      ‚ü®b, b_in‚ü©,
      h.JoinedIn‚ü©,
    fun ‚ü®‚ü®b, b_in‚ü©, h‚ü© => ‚ü®b, b_in, fun x x_in => h b b_in x x_in‚ü©‚ü©

theorem IsPathConnected.image {Y : Type _} [TopologicalSpace Y] (hF : IsPathConnected F) {f : X ‚Üí Y}
    (hf : Continuous f) : IsPathConnected (f '' F) := by
  rcases hF with ‚ü®x, x_in, hx‚ü©
  use f x, mem_image_of_mem f x_in
  rintro _ ‚ü®y, y_in, rfl‚ü©
  exact ‚ü®(hx y_in).somePath.map hf, fun t => ‚ü®_, (hx y_in).some_path_mem t, rfl‚ü©‚ü©

theorem IsPathConnected.mem_path_component (h : IsPathConnected F) (x_in : x ‚àà F) (y_in : y ‚àà F) :
    y ‚àà PathComponent x :=
  (h.JoinedIn x x_in y y_in).Joined

theorem IsPathConnected.subset_path_component (h : IsPathConnected F) (x_in : x ‚àà F) : F ‚äÜ PathComponent x :=
  fun y y_in => h.mem_path_component x_in y_in

theorem IsPathConnected.union {U V : Set X} (hU : IsPathConnected U) (hV : IsPathConnected V) (hUV : (U ‚à© V).Nonempty) :
    IsPathConnected (U ‚à™ V) := by
  rcases hUV with ‚ü®x, xU, xV‚ü©
  use x, Or.inl xU
  rintro y (yU | yV)
  ¬∑ exact (hU.joined_in x xU y yU).mono (subset_union_left U V)
    
  ¬∑ exact (hV.joined_in x xV y yV).mono (subset_union_right U V)
    

/-- If a set `W` is path-connected, then it is also path-connected when seen as a set in a smaller
ambient type `U` (when `U` contains `W`). -/
theorem IsPathConnected.preimage_coe {U W : Set X} (hW : IsPathConnected W) (hWU : W ‚äÜ U) :
    IsPathConnected ((coe : U ‚Üí X) ‚Åª¬π' W) := by
  rcases hW with ‚ü®x, x_in, hx‚ü©
  use ‚ü®x, hWU x_in‚ü©, by
    simp [‚Üê x_in]
  rintro ‚ü®y, hyU‚ü© hyW
  exact
    ‚ü®(hx hyW).joined_subtype.somePath.map (continuous_inclusion hWU), by
      simp ‚ü©

theorem IsPathConnected.exists_path_through_family {X : Type _} [TopologicalSpace X] {n : ‚Ñï} {s : Set X}
    (h : IsPathConnected s) (p : Fin‚Çì (n + 1) ‚Üí X) (hp : ‚àÄ i, p i ‚àà s) :
    ‚àÉ Œ≥ : Path (p 0) (p n), Range Œ≥ ‚äÜ s ‚àß ‚àÄ i, p i ‚àà Range Œ≥ := by
  let p' : ‚Ñï ‚Üí X := fun k => if h : k < n + 1 then p ‚ü®k, h‚ü© else p ‚ü®0, n.zero_lt_succ‚ü©
  obtain ‚ü®Œ≥, hŒ≥‚ü© : ‚àÉ Œ≥ : Path (p' 0) (p' n), (‚àÄ, ‚àÄ i ‚â§ n, ‚àÄ, p' i ‚àà range Œ≥) ‚àß range Œ≥ ‚äÜ s := by
    have hp' : ‚àÄ, ‚àÄ i ‚â§ n, ‚àÄ, p' i ‚àà s := by
      intro i hi
      simp [‚Üê p', ‚Üê Nat.lt_succ_of_le‚Çì hi, ‚Üê hp]
    clear_value p'
    clear hp p
    induction' n with n hn
    ¬∑ use Path.refl (p' 0)
      ¬∑ constructor
        ¬∑ rintro i hi
          rw [nat.le_zero_iff.mp hi]
          exact ‚ü®0, rfl‚ü©
          
        ¬∑ rw [range_subset_iff]
          rintro x
          exact hp' 0 le_rfl
          
        
      
    ¬∑ rcases hn fun i hi => hp' i <| Nat.le_succ_of_le‚Çì hi with ‚ü®Œ≥‚ÇÄ, hŒ≥‚ÇÄ‚ü©
      rcases h.joined_in (p' n) (hp' n n.le_succ) (p' <| n + 1) (hp' (n + 1) <| le_rfl) with ‚ü®Œ≥‚ÇÅ, hŒ≥‚ÇÅ‚ü©
      let Œ≥ : Path (p' 0) (p' <| n + 1) := Œ≥‚ÇÄ.trans Œ≥‚ÇÅ
      use Œ≥
      have range_eq : range Œ≥ = range Œ≥‚ÇÄ ‚à™ range Œ≥‚ÇÅ := Œ≥‚ÇÄ.trans_range Œ≥‚ÇÅ
      constructor
      ¬∑ rintro i hi
        by_cases' hi' : i ‚â§ n
        ¬∑ rw [range_eq]
          left
          exact hŒ≥‚ÇÄ.1 i hi'
          
        ¬∑ rw [not_le‚Çì, ‚Üê Nat.succ_le_iff] at hi'
          have : i = n.succ := by
            linarith
          rw [this]
          use 1
          exact Œ≥.target
          
        
      ¬∑ rw [range_eq]
        apply union_subset hŒ≥‚ÇÄ.2
        rw [range_subset_iff]
        exact hŒ≥‚ÇÅ
        
      
  have hpp' : ‚àÄ, ‚àÄ k < n + 1, ‚àÄ, p k = p' k := by
    intro k hk
    simp only [‚Üê p', ‚Üê hk, ‚Üê dif_pos]
    congr
    ext
    rw [Fin‚Çì.coe_coe_of_lt hk]
    norm_cast
  use Œ≥.cast (hpp' 0 n.zero_lt_succ) (hpp' n n.lt_succ_self)
  simp only [‚Üê Œ≥.cast_coe]
  refine' And.intro hŒ≥.2 _
  rintro ‚ü®i, hi‚ü©
  suffices p ‚ü®i, hi‚ü© = p' i by
    convert hŒ≥.1 i (Nat.le_of_lt_succ‚Çì hi)
  rw [‚Üê hpp' i hi]
  suffices i = i % n.succ by
    congr
    assumption
  rw [Nat.mod_eq_of_lt‚Çì hi]

theorem IsPathConnected.exists_path_through_family' {X : Type _} [TopologicalSpace X] {n : ‚Ñï} {s : Set X}
    (h : IsPathConnected s) (p : Fin‚Çì (n + 1) ‚Üí X) (hp : ‚àÄ i, p i ‚àà s) :
    ‚àÉ (Œ≥ : Path (p 0) (p n))(t : Fin‚Çì (n + 1) ‚Üí I), (‚àÄ t, Œ≥ t ‚àà s) ‚àß ‚àÄ i, Œ≥ (t i) = p i := by
  rcases h.exists_path_through_family p hp with ‚ü®Œ≥, hŒ≥‚ü©
  rcases hŒ≥ with ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©
  simp only [‚Üê range, ‚Üê mem_set_of_eq] at h‚ÇÇ
  rw [range_subset_iff] at h‚ÇÅ
  choose! t ht using h‚ÇÇ
  exact ‚ü®Œ≥, t, h‚ÇÅ, ht‚ü©

/-! ### Path connected spaces -/


/-- A topological space is path-connected if it is non-empty and every two points can be
joined by a continuous path. -/
class PathConnectedSpace (X : Type _) [TopologicalSpace X] : Prop where
  Nonempty : Nonempty X
  Joined : ‚àÄ x y : X, Joined x y

theorem path_connected_space_iff_zeroth_homotopy :
    PathConnectedSpace X ‚Üî Nonempty (ZerothHomotopy X) ‚àß Subsingleton (ZerothHomotopy X) := by
  let this := pathSetoid X
  constructor
  ¬∑ intro h
    refine' ‚ü®(nonempty_quotient_iff _).mpr h.1, ‚ü®_‚ü©‚ü©
    rintro ‚ü®x‚ü© ‚ü®y‚ü©
    exact Quotient‚Çì.sound (PathConnectedSpace.joined x y)
    
  ¬∑ unfold ZerothHomotopy
    rintro ‚ü®h, h'‚ü©
    skip
    exact ‚ü®(nonempty_quotient_iff _).mp h, fun x y => Quotient‚Çì.exact <| Subsingleton.elim‚Çì ‚ü¶x‚üß ‚ü¶y‚üß‚ü©
    

namespace PathConnectedSpace

variable [PathConnectedSpace X]

/-- Use path-connectedness to build a path between two points. -/
def somePath (x y : X) : Path x y :=
  Nonempty.some (joined x y)

end PathConnectedSpace

theorem is_path_connected_iff_path_connected_space : IsPathConnected F ‚Üî PathConnectedSpace F := by
  rw [is_path_connected_iff]
  constructor
  ¬∑ rintro ‚ü®‚ü®x, x_in‚ü©, h‚ü©
    refine' ‚ü®‚ü®‚ü®x, x_in‚ü©‚ü©, _‚ü©
    rintro ‚ü®y, y_in‚ü© ‚ü®z, z_in‚ü©
    have H := h y y_in z z_in
    rwa [joined_in_iff_joined y_in z_in] at H
    
  ¬∑ rintro ‚ü®‚ü®x, x_in‚ü©, H‚ü©
    refine' ‚ü®‚ü®x, x_in‚ü©, fun y y_in z z_in => _‚ü©
    rw [joined_in_iff_joined y_in z_in]
    apply H
    

theorem path_connected_space_iff_univ : PathConnectedSpace X ‚Üî IsPathConnected (Univ : Set X) := by
  constructor
  ¬∑ intro h
    have := @PathConnectedSpace.nonempty X _ _
    inhabit X
    refine' ‚ü®default, mem_univ _, _‚ü©
    simpa using PathConnectedSpace.joined default
    
  ¬∑ intro h
    have h' := h.joined_in
    cases' h with x h
    exact
      ‚ü®‚ü®x‚ü©, by
        simpa using h'‚ü©
    

theorem path_connected_space_iff_eq : PathConnectedSpace X ‚Üî ‚àÉ x : X, PathComponent x = univ := by
  simp [‚Üê path_connected_space_iff_univ, ‚Üê is_path_connected_iff_eq]

-- see Note [lower instance priority]
instance (priority := 100) PathConnectedSpace.connected_space [PathConnectedSpace X] : ConnectedSpace X := by
  rw [connected_space_iff_connected_component]
  rcases is_path_connected_iff_eq.mp (path_connected_space_iff_univ.mp ‚Äπ_‚Ä∫) with ‚ü®x, x_in, hx‚ü©
  use x
  rw [‚Üê univ_subset_iff]
  exact
    (by
        simpa using hx : PathComponent x = univ) ‚ñ∏
      path_component_subset_component x

theorem IsPathConnected.is_connected (hF : IsPathConnected F) : IsConnected F := by
  rw [is_connected_iff_connected_space]
  rw [is_path_connected_iff_path_connected_space] at hF
  exact @PathConnectedSpace.connected_space _ _ hF

namespace PathConnectedSpace

variable [PathConnectedSpace X]

theorem exists_path_through_family {n : ‚Ñï} (p : Fin‚Çì (n + 1) ‚Üí X) : ‚àÉ Œ≥ : Path (p 0) (p n), ‚àÄ i, p i ‚àà Range Œ≥ := by
  have : IsPathConnected (univ : Set X) :=
    path_connected_space_iff_univ.mp
      (by
        infer_instance)
  rcases this.exists_path_through_family p fun i => True.intro with ‚ü®Œ≥, -, h‚ü©
  exact ‚ü®Œ≥, h‚ü©

theorem exists_path_through_family' {n : ‚Ñï} (p : Fin‚Çì (n + 1) ‚Üí X) :
    ‚àÉ (Œ≥ : Path (p 0) (p n))(t : Fin‚Çì (n + 1) ‚Üí I), ‚àÄ i, Œ≥ (t i) = p i := by
  have : IsPathConnected (univ : Set X) :=
    path_connected_space_iff_univ.mp
      (by
        infer_instance)
  rcases this.exists_path_through_family' p fun i => True.intro with ‚ü®Œ≥, t, -, h‚ü©
  exact ‚ü®Œ≥, t, h‚ü©

end PathConnectedSpace

/-! ### Locally path connected spaces -/


/-- A topological space is locally path connected, at every point, path connected
neighborhoods form a neighborhood basis. -/
class LocPathConnectedSpace (X : Type _) [TopologicalSpace X] : Prop where
  path_connected_basis : ‚àÄ x : X, (ùìù x).HasBasis (fun s : Set X => s ‚àà ùìù x ‚àß IsPathConnected s) id

export LocPathConnectedSpace (path_connected_basis)

theorem loc_path_connected_of_bases {p : Œπ ‚Üí Prop} {s : X ‚Üí Œπ ‚Üí Set X} (h : ‚àÄ x, (ùìù x).HasBasis p (s x))
    (h' : ‚àÄ x i, p i ‚Üí IsPathConnected (s x i)) : LocPathConnectedSpace X := by
  constructor
  intro x
  apply (h x).to_has_basis
  ¬∑ intro i pi
    exact
      ‚ü®s x i, ‚ü®(h x).mem_of_mem pi, h' x i pi‚ü©, by
        rfl‚ü©
    
  ¬∑ rintro U ‚ü®U_in, hU‚ü©
    rcases(h x).mem_iff.mp U_in with ‚ü®i, pi, hi‚ü©
    tauto
    

theorem path_connected_space_iff_connected_space [LocPathConnectedSpace X] : PathConnectedSpace X ‚Üî ConnectedSpace X :=
  by
  constructor
  ¬∑ intro h
    infer_instance
    
  ¬∑ intro hX
    rw [path_connected_space_iff_eq]
    use Classical.arbitrary X
    refine'
      eq_univ_of_nonempty_clopen
        (by
          simp )
        ‚ü®_, _‚ü©
    ¬∑ rw [is_open_iff_mem_nhds]
      intro y y_in
      rcases(path_connected_basis y).ex_mem with ‚ü®U, ‚ü®U_in, hU‚ü©‚ü©
      apply mem_of_superset U_in
      rw [‚Üê path_component_congr y_in]
      exact hU.subset_path_component (mem_of_mem_nhds U_in)
      
    ¬∑ rw [is_closed_iff_nhds]
      intro y H
      rcases(path_connected_basis y).ex_mem with ‚ü®U, ‚ü®U_in, hU‚ü©‚ü©
      rcases H U U_in with ‚ü®z, hz, hz'‚ü©
      exact (hU.joined_in z hz y <| mem_of_mem_nhds U_in).Joined.mem_path_component hz'
      
    

theorem path_connected_subset_basis [LocPathConnectedSpace X] {U : Set X} (h : IsOpen U) (hx : x ‚àà U) :
    (ùìù x).HasBasis (fun s : Set X => s ‚àà ùìù x ‚àß IsPathConnected s ‚àß s ‚äÜ U) id :=
  (path_connected_basis x).has_basis_self_subset (IsOpen.mem_nhds h hx)

theorem loc_path_connected_of_is_open [LocPathConnectedSpace X] {U : Set X} (h : IsOpen U) : LocPathConnectedSpace U :=
  ‚ü®by
    rintro ‚ü®x, x_in‚ü©
    rw [nhds_subtype_eq_comap]
    constructor
    intro V
    rw [(has_basis.comap (coe : U ‚Üí X) (path_connected_subset_basis h x_in)).mem_iff]
    constructor
    ¬∑ rintro ‚ü®W, ‚ü®W_in, hW, hWU‚ü©, hWV‚ü©
      exact ‚ü®coe ‚Åª¬π' W, ‚ü®‚ü®preimage_mem_comap W_in, hW.preimage_coe hWU‚ü©, hWV‚ü©‚ü©
      
    ¬∑ rintro ‚ü®W, ‚ü®W_in, hW‚ü©, hWV‚ü©
      refine'
        ‚ü®coe '' W,
          ‚ü®Filter.image_coe_mem_of_mem_comap (IsOpen.mem_nhds h x_in) W_in, hW.image continuous_subtype_coe,
            Subtype.coe_image_subset U W‚ü©,
          _‚ü©
      rintro x ‚ü®y, ‚ü®y_in, hy‚ü©‚ü©
      rw [‚Üê Subtype.coe_injective hy]
      tauto
      ‚ü©

theorem IsOpen.is_connected_iff_is_path_connected [LocPathConnectedSpace X] {U : Set X} (U_op : IsOpen U) :
    IsPathConnected U ‚Üî IsConnected U := by
  rw [is_connected_iff_connected_space, is_path_connected_iff_path_connected_space]
  have := loc_path_connected_of_is_open U_op
  exact path_connected_space_iff_connected_space

