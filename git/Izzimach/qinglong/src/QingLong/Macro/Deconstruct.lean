-- Deconstruct freer monads generated by FreerMacro


import Lean
import Lean.Parser

import QingLong.Macro.FreerMacro


open Lean Elab Expr Command Meta Term
open Freer

#check evalExpr

namespace Deconstruct

def spaceN (n : Nat) : String := String.mk <| List.replicate n ' '

partial
def goExpr (t : Expr) (indent : Nat) : MetaM Unit := do
  let preSpace := spaceN indent
  let dumpX := fun s => IO.println <| preSpace ++ s
  match t with
  | bvar ix _ => dumpX <| "bvar=" ++ toString ix
  | fvar fid _ => dumpX <| "fvar=" ++ toString fid.name
  | mvar mid _ => dumpX <| "mvar=" ++ toString mid.name
  | sort lvl _ => dumpX <| "sort"
  | const n levels _ => dumpX <| "const=" ++ n.toString
  | app f arg _ => dumpX "app "; goExpr f (indent+1); goExpr arg (indent+1)
  | lam n arg body _ => dumpX ("lam > " ++ n.toString); goExpr arg (indent+1); goExpr body (indent+1)
  | forallE n a b _ => dumpX ("forall " ++ n.toString); goExpr a (indent+1); goExpr b (indent+1)
--  | letE n t v b _ => dumpX ("let " ++ n.toString); goExpr t (indent+1); goExpr v (indent+1); goExpr (b.instantiate1 v) (indent+1)
  | letE n t v b _ => do
      dumpX ("let " ++ n.toString)
      goExpr t (indent+1)
      goExpr v (indent+1)
      goExpr b (indent+1)
  | lit (Literal.natVal n) _ => dumpX <| "lit=" ++ toString n
  | lit (Literal.strVal s) _ => dumpX <| "lit=" ++ s
  | mdata md e _ => dumpX "mdata"
  | proj n ix e _ => dumpX "proj"


def walkExpr (thing : Syntax) : TermElabM Expr := do
  let thingExpr ← elabTerm thing Option.none
  let e ← getEnv
  /-let zi := e.find? (Name.mkSimple "zzz")
  match zi with
  | Option.some (.defnInfo v) => do
      IO.println "zzz type: "
      goExpr v.type 0
  | _ => pure ()-/
  let et ← inferType thingExpr
  IO.println "thing type: "
  goExpr et 0
  IO.println "thing expression: "
  goExpr thingExpr 0
  --logInfo <| thingExpr
  pure <| Lean.mkConst `Nat.zero


-- The forall value in a type is basically an argument: forall x (forall y z) is "x → y → z"
-- This takes the set of nested foralls and breaks them into a list of argument types
def unfoldForalls : Expr → List Expr
| forallE n a rest _ => a :: unfoldForalls rest
| x => [x]

-- given some name from a ConstantInfo returns true if this is a match call (match_1, match_2, etc.)
def isMatchCall : Name → Bool := fun n =>
    match n.components.getLast? with
    | Option.none => false
    | Option.some v => String.isPrefixOf "match_" v.toString


elab "walkExpr" thing:term : term => walkExpr thing


def TransformerApp : Type := List Expr → (List Expr → Expr → TermElabM Expr) → TermElabM Expr

-- Dirty beta-reduce. We try to beta reduce functions, with the expectation that some
-- expressions will be malformed since we may not have all the information we need.
def magicBR (argStack : List Expr) (funcBody : Expr) (offset : Nat) : Expr :=
    match funcBody with
    | bvar ix _ => @Option.getD Expr (argStack.get? (offset - ix)) (Lean.mkStrLit "Bad bound variable")
    | app f arg z => Expr.app (magicBR argStack f offset) (magicBR argStack arg offset) z
    | lam n e c z => Expr.lam n e (magicBR argStack c (offset + 1)) z
    | x => x


#print KVMap

--
-- "You are a MAGIC SKELETON packed with MEAT and animated by ELECTRICITY and IMAGINATION.
--  You have a cave in your face full of sharp bones and five tentacles at the end of each arm.
--  YOU CAN DO ANYTHING, MAGIC SKELETON" -- Chuck Wendig
--
partial def magicSkeleton (transformers : List (String × TransformerApp)) (argStack : List Expr) (e : Expr) : TermElabM Expr :=
    match e with
    | const c _ _ => do
        let fullName := c.toString
        match c.components.getLast? with
        | Option.none => pure <| Lean.mkStrLit fullName
        | Option.some l => 
            match transformers.lookup l.toString with
            | Option.some f => f argStack (magicSkeleton transformers)
            | Option.none => do
                let e ← getEnv
                let v := e.find? c
                match v with
                | Option.none => pure <| Lean.mkStrLit ("Unknown const " ++ toString c)
                | Option.some ci => do
                    match ci.value? with
                    | Option.none => do
                        --logInfo argStack
                        pure <| Lean.mkStrLit ("no value for constantinfo of " ++ toString c ++ " constantinfo=" ++ toString ci.name ++ " ctor?=" ++ toString ci.isCtor ++ " inductive?=" ++ toString ci.isInductive)
                    | Option.some val =>
                        match (isMatchCall c), (transformers.lookup "match") with
                        | true, Option.some matchBuild => do
                            let et ← inferType val
                            let matchArgs := unfoldForalls et
                            -- In a match "function", the first two args are motive and actual value, so we skip them.
                            -- The last argument of the type is the result, so ignore that too.
                            logInfo matchArgs
                            let branchCount := matchArgs.length - 3
                            -- pull the branches out of the argument stack
                            let branches := List.toArray <| List.take branchCount <| List.drop 2 argStack
                            let breakBranches ← Array.sequenceMap branches (fun z => magicSkeleton transformers argStack z)
                            matchBuild (Array.toList breakBranches) (magicSkeleton transformers)
                        | _, _ => magicSkeleton transformers argStack val
    | app f arg _ => magicSkeleton transformers (arg :: argStack) f
    | lam _ _ body _ => do
        -- try to substitute in bound variables and then skeletonize it
        let peBody := magicBR argStack body 0
        magicSkeleton transformers argStack peBody
    | _ => do
        --logInfo <| toString e
        pure <| Lean.mkStrLit "zort"

syntax (name := skeletonize) "goSkeleton" term " ::: " term : term

set_option hygiene false in
elab "genMagicSkeleton" skelName:ident " >: " transforms:term " :< " : command => do
    let skelCommand ← 
        `(@[termElab skeletonize]
          def $skelName : TermElab := fun stx oxe => do
              let e ← elabTerm (Syntax.getArg stx 1) Option.none
              magicSkeleton $transforms [] e
         )
    elabCommand skelCommand

def x3 : Nat → Nat → Nat := fun z y => z + 3
def ack : String → Nat := fun _ => 4
def blargh2 : String → Nat := fun _ => 77

structure Zort (a : Type) where
  (v₁ : a) (v₂ : a)

inductive FreerSkeleton (t : Type) where
| Error : String → FreerSkeleton t
| Empty
| Pure : (α : Type) → α → FreerSkeleton t
| Command : t → FreerSkeleton t 
| Bind : FreerSkeleton t → FreerSkeleton t → FreerSkeleton t
| NonDet : FreerSkeleton t → FreerSkeleton t → FreerSkeleton t

def dumpFreerSkeleton {t : Type} [ToString t] : FreerSkeleton t → String
    | .Error e => "Error : " ++ e
    | .Empty   => "Empty"
    | .Pure tx x => "Pure ?"
    | .Command t => "Command: " ++ toString t
    | .Bind a b => dumpFreerSkeleton a ++ " >>= " ++ dumpFreerSkeleton b
    | .NonDet a b => "(" ++ dumpFreerSkeleton a ++ " || " ++ dumpFreerSkeleton b ++ ")"

instance [ToString t] : ToString (FreerSkeleton t) where
    toString := dumpFreerSkeleton

def listToNonDetFreer (targetType : Expr) (l :List Expr) : Expr :=
    match l with
    | List.nil => Lean.mkApp (Lean.mkConst ``FreerSkeleton.Empty) targetType
    | List.cons h List.nil => h
    | List.cons h t => Lean.mkAppN (Lean.mkConst ``FreerSkeleton.NonDet) #[targetType, h, listToNonDetFreer targetType t]


def stdMonadSkeleton (resultTypeName : Name) : List (String × TransformerApp) :=
[
    ⟨"bind",fun args mk => do
        let a₁ ← mk args (args.get! 4)
        let a₂ ← mk (Lean.mkStrLit "badArg" :: args) (args.get! 5)
        pure <| Lean.mkAppN (Lean.mkConst ``FreerSkeleton.Bind) #[(Lean.mkConst resultTypeName), a₁,a₂]⟩,
    ⟨"pure",fun args mk => do
        let et := args.get! 2
        let a := args.get! 3
        pure <| Lean.mkAppN (Lean.mkConst ``FreerSkeleton.Pure) #[Lean.mkConst resultTypeName, et, a]⟩,
    ⟨"ite",fun args mk => do
        let b₁ ← mk args (args.get! 3)
        let b₂ ← mk args (args.get! 4)
        pure <| Lean.mkAppN (Lean.mkConst ``FreerSkeleton.NonDet) #[Lean.mkConst resultTypeName, b₁, b₂]⟩,
    ⟨"match",fun branches mk => pure <| listToNonDetFreer (Lean.mkConst resultTypeName) branches⟩
]

--genMagicSkeleton mutexSkel >: stdMonadSkeleton ``String :<

--#check goSkeleton (x3 (blargh2 "a") (ack "zoz")) ::: 7
--#check goSkeleton (do let z ← pure 3; IO.println z : IO Unit) ::: 7

--def x := goSkeleton (do let z ← pure 3; IO.println z : IO Unit) ::: 7


end Deconstruct