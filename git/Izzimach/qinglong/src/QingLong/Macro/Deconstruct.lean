-- Deconstruct freer monads generated by FreerMacro


import Lean
import Lean.Parser

import QingLong.Macro.FreerMacro


open Lean Elab Expr Command Meta Term
open Freer

namespace Deconstruct

def spaceN (n : Nat) : String := String.mk <| List.replicate n ' '

partial
def goExpr (t : Expr) (indent : Nat) : MetaM Unit := do
  let preSpace := spaceN indent
  let dumpX := fun s => IO.println <| preSpace ++ s
  match t with
  | bvar ix _ => dumpX <| "bvar=" ++ toString ix
  | fvar fid _ => dumpX <| "fvar=" ++ toString fid.name
  | mvar mid _ => dumpX <| "mvar=" ++ toString mid.name
  | sort lvl _ => dumpX <| "sort"
  | const n levels _ => dumpX <| "const=" ++ n.toString
  | app f arg _ => dumpX "app "; goExpr f (indent+1); goExpr arg (indent+1)
  | lam n arg body _ => dumpX ("lam > " ++ n.toString); goExpr arg (indent+1); goExpr body (indent+1)
  | forallE n a b _ => dumpX ("forall " ++ n.toString); goExpr a (indent+1); goExpr b (indent+1)
--  | letE n t v b _ => dumpX ("let " ++ n.toString); goExpr t (indent+1); goExpr v (indent+1); goExpr (b.instantiate1 v) (indent+1)
  | letE n t v b _ => do
      dumpX ("let " ++ n.toString)
      goExpr t (indent+1)
      goExpr v (indent+1)
      goExpr b (indent+1)
  | lit (Literal.natVal n) _ => dumpX <| "lit=" ++ toString n
  | lit (Literal.strVal s) _ => dumpX <| "lit=" ++ s
  | mdata md e _ => dumpX "mdata"
  | proj n ix e _ => dumpX "proj"


def walkExpr (thing : Syntax) : TermElabM Expr := do
  let thingExpr ← elabTerm thing Option.none
  let e ← getEnv
  /-let zi := e.find? (Name.mkSimple "zzz")
  match zi with
  | Option.some (.defnInfo v) => do
      IO.println "zzz type: "
      goExpr v.type 0
  | _ => pure ()-/
  let et ← inferType thingExpr
  IO.println "thing type: "
  goExpr et 0
  IO.println "thing expression: "
  goExpr thingExpr 0
  --logInfo <| thingExpr
  pure <| Lean.mkConst `Nat.zero

inductive MonadSequence where
| Error : String → MonadSequence
| Empty
| Pure : MonadSequence
| Command : String → MonadSequence
| Bind : MonadSequence → MonadSequence → MonadSequence
| NonDet : MonadSequence → MonadSequence → MonadSequence
  deriving Repr

def mqError (s : String) : Expr := Lean.mkApp (Lean.mkConst ``MonadSequence.Error) (Lean.mkStrLit s)
def mqCommand (s : String) : Expr := Lean.mkApp (Lean.mkConst ``MonadSequence.Command) (Lean.mkStrLit s)

-- dirty beta-reduce. We try to beta reduce functions, with the expectation that some
-- expressions are malformed.
def dirtyBR (funcBody : Expr) (argStack : List Expr) (offset : Nat) : Expr :=
    match funcBody with
    | bvar ix _ => @Option.getD Expr (argStack.get? (offset - ix)) (mqError "bad bound variable")
    | app f arg z => Expr.app (dirtyBR f argStack offset) (dirtyBR arg argStack offset) z
    | lam n e c z => Expr.lam n e (dirtyBR c argStack (offset + 1)) z
    | x => x

def i1 : Expr := (Lean.mkConst ``IO)

-- compare two monads to see if they match except for the result type
-- i.e., meq (IO Nat) (IO Unit) is true
def monadEq : Expr → Expr → MetaM Bool := fun t1 t2 =>
    match (t1,t2) with
    | (app f1 _ _, app f2 _ _) => isDefEq f1 f2
    | _ => pure false

-- given a parameterized type, strip off the last parameter so it's (Type → Type)
-- and compare to a monad type that is already of the form Type → Type
def monadMatch : Expr → Expr → MetaM Bool := fun t m =>
    match t with
    | app m2 _ _ => isDefEq m m2
    | forallE n a b _ => monadMatch b m
    | _ => pure false

def checkAgainstMonads : Expr → List Expr → MetaM (Option Nat) := fun t l =>
    match l with
    | List.nil => pure Option.none
    | List.cons head tail => do
        let m ← monadMatch t head
        if m
        then pure (Option.some 0)
        else do
            let r ← checkAgainstMonads t tail
            pure <| Option.map Nat.succ r

partial
def breakApp (commandNames : List Expr) (appExpr : Expr) (argStack : List Expr) (recDepthLeft : Nat): TermElabM Expr := do
    if recDepthLeft == 0
    then pure <| mqError "recursion depth limit exceeded"
    else
    -- check for common app values: bind, pure
    match appExpr with
    | app f arg _ => breakApp commandNames f (arg :: argStack) (recDepthLeft - 1)
    | letE n t v body _ => pure <| mqError (toString appExpr)
    | const c _ _ =>
        match c with
        | ``Bind.bind =>
            let b1 ← match argStack.get? 4 with
                        | Option.none => pure <| mqError "bad arg 1 to bind"
                        | Option.some x => breakApp commandNames x argStack (recDepthLeft - 1)
            let b2 ← match argStack.get? 5 with
                        | Option.none => pure <| mqError "bad arg 2 to bind"
                        | Option.some x => breakApp commandNames x ((mqError "nonDet arg from bind") :: argStack) (recDepthLeft - 1)
            pure <| Lean.mkApp (Lean.mkApp (Lean.mkConst ``MonadSequence.Bind) b1) b2
        | ``Pure.pure => pure <| Lean.mkConst ``MonadSequence.Pure -- (argStack.get! 2)
        | ``Sendable.send => do
            let sending := argStack.get! 4
            let et ← inferType sending
            goExpr et 0
            let m ← checkAgainstMonads et commandNames
            --logInfo argStack
            match m with
            | Option.none => pure <| Lean.mkApp (Lean.mkConst ``MonadSequence.Command) (Lean.mkStrLit "send")--(argStack.get! 4)))
            | Option.some ix => pure <| Lean.mkApp (Lean.mkConst ``MonadSequence.Command) (Lean.mkStrLit ("send " ++ toString ix))--(argStack.get! 4)))
        | ``ite => pure <| Lean.mkApp (Lean.mkConst ``MonadSequence.Error) (Lean.mkStrLit "if then else")
        | _ => do
            let e ← getEnv
            let v := e.find? c
            match v with
            | Option.none => pure <| mqError ("Unknown const " ++ toString c)
            | Option.some v => do
                /-let et ← inferType v.value!
                --goExpr et 0
                let m ← monadMatch et i1
                if m
                then pure <| Lean.mkApp (Lean.mkConst ``MonadSequence.Command) (Lean.mkStrLit "match")--(argStack.get! 4)))
                else -/
                    breakApp commandNames v.value! argStack (recDepthLeft - 1)
    | lam _ _ body _ =>
        let peBody := dirtyBR body argStack 0
        --goExpr peBody 0
        breakApp commandNames peBody argStack (recDepthLeft - 1)
    | bvar ix _ => pure <| Option.getD (argStack.get? ix) (mqError "bad bound variable")
    | _ => pure <| mqError ("unknown term: " ++ toString appExpr)--Lean.mkConst ``MonadSequence.Empty

elab "walkExpr" thing:term : term => walkExpr thing

elab "breakExpr" thing:term : term => do
    let thingExpr ← elabTerm thing Option.none
    breakApp [] thingExpr [] 100

elab "breakFreerExpr" thing:term " :? " commands:term,+ " ?: " : term => do
    let cmdArr : Array Syntax := ↑commands
    let cmdExprs : Array Expr ← cmdArr.sequenceMap (fun e => elabTerm e Option.none)
    let thingExpr ← elabTerm thing Option.none
    breakApp (Array.toList cmdExprs) thingExpr [] 50
    --pure <| Lean.mkStrLit "zoot!"
    
#eval walkExpr ((do let z ← pure 3; IO.println z) : IO Unit)
#eval breakExpr ((IO.println 4) : IO Unit)
#eval breakFreerExpr ((do IO.print 3; IO.print 4; pure 5) : IO Nat) :? IO ?:

def zzz : Nat → IO Unit := fun _ => IO.print "argh"

#eval breakExpr (fun n => if n < 3 then "argh" else "ack")
#check @Pure.pure

def z':= Lean.mkConst `Nat.zero

#eval z'

end Deconstruct