<html>
<head>
<meta charset="utf-8"></meta><title>leanprover/lake</title>
<link rel="stylesheet" href="./static/style.css"></link></head>
<body>
<header>
<h1>
<a href="./">Reservoir</a>
</h1>
<input placeholder="Text in here to navigate!"></input><ul>
<li>
<a href="#">About</a>
</li>
<li>
<a href="#">New</a>
</li>
<li>
<a href="#">Trending</a>
</li>
</ul>
</header>
<main>
<h1>leanprover/lake</h1>
<p>Lean 4 build system and package manager with configuration files written in Lean.</p>
<a href="https://github.com/leanprover/lake">GitHub Link</a>
<a href="#" title="Missing now!">Documentation</a>
<h2>Pick a version!</h2>
<p>TODO: should show a time axes that allows the users to view, filter and click copy the lakefile config.</p>
<h2>README</h2>
<div class="md" data-path="README.md" id="readme"><article class="markdown-body entry-content container-lg" itemprop="text"><h3 dir="auto">Lake</h3>
<p dir="auto">Lake (Lean Make) is a new build system and package manager for Lean 4.
With Lake, the package's configuration is written in Lean inside a dedicated <code>lakefile.lean</code> stored in the root of the package's directory.</p>
<p dir="auto">Each <code>lakefile.lean</code> includes a <code>package</code> declaration (akin to <code>main</code>) which defines the package's basic configuration. It also typically includes build configurations for different targets (e.g., Lean libraries and binary executables) and Lean scripts to run on the command line (via <code>lake script run</code>).</p>
<p dir="auto"><em><strong>This README provides information about Lake relative to the current commit. If you are looking for documentation for the Lake version shipped with a given Lean nightly, you should look at the README of that version.</strong></em></p>
<h4 dir="auto">Table of Contents</h4>
<ul dir="auto">
<li><a href="#getting-lake">Getting Lake</a></li>
<li><a href="#creating-and-building-a-package">Creating and Building a Package</a></li>
<li><a href="#package-configuration-options">Package Configuration Options</a></li>
<li><a href="#defining-build-targets">Defining Build Targets</a>
<ul dir="auto">
<li><a href="#lean-libraries">Lean Libraries</a></li>
<li><a href="#binary-executables">Binary Executables</a></li>
<li><a href="#external-libraries">External Libraries</a></li>
<li><a href="#custom-targets">Custom Targets</a></li>
</ul>
</li>
<li><a href="#adding-dependencies">Adding Dependencies</a>
<ul dir="auto">
<li><a href="#syntax-of-require">Syntax of <code>require</code></a></li>
</ul>
</li>
<li><a href="#writing-and-running-scripts">Writing and Running Scripts</a></li>
<li><a href="#building-and-running-lake-from-the-source">Building and Running Lake from the Source</a>
<ul dir="auto">
<li><a href="#building-with-nix-flakes">Building with Nix Flakes</a></li>
<li><a href="#augmenting-lakes-search-path">Augmenting Lake's Search Path</a></li>
</ul>
</li>
</ul>
<h4 dir="auto">Getting Lake</h4>
<p dir="auto">Lake is part of the <a href="https://github.com/leanprover/lean4">lean4</a> repository and is distributed along with its official releases (e.g., as part of the <a href="https://github.com/leanprover/elan">elan</a> toolchain). So if you have installed a semi-recent Lean 4 nightly, you should already have it!</p>
<p dir="auto">Note that the Lake included with Lean is not updated as frequently as this repository, so some bleeding edge features may be missing. If you want to build the latest version from the source yourself, check out the <a href="#building-and-running-lake-from-the-source">build instructions</a> at the bottom of this README.</p>
<h4 dir="auto">Creating and Building a Package</h4>
<p dir="auto">To create a new package, either run <code>lake init <package-name> [<template>]</code> to setup the package in the current directory or <code>lake new <package-name> [<template>]</code> to create it in a new directory. For example, we could create the package <code>hello</code> like so:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ mkdir hello
$ cd hello
$ lake init hello"><pre class="notranslate"><code>$ mkdir hello
$ cd hello
$ lake init hello
</code></pre></div>
<p dir="auto">or like so:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ lake new hello
$ cd hello"><pre class="notranslate"><code>$ lake new hello
$ cd hello
</code></pre></div>
<p dir="auto">Either way, Lake will initialize a git repository in the package directory with a basic <code>.gitignore</code> that ignores the build directory (i.e., <code>build</code>) where Lake outputs build files.</p>
<p dir="auto">It will also create the root Lean file for the package's library, which uses the capitalized version of the package's name (e.g., <code>Hello.lean</code> in this example), and the root file for the package's binary <code>Main.lean</code>. They contain the following dummy "Hello World" program split across the two files:</p>
<p dir="auto"><strong>Hello.lean</strong></p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="def hello := "world""><pre><span class="pl-k">def</span> <span class="pl-en">hello</span> := <span class="pl-s"><span class="pl-pds">"</span>world<span class="pl-pds">"</span></span></pre></div>
<p dir="auto"><strong>Main.lean</strong></p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="import Hello

def main : IO Unit :=
  IO.println s!"Hello, {hello}!""><pre><span class="pl-k">import</span> Hello

<span class="pl-k">def</span> <span class="pl-en">main</span> : IO Unit :=
  IO.println s!<span class="pl-s"><span class="pl-pds">"</span>Hello, {hello}!<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">Lake also creates a basic <code>lakefile.lean</code> for the package along with a <code>lean-toolchain</code> file that contains the version string of the currently active Lean, which tells <a href="https://github.com/leanprover/elan"><code>elan</code></a> to use that Lean toolchain for the package.</p>
<p dir="auto"><strong>lakefile.lean</strong></p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="import Lake
open Lake DSL

package hello {
  -- add package configuration options here
}

lean_lib Hello {
  -- add library configuration options here
}

@[defaultTarget]
lean_exe hello {
  root := `Main
}"><pre><span class="pl-k">import</span> Lake
<span class="pl-k">open</span> Lake DSL

package hello {
  <span class="pl-c"><span class="pl-c">--</span> add package configuration options here</span>
}

lean_lib Hello {
  <span class="pl-c"><span class="pl-c">--</span> add library configuration options here</span>
}

<span class="pl-k">@[defaultTarget]</span>
lean_exe hello {
  root := <span class="pl-en">`Main</span>
}</pre></div>
<p dir="auto">The command <code>lake build</code> can then be used to build the package (and its <a href="#adding-dependencies">dependencies</a>, if it has them) into a native executable. The result will be placed in <code>build/bin</code>.</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ lake build
...
$ ./build/bin/hello
Hello, world!"><pre class="notranslate"><code>$ lake build
...
$ ./build/bin/hello
Hello, world!
</code></pre></div>
<p dir="auto">Examples of different package configurations can be found in the <a href="examples"><code>examples</code></a> folder of this repository. You can also specified a particular configuration file template when using <code>lake init</code> or <code>lake new</code> to control what files Lake creates. See <code>lake help init</code> or <code>lake help new</code> for details.</p>
<h4 dir="auto">Package Configuration Options</h4>
<p dir="auto">Lake provides a large assortment of configuration options for packages.</p>
<p dir="auto"><strong>Workspace Options</strong></p>
<p dir="auto">Workspace options are shared across a package and its dependencies.</p>
<ul dir="auto">
<li><code>packagesDir</code>: The directory to which Lake should download remote dependencies. Defaults to <code>lean_packages</code>.</li>
</ul>
<p dir="auto"><strong>Per Package Options</strong></p>
<ul dir="auto">
<li><code>srcDir</code>: The directory containing the package's Lean source files. Defaults to the package's directory. (This will be passed to <code>lean</code> as the <code>-R</code> option.)</li>
<li><code>buildDir</code>: The directory to which Lake should output the package's build results. Defaults to <code>build</code>.</li>
<li><code>oleanDir</code>: The build subdirectory to which Lake should output the package's <code>.olean</code> files. Defaults to <code>lib</code>.</li>
<li><code>irDir</code>: The build subdirectory to which Lake should output the package's intermediary results (e.g., <code>.c</code> and <code>.o</code> files). Defaults to <code>ir</code>.</li>
<li><code>libDir</code>: The build subdirectory to which Lake should output the package's libraries. Defaults to <code>lib</code>.</li>
<li><code>binDir</code>: The build subdirectory to which Lake should output the package's binary executables. Defaults to <code>bin</code>.</li>
<li><code>precompileModules</code>:  Whether to compile each module into a native shared library that is loaded whenever the module is imported. This speeds up the evaluation of metaprograms and enables the interpreter to run functions marked <code>@[extern]</code>. Defaults to <code>false</code>.</li>
<li><code>isLeanOnly</code>: Whether the package is "Lean-only". A Lean-only package does not produce native files for modules (e.g. <code>.c</code>, <code>.o</code>). Defaults to <code>false</code>. Setting <code>precompileModules</code> to <code>true</code> will override this setting and produce native files anyway (as they are needed to build module dynlibs).</li>
<li><code>moreServerArgs</code>:  Additional arguments to pass to the Lean language server (i.e., <code>lean --server</code>) launched by <code>lake serve</code>.</li>
<li><code>buildType</code>: The <code>BuildType</code> of targets in the package (see <a href="https://stackoverflow.com/a/59314670" rel="nofollow"><code>CMAKE_BUILD_TYPE</code></a>). One of <code>debug</code>, <code>relWithDebInfo</code>, <code>minSizeRel</code>, or <code>release</code>. Defaults to <code>release</code>.</li>
<li><code>moreLeanArgs</code>: An <code>Array</code> of additional arguments to pass to <code>lean</code> while compiling Lean source files.</li>
<li><code>moreLeancArgs</code>: An <code>Array</code> of additional arguments to pass to <code>leanc</code> while compiling the C source files generated by <code>lean</code>. Lake already passes some flags based on the <code>buildType</code>, but you can change this by, for example, adding <code>-O0</code> and <code>-UNDEBUG</code>.</li>
<li><code>moreLinkArgs</code>: An <code>Array</code> of additional arguments to pass to <code>leanc</code> when linking (e.g., binary executables or shared libraries). These will come <em>after</em> the paths of <code>extern_lib</code> targets.</li>
<li><code>extraDepTarget</code>: An extra <code>OpaqueTarget</code> that should be built before the package. <code>Target.collectOpaqueList/collectOpaqueArray</code> can be used combine multiple extra targets into a single <code>extraDepTarget</code>. <strong>DEPRECATED:</strong> Try to use separate <a href="#custom-targets">custom target declarations</a> instead. Otherwise, raise an issue here about your use case.</li>
</ul>
<h4 dir="auto">Defining Build Targets</h4>
<p dir="auto">A Lake package can have many build targets, such as different Lean libraries and multiple binary executables. Any number of these declarations can be marked with the <code>@[defaultTarget]</code> attribute to tell Lake to build them on a bare <code>lake build</code> of the package.</p>
<h5 dir="auto">Lean Libraries</h5>
<p dir="auto">A Lean library target defines a set of Lean modules available to <code>import</code> and how to build them.</p>
<p dir="auto"><strong>Syntax</strong></p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="lean_lib «target-name» {
  -- configuration options go here
}"><pre>lean_lib «<span class="pl-en">target-name</span>» {
  <span class="pl-c"><span class="pl-c">--</span> configuration options go here</span>
}</pre></div>
<p dir="auto"><strong>Configuration Options</strong></p>
<ul dir="auto">
<li><code>roots</code>: The root module(s) of the library. Submodules of these roots (e.g., <code>Lib.Foo</code> of <code>Lib</code>) are considered part of the library. Defaults to a single root of the library's upper camel case name.</li>
<li><code>globs</code>: An <code>Array</code> of module <code>Glob</code>s to build for the library. Defaults to a <code>Glob.one</code> of each of the library's  <code>roots</code>. Submodule globs build every source file within their directory. Local imports of glob'ed files (i.e., fellow modules of the workspace) are also recursively built.</li>
<li><code>libName</code>: The name of the library. Used as a base for the file names of its static and dynamic binaries. Defaults to the upper camel case name of the target.</li>
<li><code>nativeFacets</code>: An <code>Array</code> of module facets to build and combine into the library's static
and shared libraries. Defaults to <code>#[Module.oFacet]</code> (i.e., the object file compiled from the Lean source). <strong>PREVIEW:</strong> Module facets are in beta, unstable, and not yet documented. Use with care.</li>
<li><code>precompileModules</code>, <code>buildType</code>, <code>moreLeanArgs</code>, <code>moreLinkArgs</code>, <code>moreLinkArgs</code>: Augments the package's corresponding configuration option. The library's arguments come after, modules are precompiled if either the library or package are precompiled, and the build type is the minimum of the two (<code>debug</code> is the lowest, and <code>release</code> is the highest)</li>
</ul>
<h5 dir="auto">Binary Executables</h5>
<p dir="auto">A Lean executable target builds a binary executable from a Lean module with a <code>main</code> function.</p>
<p dir="auto"><strong>Syntax</strong></p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="lean_exe «target-name» {
  -- configuration options go here
}"><pre>lean_exe «<span class="pl-en">target-name</span>» {
  <span class="pl-c"><span class="pl-c">--</span> configuration options go here</span>
}</pre></div>
<p dir="auto"><strong>Configuration Options</strong></p>
<ul dir="auto">
<li><code>root</code>: The root module of the binary executable. Should include a <code>main</code> definition that will serve as the entry point of the program. The root is built by recursively building its local imports (i.e., fellow modules of the workspace). Defaults to the name of the target.</li>
<li><code>exeName</code>: The name of the binary executable. Defaults to the target name with any <code>.</code> replaced with a <code>-</code>.</li>
<li><code>supportInterpreter</code>: Whether to expose symbols within the executable to the Lean interpreter. This allows the executable to interpret Lean files (e.g., via <code>Lean.Elab.runFrontend</code>). Implementation-wise, this passes <code>-rdynamic</code> to the linker when building on a non-Windows systems. Defaults to <code>false</code>.</li>
<li><code>buildType</code>, <code>moreLeanArgs</code>, <code>moreLinkArgs</code>, <code>moreLinkArgs</code>: Augments the package's corresponding configuration option. The executable's arguments come after and the build type is the minimum of the two (<code>debug</code> is the lowest, and <code>release</code> is the highest).</li>
</ul>
<h5 dir="auto">External Libraries</h5>
<p dir="auto">A external library target is a non-Lean <strong>static</strong> library that will be linked to the binaries of the package and its dependents (e.g., their shared libraries and executables).</p>
<p dir="auto"><strong>Syntax</strong></p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="extern_lib «target-name» :=
  -- term of type `FileTarget` that builds the external library"><pre>extern_lib «<span class="pl-en">target-name</span>» :=
  <span class="pl-c"><span class="pl-c">--</span> term of type `FileTarget` that builds the external library</span></pre></div>
<h5 dir="auto">Custom Targets</h5>
<p dir="auto">A arbitrary target that can be built via <code>lake build <target-name></code>.</p>
<p dir="auto"><strong>Syntax</strong></p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="target «target-name» : α :=
  -- term of type `BuildTarget α` that builds the target"><pre>target «<span class="pl-en">target-name</span>» : α :=
  <span class="pl-c"><span class="pl-c">--</span> term of type `BuildTarget α` that builds the target</span></pre></div>
<h4 dir="auto">Adding Dependencies</h4>
<p dir="auto">Lake packages can have dependencies. Dependencies are other Lake packages the current package needs in order to function. They can be sourced directly from a local folder (e.g., a subdirectory of the package) or come from remote Git repositories. For example, one can depend on the Lean 4 port of <a href="https://github.com/leanprover-community/mathlib4">mathlib</a> like so:</p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="package hello

require mathlib from git
  "https://github.com/leanprover-community/mathlib4.git""><pre>package hello

require mathlib <span class="pl-k">from</span> git
  <span class="pl-s"><span class="pl-pds">"</span>https://github.com/leanprover-community/mathlib4.git<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">The next run of <code>lake build</code> (or refreshing dependencies in an editor like VSCode) will clone the mathlib repository and build it. Information on the specific revision cloned will then be saved to <code>manifest.json</code> in the workspace's <code>packageDir</code> (by default, <code>lean_packages</code>) to enable reproducibility. To update <code>mathlib</code> after this, you will need to run <code>lake update</code> -- other commands do not update resolved dependencies.</p>
<p dir="auto">For a theorem proving packages which depend on <code>mathlib</code>, you can also run <code>lake new <package-name> math</code> to generate a package configuration file that already has the <code>mathlib</code> dependency (and no binary executable target).</p>
<h5 dir="auto">Syntax of <code>require</code></h5>
<p dir="auto">The <code>require</code> command has two forms:</p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="require foo from "path"/"to"/"local"/"package" with ["optional","args"]
require bar from git "url.git"@"rev"/"optional"/"path-to"/"dir-with-pkg""><pre>require foo <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">"</span>path<span class="pl-pds">"</span></span>/<span class="pl-s"><span class="pl-pds">"</span>to<span class="pl-pds">"</span></span>/<span class="pl-s"><span class="pl-pds">"</span>local<span class="pl-pds">"</span></span>/<span class="pl-s"><span class="pl-pds">"</span>package<span class="pl-pds">"</span></span> <span class="pl-k">with</span> [<span class="pl-s"><span class="pl-pds">"</span>optional<span class="pl-pds">"</span></span>,<span class="pl-s"><span class="pl-pds">"</span>args<span class="pl-pds">"</span></span>]
require bar <span class="pl-k">from</span> git <span class="pl-s"><span class="pl-pds">"</span>url.git<span class="pl-pds">"</span></span>@<span class="pl-s"><span class="pl-pds">"</span>rev<span class="pl-pds">"</span></span>/<span class="pl-s"><span class="pl-pds">"</span>optional<span class="pl-pds">"</span></span>/<span class="pl-s"><span class="pl-pds">"</span>path-to<span class="pl-pds">"</span></span>/<span class="pl-s"><span class="pl-pds">"</span>dir-with-pkg<span class="pl-pds">"</span></span></pre></div>
<p dir="auto">The first form adds a local dependency and the second form adds a Git dependency. For a Git dependency, the revision can be a commit hash, branch, or tag. Also, the <code>@"rev"</code> and <code>/"path-to"/"term"</code> parts of the <code>require</code> are optional.</p>
<p dir="auto">Both forms also support an optional <code>with</code> clause to specify arguments to pass to the dependency's package configuration (i.e., same as <code>args</code> in a <code>lake build -- <args...></code> invocation). The elements of both the <code>from</code> and <code>with</code> clauses are proper terms so normal computation is supported within them (though parentheses made be required to disambiguate the syntax).</p>
<h4 dir="auto">Writing and Running Scripts</h4>
<p dir="auto">A configuration file can also contain a number of <code>scripts</code> declaration. A script is an arbitrary <code>(args : List String) → ScriptM UInt32</code> definition that can be run by <code>lake script run</code>. For example, given the following <code>lakefile.lean</code>:</p>
<div class="highlight highlight-source-lean notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="import Lake
open Lake DSL

package scripts

/--
Display a greeting

USAGE:
  lake run greet [name]

Greet the entity with the given name. Otherwise, greet the whole world.
-/
script greet (args) do
  if h : 0 < args.length then
    IO.println s!"Hello, {args.get 0 h}!"
  else
    IO.println "Hello, world!"
  return 0"><pre><span class="pl-k">import</span> Lake
<span class="pl-k">open</span> Lake DSL

package scripts

<span class="pl-c">/--</span>
<span class="pl-c">Display a greeting</span>
<span class="pl-c"></span>
<span class="pl-c">USAGE:</span>
<span class="pl-c">  lake run greet <span class="pl-pds">[</span><span class="pl-corl">name</span><span class="pl-pds">]</span></span>
<span class="pl-c"></span>
<span class="pl-c">Greet the entity with the given name. Otherwise, greet the whole world.</span>
<span class="pl-c">-/</span>
script greet (args) <span class="pl-k">do</span>
  <span class="pl-k">if</span> h : <span class="pl-c1">0</span> < args.length <span class="pl-k">then</span>
    IO.println s!<span class="pl-s"><span class="pl-pds">"</span>Hello, {args.get 0 h}!<span class="pl-pds">"</span></span>
  <span class="pl-k">else</span>
    IO.println <span class="pl-s"><span class="pl-pds">"</span>Hello, world!<span class="pl-pds">"</span></span>
  return <span class="pl-c1">0</span></pre></div>
<p dir="auto">The script <code>greet</code> can be run like so:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ lake script run greet
Hello, world!
$ lake script run greet me
Hello, me!"><pre class="notranslate"><code>$ lake script run greet
Hello, world!
$ lake script run greet me
Hello, me!
</code></pre></div>
<p dir="auto">You can print the docstring of a script with <code>lake script doc</code>:</p>
<div class="snippet-clipboard-content notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ lake script doc greet
Display a greeting

USAGE:
  lake run greet [name]

Greet the entity with the given name. Otherwise, greet the whole world."><pre class="notranslate"><code>$ lake script doc greet
Display a greeting

USAGE:
  lake run greet [name]

Greet the entity with the given name. Otherwise, greet the whole world.
</code></pre></div>
<h4 dir="auto">Building and Running Lake from the Source</h4>
<p dir="auto">If you already have a Lean installation with <code>lake</code> packaged with it, you can build a new <code>lake</code> by just running <code>lake build</code>.</p>
<p dir="auto">Otherwise, there is a pre-packaged <code>build.sh</code> shell script that can be used to build Lake. It passes it arguments down to a <code>make</code> command. So, if you have more than one core, you will probably want to use a <code>-jX</code> option to specify how many build tasks you want it to run in parallel. For example:</p>
<div class="highlight highlight-source-shell notranslate position-relative overflow-auto" data-snippet-clipboard-copy-content="$ ./build.sh -j4"><pre>$ ./build.sh -j4</pre></div>
<p dir="auto">After building, the <code>lake</code> binary will be located at <code>build/bin/lake</code> and the library's <code>.olean</code> files will be located in <code>build/lib</code>.</p>
<h5 dir="auto">Building with Nix Flakes</h5>
<p dir="auto">It is also possible to build Lake with the Nix setup <code>buildLeanPackage</code> from the <a href="https://github.com/leanprover/lean4"><code>lean4</code></a> repository. To do so, you need to have Nix installed with flakes enabled. It is recommended to also set up the Lean 4 binary cache as described in the Lean 4 repository.</p>
<p dir="auto">It is then possible to build Lake with <code>nix build .</code> or run it from anywhere with <code>nix run github:leanprover/lake</code>.</p>
<p dir="auto">A development environment with Lean 4 installed can be loaded automatically by running <code>nix develop</code> or automatically on <code>cd</code> with <code>direnv</code> by running <code>direnv allow</code>.</p>
<p dir="auto">The versions of <code>nixpkgs</code> and <code>lean4</code> are fixed to specific hashes. They can be updated by running <code>nix flake update</code>.</p>
<p dir="auto">Thank Anders Christiansen Sørby (<a href="https://github.com/Anderssorby">@Anderssorby</a>) for this support!</p>
<h5 dir="auto">Augmenting Lake's Search Path</h5>
<p dir="auto">The <code>lake</code> executable needs to know where to find the <code>.olean</code> files for the modules used in the package configuration file. Lake will intelligently setup an initial search path based on the location of its own executable and <code>lean</code>.</p>
<p dir="auto">Specifically, if Lake is co-located with <code>lean</code> (i.e., there is <code>lean</code> executable in the same directory as itself), it will assume it was installed with Lean and that both Lean and Lake are located in <code><lean-home>/bin</code> with Lean's <code>.olean</code> files at <code><lean-home/lib/lean</code> and Lake's <code>.olean</code> files at <code><lean-home/lib/lean</code>. Otherwise, it will run <code>lean --print-prefix</code> to find Lean's home and assume that its <code>.olean</code> files are at <code><lean-home>/lib/lean</code> and that <code>lake</code> is at <code><lake-home>/bin/lake</code> with its <code>.olean</code> files at <code><lake-home>/lib</code>.</p>
<p dir="auto">This search path can be augmented by including other directories of <code>.olean</code> files in the <code>LEAN_PATH</code> environment variable, allowing the user to correct Lake's search if the <code>.olean</code> files for Lean (or Lake itself) are in non-standard locations. However, such directories will <em>not</em> take precedence over the initial search path. This is important in development, as it prevents the Lake version being used to build Lake from using the Lake version being built's <code>.olean</code> files to elaborate Lake's <code>lakefile.lean</code> (which can lead to all kinds of errors).</p>
</article></div></main>
</body>
</html>